/*!
  @file
  qcril_cm.c

  @brief
  Handles RIL requests for CM (MM - Multimode Services)


*/
/*===========================================================================

  Copyright (c) 2009 - 2010 Qualcomm Technologies, Inc. All Rights Reserved

  Qualcomm Technologies Proprietary

  Export of this technology or software is regulated by the U.S. Government.
  Diversion contrary to U.S. law prohibited.

  All ideas, data and information contained in or disclosed by
  this document are confidential and proprietary information of
  Qualcomm Technologies, Inc. and all rights therein are expressly reserved.
  By accepting this material the recipient agrees that this material
  and the information contained therein are held in confidence and in
  trust and will not be used, copied, reproduced in whole or in part,
  nor its contents revealed in any manner to others without the express
  written permission of Qualcomm Technologies, Inc.

===========================================================================*/

/*===========================================================================

                        EDIT HISTORY FOR MODULE

This section contains comments describing changes made to the module.
Notice that changes are listed in reverse chronological order.

$Header: //linux/pkgs/proprietary/qc-ril/main/source/qcril_cm.c#84 $

when       who     what, where, why
--------   ---     ---------------------------------------------------------- 
03/04/10   pg      Update GW call id and presentation when receiving 
                   CALL_EVENT_SETUP_IND.  
                   Update GW call name and presentation when receiving
                   CALL_EVENT_CNAP_INFO_RECEIVED.
03/04/10   sk      Added DSAC changes with Featurization
02/25/10   sb      Drop MT SMS if mobile is in Emergency Callback state.
02/09/10   pg      Added support to indicate call re-establishment to UI.
12/09/09   sb      Replace existing call if get an incoming event with same
                   call id.
11/19/09   js      Support for Illegal Card State
11/12/09   sb      Added sanity timer to info rec processing.
11/05/09   pg      Fixed no Emergency callback mode after emergency call over
                   flash.
10/21/09   pg      Send success response to RIL_REQUEST_CDMA_SET_SUBSCRIPTION 
                   when the request is the same as the current setting.
                   Do not wait for CM_PH_COMMAND_CALLBACK for 
                   cm_ph_cmd_change_rtre_config() as we might not get command 
                   callback for this cm command.
09/24/09   pg      Initialized dial number for CDMA voice call with digit_mode 
                   set to CM_DIGIT_MODE_4BIT_DTMF so that it allows more 
                   dialing digits to be included in Origination Message.
09/21/09   pg      Report UNSOL_NETWORK_STATE_CHANGE when HDR active protocol
                   is updated.
                   Fixed Registration State info when phone is in Hybrid mode 
                   and only HDR is available.
                   Fixed data type mismatched issue in Rgistration State info
                   response.
09/16/09   sb      Set call_fail_cause when cmd callback fails.
09/15/09   sb      Added support for Extended Burst Type International DBM.
07/28/09   pg      At power up time, return the radio state associated with 
                   the previously acquired network mode toavoid constant 
                   phone images swapping.
                   Do not return both UNSOL_RADIO_STATE_CHANGE and 
                   UNSOL_NETWORK_STATE_CHANGE for the same CM event.
07/23/09   sb      If the phone receives an incoming event for a voice call
                   in CDMA while a voice call is already up, auto-answer it.
07/17/09   pg      Added default support for CDMA registration reject cause.
07/08/09   pg      Added support to handle multiple TTY modes when setting up
                   voice calls.
06/15/09   nrn     Adding support for NAM programming
06/15/09   nd      Added support to check the CDMA emergency flash number in ECC property file.
06/15/09   nd      Added support for CDMA Time of Day.
06/15/09   fc      Changes to fix the race condition of event thread processed
                   the CM_CALL_EVENT_ORIG before call id of the corresponding
                   entry in reqlist being updated.
                   Removed ecc_mutex.
06/06/09   nrn     Adding support for Authentication and Registration Reject
06/03/09   nd      Added support for Otasp/Otapa.
06/01/09   fc      Changes to disable the CDMA and GW subscrition separately.
06/01/09   sk      Changes related to CM_SS_EVENT_EMERG_NUM_LIST handling
05/30/09   pg      Fixed available radio technology when in Hybrid mode.
                   Verify set_preferred_network_mode request for 1XEVDO without
                   checking the returned acq_ord_pref field.
05/29/09   fc      Added support for FTM mode.
05/28/09   fc      Changes to response generic failure if failed to register
                   for manual selection.
05/28/09   nrn     Adding ussd fix for correcting the length 
05/27/09   nd      Fixed the issue with NITZ when dst+universal time are set.
05/26/09   fc      Changes to report the correct last call fail reason for
                   network initiated call end.
05/26/09   fc      Changes to enforce syncing of subscription state with 
                   CM_EVENT_PH_INFO since it could be out of sync if 
                   ril-daemon stopped through ABD shell.
05/18/09   fc      Changes to log debug messages to Diag directly instead
                   of through logcat.
                   Changes to support profiling of AMSS events.
                   Fixed the issue of wrong NITZ DST calculation.
05/14/09   pg      Added support for CDMA phase II under FEATURE_MULTIMODE_ANDROID_2.
                   Mainlined FEATURE_MULTIMODE_ANDROID.
05/11/09   fc      Fixed the issue of not initialized unused fields
                   in GW origination parameters. 
                   Replaced banned API sscanf().
05/07/08   fc      Fixed the issue of reporting wrong CLIR in the response to
                   RIL_REQUEST_GET_CLIR, not honoring setting of CLIR to 
                   QCRIl_CM_SS_CLIR_PRESENTATION_INDICATOR in 
                   RIL_REQUEST_SET_CLIR, not storing CLIR persistently and
                   use wrong default CLIR setting in RIL_REQUEST_DIAL.
05/06/09   fc      Changes for GSM NITZ.
04/29/09   pg      Added support for Auto-Answer.
04/28/09   fc      Added support to perform card powerup/powerdown for
                   LPM to ONLINE or vice versa transition. 
04/14/09   fc      Changes on debug messages.
04/13/09   fc      Changes to de-register noisy CM events whenever screen off
                   for power optimization.
                   Fixes on invalid parameter passing and function call.
04/07/09   fc      Fixed the issue of cell ID change not being reported 
                   because of incorrectly defaulting location update to 
                   disabled and not detecting CM_SS_CELL_INFO_MASK. 
04/05/09   fc      Cleanup log macros and mutex macros.
                   Fixed the issue of bogus pointer being reported in the
                   payload of RIL_UNSOL_SUPP_SVC_NOTIFICATION.
                   Fixed the issue in cell selection failure caused by
                   redundant call to cm_ph_cmd_sys_sel_pref(). 
03/30/09   fc      Merged the changes to use cm_mm_call_cmd_end() if there is
                   only one call which is the active call.
02/25/09   fc      Added ONS support for NITZ.
03/16/09   pg      Mainline FEATURE_CM_UTIL_RPC_AVAIL.
02/24/09   fc      Corrected the callback function pointer to NULL.
02/23/09   fc      Changes on debug messages.
02/15/09   fc      Comments changes per code review comments.
02/09/09   fc      Changed to force RTRE config to NV subscription in case of 
                   NV RTRE config set to CM_RTRE_CONFIG_RUIM_OR_DROP_BACK, but
                   runtime control of RTRE config is not enabled. 
02/09/09   fc      Changed the power up sequence to start with Radio State 
                   Unavailable, to command CM to LPM and subscription 
                   unavailable, and to wait for the very first CM_PH_EVENT_INFO 
                   before reading RTRE configuration and transition to Radio
                   State Off.
02/06/09   pg      Always initialize number plan for dialed number to 
                   CM_NUM_PLAN_ISDN.
02/04/09   pg      Call cmutil RPC APIs when FEATURE_CM_UTIL_RPC_AVAIL is
                   defined.
01/30/09   pg      Get band/mode capability from CM_PH_EVENT_INFO.
01/28/09   pg      If NV_PREF_MODE_I is set to CDMA_ONLY, HDR_ONLY, or CDMA_AND_HDR, 
                   enable CDMA subscription.  
                   A temporary solution until CM API is available.
01/26/09   fc      Logged assertion info.
01/19/09   pg      Activate QCRIL CM client regardless if any of cm event 
                   registration fail.
01/14/06   fc      Changes to report "Limited Service" as "No Service" in
                   (GPRS) Registration State payload.
                   Fixed the issue of dereferencing the sys_mode field without 
                   first checking the srv_status field of RSSI event in 
                   multi-mode implementation. 
01/08/09   fc      Mainlined FEATURE_MODEM_UPGRADE_2.
12/25/08   fc      Fixed the issue of never calling OnRequestComplete() for 
                   RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE.
12/21/08   fc      Cleanup the internal token ID implementation.
12/16/08   fc      Fixed NITZ time reporting.
                   Changes to support the release of AMSS CM object for ONCRPC.
                   Changes to allow configuring the preferred network type to 
                   automatic setting.
                   Fixed RIL_REQUEST_HANGUP to specify the correct call mode
                   as call end parameters even in case of short fade.
                   Fixed RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE implementation
                   that was broken by multi-mode change of disabled the powerup
                   one-time query of HW band mode capability. 
12/08/08   pg      Added support to pass CDMA voice privacy mode to RILD.
                   For multi-mode, Radio State is now changed 
                   from RADIO_STATE_NV_READY to RADIO_STATE_SIM_READY when 
                   modem acquires GW system.
                   Fixed RIL_REQUEST_ANSWER to pass in correct mode_info.
                   Changed RIL_REQUEST_DIAL handler so that call origination 
                   is passed to CM even there is no services.
11/14/08   pg      Read NV_PREF_MODE_I to determine whether CDMA subscription
                   should be enabled.  If it's set to CDMA_ONLY, enable CDMA
                   subscription.  A temporary solution until CM API is 
                   available.
11/06/08   pg      Mainlined FEATURE_TEST_CDMA_ON_NON_MULTIMODE_ANDROID.
10/29/08   pg      Default mode_capability to MODE_DIGITAL_ONLY under
                   FEATURE_TEST_CDMA_ON_NON_MULTIMODE_ANDROID.
10/28/08   pg      Added support for RIL_REQUEST_SET_LOCATION_UPDATES.
                   Changed RIL_REQUEST_OPERATOR API.
                   Added support for call fail reason CALL_FAIL_BARRED.
10/23/08   pg      Report unsol_network_state_change when we receive 
                   CM_SS_EVENT_RSSI if the network state has changed.
10/26/08   pg      Initialize cm orig cmd based on the mode the phone is in.
10/10/08   pg      Change token_id used internally from NULL to 0xFFFFFFFF.
10/01/08   pg      Added code for testing CDMA on non multimode Android.
09/18/08   pg      Comment out some debug messages that causes crash in unit test.
09/18/08   pg      Fixed mapping of CLIR for GW voice origination.
08/29/08   adb     Added mute at end of last voice call. 
08/07/08   pg      Fixed some Mutex problem.
08/07/08   pg      Changed CM event that request DTMF wait on.
08/04/08   tml     Fixed Query facility, set facility, PIN1 and FDN issues
06/11/08   pg      Flaged emergency call as a voice call.
06/09/08   pg      Fixed some call services bugs.
05/28/08   tml     Avoid null pointer access
05/28/08   pg      Added basic call services support.
05/22/08   tml     Fixed memory access issue
05/21/08   jar     Featurized for off target platform compilation and fixed
                   array access out of bound
05/07/08   fc      First cut implementation.
05/04/08   da      Initial framework.

===========================================================================*/

/*===========================================================================

                           INCLUDE FILES

===========================================================================*/

#include <errno.h>
#include <cutils/memory.h>
#include <cutils/properties.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "ril.h"
#include "IxErrno.h"
#include "comdef.h"
#include "qcrili.h"
#include "qcril_cmi.h"
#include "qcril_cm.h"
#include "qcril_cm_api_map.h"
#include "qcril_cm_clist.h"
#include "qcril_cm_ons.h"
#include "qcril_cm_ss.h"
#include "qcril_cm_util.h"
#include "qcril_data.h"
#include "qcril_other_api_map.h"
#include "qcril_pbm_api_map.h"
#include "qcril_reqlist.h"
#include "qcril_arb.h"
#include "qcril_pbm.h"
#include "qcrilhook_oem.h"
#include "qcril_smsi.h"

#ifdef FEATURE_QCRIL_SAR
#include "rfm_sar.h"
#endif /* FEATURE_QCRIL_SAR */


/*===========================================================================

                    INTERNAL DEFINITIONS AND TYPES

===========================================================================*/
/* RADIO_POWER request flow control */
#define MAX_QUEUED_REQUESTS 20


/*===========================================================================

                         LOCAL VARIABLES

===========================================================================*/

/* Variables internal to module qcril_cm.c  */
static qcril_cm_struct_type *qcril_cm;

/* Maximum 20 seconds needed to do system re-selection */
static const struct timeval QCRIL_CM_TIMEVAL_NETSELPOLL = { 20, 0 };

/* Sanity timer for info rec processing */
static const struct timeval QCRIL_CM_TIMEVAL_CDMA_INFO_REC = {0,300000};

static const char *card_status_name[] = { "Unknown", "Not applicable", "Down", "Up", "Not Accessible", "Refresh", "PwrUp Failed", 
                                          "PwrDown Failed" , "Illegal", "Absent" };

/* RADIO_POWER request flow control */
static int radio_on_req[MAX_QUEUED_REQUESTS];
static int radio_off_req[MAX_QUEUED_REQUESTS];
static int num_radio_on_req = 0;
static int num_radio_off_req = 0;

static struct timeval t_rx_previous_waiting_call_id_time = {0,0};
static cm_num_s_type previous_waiting_call_number;
#define CALL_WAITING_DELTA 5  // 5 sec

/*===========================================================================

                    INTERNAL FUNCTION PROTOTYPES

===========================================================================*/
void qcril_send_radio_response_process_blocked_request
( qcril_instance_id_e_type, qcril_modem_id_e_type, RIL_Errno, sys_oprt_mode_e_type, int);
/*===========================================================================

                                FUNCTIONS

===========================================================================*/


/*=========================================================================
  FUNCTION:  qcril_cm_phonesvc_command_callback

===========================================================================*/
/*!
    @brief
    Callback to handle CM Phone command callback.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_cm_phonesvc_command_callback
(
  void                 *data_block_ptr,
  cm_ph_cmd_e_type     ph_cmd,
  cm_ph_cmd_err_e_type ph_cmd_err
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  uint16 req_id;
  qcril_reqlist_public_type req_info;
  qcril_cm_command_callback_params_type params;

  #ifdef FEATURE_QCRIL_SUBS_CTRL
  uint16 subscription_mask;
  #endif /* FEATURE_QCRIL_SUBS_CTRL */

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  user_data = (uint32) data_block_ptr;
  instance_id = QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( user_data );
  modem_id = QCRIL_EXTRACT_MODEM_ID_FROM_USER_DATA( user_data );
  req_id = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA( user_data );
  i_ptr = &qcril_cm[ instance_id ];

  #ifdef FEATURE_QCRIL_SUBS_CTRL
  subscription_mask = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA( user_data );
  #endif /* FEATURE_QCRIL_SUBS_CTRL */

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_SUBS_CTRL
  if ( ph_cmd == CM_PH_CMD_SUBSCRIPTION_AVAILABLE ) 
  {
    if ( ph_cmd_err == CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S ) 
    {
      /* Update GW subscription state */
      if ( subscription_mask & QCRIL_MODE_GW_CONFIG_MASK )
      {
        QCRIL_LOG_DEBUG( "%s", "Pri GW subscription enabled\n" ); 
        i_ptr->ph_info[ modem_id ].pri_gw_subscription_state = QCRIL_CM_SUBSCRIPTION_ENABLED;
      }

      /* Update CDMA subscription state */
      if ( subscription_mask & QCRIL_MODE_1XEVDO_CONFIG_MASK )
      {
        QCRIL_LOG_DEBUG( "%s", "Pri CDMA subscription enabled\n" ); 
        i_ptr->ph_info[ modem_id ].pri_cdma_subscription_state = QCRIL_CM_SUBSCRIPTION_ENABLED;
      }
    }
  }
  else if ( ph_cmd == CM_PH_CMD_SUBSCRIPTION_NOT_AVAILABLE ) 
  {
    if ( ph_cmd_err == CM_PH_CMD_ERR_SUBSCRIPTION_AVAILABLE_S ) 
    {
      /* Update GW subscription state */
      if ( subscription_mask & QCRIL_MODE_GW_CONFIG_MASK )
      {
        QCRIL_LOG_DEBUG( "%s", "Pri GW subscription disabled\n" ); 
        i_ptr->ph_info[ modem_id ].pri_gw_subscription_state = QCRIL_CM_SUBSCRIPTION_DISABLED;
      }

      /* Update CDMA subscription state */
      if ( subscription_mask & QCRIL_MODE_1XEVDO_CONFIG_MASK )
      {
      QCRIL_LOG_DEBUG( "%s", "Pri CDMA subscription disabled\n" ); 
        i_ptr->ph_info[ modem_id ].pri_cdma_subscription_state = QCRIL_CM_SUBSCRIPTION_DISABLED;
      }
    }
  }
  else
  #endif /* FEATURE_QCRIL_SUBS_CTRL */
  if ( ( ph_cmd == CM_PH_CMD_WAKEUP_FROM_STANDBY ) && ( req_id == QCRIL_REQ_ID_INTERNAL ) )
  {
    if ( ph_cmd_err != CM_PH_CMD_ERR_NOERR )
    {
      QCRIL_LOG_ERROR( "RID %d MID %d Wakeup CM from Standby failed with error code %d", instance_id, modem_id, ph_cmd_err );
    }
  }
  else if ( ( req_id != QCRIL_REQ_ID_INTERNAL )
            #ifdef FEATURE_QCRIL_SUBS_CTRL
            && ( ph_cmd != CM_PH_CMD_SUBSCRIPTION_AVAILABLE ) && ( ph_cmd != CM_PH_CMD_SUBSCRIPTION_NOT_AVAILABLE ) 
            #endif /* FEATURE_QCRIL_SUBS_CTRL */
          ) 
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d Received CM_PH_COMMAND_CALLBACK : Req ID %d\n", instance_id, modem_id, req_id );

    /* Lookup the Token ID */
    if ( qcril_reqlist_query_by_req_id( req_id, &instance_id, &req_info ) == E_SUCCESS )
    {
      /* Call CM command callback event handler */
      params.command = QCRIL_CM_COMMAND_PH;
      params.command_info.ph.cmd = ph_cmd;
      params.command_info.ph.cmd_err = ph_cmd_err;
      qcril_event_queue( instance_id, modem_id, QCRIL_DATA_ON_STACK,
                         QCRIL_EVT_CM_COMMAND_CALLBACK, (void *)&params, sizeof( params ), req_info.t );
    }
    else
    {
      QCRIL_LOG_ERROR( "Req ID: %d not found for CM_PH_COMMAND_CALLBACK\n", req_id );
    }
  }
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_phonesvc_command_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_process_phonesvc_event_callback

===========================================================================*/
/*!
    @brief
    Process CM Phone event callback.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_process_phonesvc_event_callback
(
  qcril_instance_id_e_type     instance_id,
  qcril_modem_id_e_type        modem_id,
  cm_ph_event_e_type           ph_event,
  const cm_ph_info_s_type      *ph_info_ptr
)
{                         
  #ifdef FEATURE_QCRIL_DSDS
  uint8 i;
  qcril_instance_id_e_type route_instance_id = instance_id;
  qcril_reqlist_public_type req_info;
  #endif /* FEATURE_QCRIL_DSDS */
  qcril_evt_e_type event_id;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( ph_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Figure out Event ID */
  event_id = QCRIL_EVT_CM_PH_BASE + ph_event;

  QCRIL_LOG_DEBUG( "RID %d MID %d Received phonesvc event : %s (%d)\n", instance_id, modem_id, 
                   qcril_log_lookup_event_name( event_id ), event_id );

  #ifdef FEATURE_QCRIL_DSDS
  if ( qcril_arb_lookup_instance_id_from_as_id( ph_info_ptr->asubs_id, &route_instance_id ) == E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "Route RID %d for %s(%d), as_id %d\n", route_instance_id, 
                     qcril_log_lookup_event_name( event_id ), event_id, ph_info_ptr->asubs_id );
    /* Call event handler for CM Phone Service event */
    qcril_event_queue( route_instance_id, modem_id, QCRIL_DATA_ON_STACK,
                       event_id, (void *) ph_info_ptr, sizeof( cm_ph_info_s_type ), (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    return;
  }
  else
  {
     route_instance_id = (ph_info_ptr->asubs_id == SYS_MODEM_AS_ID_1) ? QCRIL_DEFAULT_INSTANCE_ID: QCRIL_SECOND_INSTANCE_ID;

     if( qcril_reqlist_query_by_event( route_instance_id, modem_id, event_id, &req_info ) == E_SUCCESS )
     {
        QCRIL_LOG_DEBUG( "Route RID %d for %s(%d), as_id %d due to hotswap for pending request\n", route_instance_id,
                         qcril_log_lookup_event_name( event_id ), event_id, ph_info_ptr->asubs_id );

        /* Call event handler for CM Phone Service event */
        qcril_event_queue( route_instance_id, modem_id, QCRIL_DATA_ON_STACK,
                           event_id, (void *) ph_info_ptr, sizeof( cm_ph_info_s_type ), (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
        return;
     }
     else if( ( event_id == QCRIL_EVT_CM_PH_SYS_SEL_PREF ) && ( route_instance_id == QCRIL_DEFAULT_INSTANCE_ID) )
     {
        QCRIL_LOG_DEBUG( "Route RID %d for %s(%d), as_id %d for handling emergency callback mode properly\n", route_instance_id,
                         qcril_log_lookup_event_name( event_id ), event_id, ph_info_ptr->asubs_id );

        /* Call event handler for CM Phone Service event */
        qcril_event_queue( route_instance_id, modem_id, QCRIL_DATA_ON_STACK,
                           event_id, (void *) ph_info_ptr, sizeof( cm_ph_info_s_type ), (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
        return;
     }
  }

  /* For DSDS, AS_ID may not be always available iat the time phone event is received */
  if ( qcril_arb_ma_is_dsds() )
  {
    switch( event_id )
    {
      /* Below events always apply for both the instances */
      case QCRIL_EVT_CM_PH_OPRT_MODE:
      case QCRIL_EVT_CM_PH_DUAL_STANDBY_PREF:
        /* route the ph_ino event to both the instances, filter it out in the event handling.
            this is due to an issue that both command call back and event callback are recevied at same time
            for a pending request when hotswap happens, resulting in not able to route the event to proper instance*/
      case QCRIL_EVT_CM_PH_INFO:
        for ( i = 0; i < QCRIL_MAX_INSTANCE_ID; i++ )
        {
          /* Call event handler for CM Phone Service event */
          QCRIL_LOG_DEBUG( "Route RID %d for %s(%d), as_id %d\n", i,
                           qcril_log_lookup_event_name( event_id ), event_id, ph_info_ptr->asubs_id );
          qcril_event_queue( i, modem_id, QCRIL_DATA_ON_STACK,
                             event_id, (void *) ph_info_ptr, sizeof( cm_ph_info_s_type ),
                             (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
        }
        return;

      default:
        QCRIL_LOG_DEBUG( "Ignore %s(%d)\n", qcril_log_lookup_event_name( event_id ), event_id );
        return;
    }
  }

  /* Call event handler for CM Phone Service event */
  QCRIL_LOG_DEBUG( "Route RID %d for %s(%d), as_id %d\n", instance_id,
                 qcril_log_lookup_event_name( event_id ), event_id, ph_info_ptr->asubs_id );
  #endif /* FEATURE_QCRIL_DSDS */

  qcril_event_queue( instance_id, modem_id, QCRIL_DATA_ON_STACK,
                   event_id, (void *) ph_info_ptr, sizeof( cm_ph_info_s_type ), 
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

} /* qcril_cm_process_phonesvc_event_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_phonesvc_event_callback

===========================================================================*/
/*!
    @brief
    Callback to handle CM Phone event.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_callback
(
  cm_ph_event_e_type           ph_event,
  const cm_ph_info_s_type      *ph_info_ptr
)
{                         
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_DEFAULT_MODEM_ID;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( ph_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process phone event callback */
  qcril_cm_process_phonesvc_event_callback( instance_id, modem_id, ph_event, ph_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_phonesvc_event_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_phonesvc_event_callback_fusion

===========================================================================*/
/*!
    @brief
    Callback to handle CM Phone event for MDM.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_callback_fusion
(
  cm_ph_event_e_type           ph_event,
  const cm_ph_info_s_type      *ph_info_ptr
)
{                         
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_SECOND_MODEM_ID;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( ph_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process Phone Service event callback */
  qcril_cm_process_phonesvc_event_callback( instance_id, modem_id, ph_event, ph_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_phonesvc_event_callback_fusion */


/*=========================================================================
  FUNCTION:  qcril_cm_srvsys_command_callback

===========================================================================*/
/*!
    @brief
    Callback to handle CM Serving System command callback.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_cm_srvsys_command_callback
(
  void                 *data_block_ptr,
  cm_ss_cmd_e_type     ss_cmd,
  cm_ss_cmd_err_e_type ss_cmd_err
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  uint32 user_data;
  uint16 req_id;
  qcril_reqlist_public_type req_info;
  qcril_cm_command_callback_params_type params;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  user_data = ( uint32 ) data_block_ptr;
  instance_id = QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( user_data );
  modem_id = QCRIL_EXTRACT_MODEM_ID_FROM_USER_DATA( user_data );
  req_id = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA( user_data );

  /*-----------------------------------------------------------------------*/

  if ( req_id != QCRIL_TOKEN_ID_INTERNAL )
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d Received CM_SS_COMMAND_CALLBACK : Req ID %d\n", instance_id, modem_id, req_id );

    /* Lookup the Token ID */
    if ( qcril_reqlist_query_by_req_id( req_id, &instance_id, &req_info ) == E_SUCCESS )
    {
      /* Call CM command callback event handler */
      params.command = QCRIL_CM_COMMAND_SS;
      params.command_info.ss.cmd = ss_cmd;
      params.command_info.ss.cmd_err = ss_cmd_err;
      qcril_event_queue( instance_id, modem_id, QCRIL_DATA_ON_STACK, QCRIL_EVT_CM_COMMAND_CALLBACK, 
                         (void *)&params, sizeof( params ), req_info.t );
    }
    else
    {
      QCRIL_LOG_ERROR( "Req ID: %d not found for CM_SS_COMMAND_CALLBACK\n", req_id );
    }
  }
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_srvsys_command_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_process_srvsys_event_callback

===========================================================================*/
/*!
    @brief
    Callback to handle CM Serving System event callback.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_process_srvsys_event_callback
(
  qcril_instance_id_e_type   instance_id,
  qcril_modem_id_e_type      modem_id,
  cm_ss_event_e_type         ss_event,
  const cm_mm_ss_info_s_type *ss_info_ptr
)
{
  qcril_evt_e_type event_id;
  uint8 i = instance_id;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( ss_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Figure out Event ID */
  event_id = QCRIL_EVT_CM_SS_BASE + ss_event;

  QCRIL_LOG_DEBUG( "RID %d MID %d Received srvsys event : %s (%d)\n", instance_id, modem_id, 
                   qcril_log_lookup_event_name( event_id ), event_id );

  /* Call event handler for CM Serving System Service event */

  #ifdef FEATURE_QCRIL_DSDS
  /* Route to all instances for processing */
  for ( i = 0; i < QCRIL_ARB_MAX_INSTANCES; i++ )
  #endif /* FEATURE_QCRIL_DSDS */
  {
    qcril_event_queue( i, modem_id, QCRIL_DATA_ON_STACK,
                       event_id, (void *) ss_info_ptr, sizeof( cm_mm_ss_info_s_type ), (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
  }

} /* qcril_cm_process_srvsys_event_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_srvsys_event_callback

===========================================================================*/
/*!
    @brief
    Callback to handle CM Serving System event callback.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_event_callback
(
  cm_ss_event_e_type           ss_event,
  const cm_mm_ss_info_s_type   *ss_info_ptr
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_DEFAULT_MODEM_ID;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( ss_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process CM Serving System event callback */
  qcril_cm_process_srvsys_event_callback( instance_id, modem_id, ss_event, ss_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_srvsys_event_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_srvsys_event_callback_fusion

===========================================================================*/
/*!
    @brief
    Callback to handle CM Serving System event callback for MDM.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_event_callback_fusion
(
  cm_ss_event_e_type           ss_event,
  const cm_mm_ss_info_s_type   *ss_info_ptr
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_SECOND_MODEM_ID;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( ss_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process CM Serving System event callback */
  qcril_cm_process_srvsys_event_callback( instance_id, modem_id, ss_event, ss_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_srvsys_event_callback_fusion */


#ifdef FEATURE_QCRIL_CALL_ORIG_EXTEN3
/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_command_callback_exten

===========================================================================*/
/*!
    @brief
    Callback to handle CM Call command callback.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_cm_callsvc_command_callback_exten
(
  void                   *data_block_ptr,
  cm_call_cmd_e_type     call_cmd,
  cm_call_cmd_err_e_type call_cmd_err,
  cm_call_cmd_err_cause_e_type  call_cmd_err_cause,
  cm_alpha_s_type               alpha
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  uint32 user_data;
  uint16 req_id;
  qcril_reqlist_public_type req_info;
  qcril_cm_command_callback_params_type params;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( data_block_ptr != NULL );
  user_data = ( uint32 ) data_block_ptr;
  instance_id = QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( user_data );
  modem_id = QCRIL_EXTRACT_MODEM_ID_FROM_USER_DATA( user_data );
  req_id = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA( user_data );

  /*-----------------------------------------------------------------------*/

  if ( req_id != QCRIL_REQ_ID_INTERNAL )
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d Received CM_CALLSVC_COMMAND_CALLBACK : Req ID %d\n", instance_id, modem_id, req_id );
    QCRIL_LOG_DEBUG( "cmd_err = %d, err_cause = %d", call_cmd_err, call_cmd_err_cause);

    /* Lookup the Token ID */
    if ( qcril_reqlist_query_by_req_id( req_id, &instance_id, &req_info ) == E_SUCCESS )
    {
      /* Call CM command callback event handler */
      params.command = QCRIL_CM_COMMAND_CALL;
      params.command_info.call.cmd = call_cmd;
      params.command_info.call.cmd_err = call_cmd_err;
      params.command_info.call.err_cause = call_cmd_err_cause;
      qcril_event_queue( instance_id, modem_id, QCRIL_DATA_ON_STACK, QCRIL_EVT_CM_COMMAND_CALLBACK, 
                         (void *)&params, sizeof( params ), req_info.t );
    }
    else
    {
      QCRIL_LOG_ERROR( "Req ID: %d not found for CM_CALLSVC_COMMAND_CALLBACK\n", req_id );
    }
  }
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_callsvc_command_callback_exten */
#endif /* FEATURE_QCRIL_CALL_ORIG_EXTEN3 */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_command_callback

===========================================================================*/
/*!
    @brief
    Callback to handle CM Call command callback.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_cm_callsvc_command_callback
(
  void                   *data_block_ptr,
  cm_call_cmd_e_type     call_cmd,
  cm_call_cmd_err_e_type call_cmd_err
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  uint32 user_data;
  uint16 req_id;
  qcril_reqlist_public_type req_info;
  qcril_cm_command_callback_params_type params;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( data_block_ptr != NULL );
  user_data = ( uint32 ) data_block_ptr;
  instance_id = QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( user_data );
  modem_id = QCRIL_EXTRACT_MODEM_ID_FROM_USER_DATA( user_data );
  req_id = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA( user_data );

  /*-----------------------------------------------------------------------*/

  if ( req_id != QCRIL_REQ_ID_INTERNAL )
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d Received CM_CALLSVC_COMMAND_CALLBACK : Req ID %d\n", instance_id, modem_id, req_id );

    /* Lookup the Token ID */
    if ( qcril_reqlist_query_by_req_id( req_id, &instance_id, &req_info ) == E_SUCCESS )
    {
      /* Call CM command callback event handler */
      params.command = QCRIL_CM_COMMAND_CALL;
      params.command_info.call.cmd = call_cmd;
      params.command_info.call.cmd_err = call_cmd_err;
      qcril_event_queue( instance_id, modem_id, QCRIL_DATA_ON_STACK, QCRIL_EVT_CM_COMMAND_CALLBACK, 
                         (void *)&params, sizeof( params ), req_info.t );
    }
    else
    {
      QCRIL_LOG_ERROR( "Req ID: %d not found for CM_CALLSVC_COMMAND_CALLBACK\n", req_id );
    }
  }
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_callsvc_command_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_process_callsvc_event_callback

===========================================================================*/
/*!
    @brief
    Process CM Call Services event callback.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_process_callsvc_event_callback
(
  qcril_instance_id_e_type instance_id,
  qcril_modem_id_e_type modem_id,
  cm_call_event_e_type call_event,
  const cm_mm_call_info_s_type *call_info_ptr
)
{
  qcril_instance_id_e_type route_instance_id = instance_id;
  qcril_evt_e_type event_id;
  #ifdef FEATURE_QCRIL_DSDS
  qcril_cm_clist_public_type call_info;
  #endif
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( call_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Figure out Event ID */
  event_id = QCRIL_EVT_CM_CALL_BASE + call_event;

  QCRIL_LOG_DEBUG( "RID %d MID %d Received callsvc event : %s (%d)\n", instance_id, modem_id, 
                   qcril_log_lookup_event_name(event_id), event_id );

  #ifdef FEATURE_QCRIL_DSDS
  if ( qcril_arb_lookup_instance_id_from_as_id( call_info_ptr->asubs_id, &route_instance_id ) != E_SUCCESS )
  {
    route_instance_id = (call_info_ptr->asubs_id == SYS_MODEM_AS_ID_1) ? QCRIL_DEFAULT_INSTANCE_ID: QCRIL_SECOND_INSTANCE_ID;

    if( ( call_info_ptr->call_type != CM_CALL_TYPE_EMERGENCY ) &&
         ( qcril_cm_clist_query_voice_call_id( route_instance_id, modem_id, call_info_ptr->call_id, &call_info ) != E_SUCCESS ) )
    {
      QCRIL_LOG_DEBUG( "Ignore %s(%d)\n", qcril_log_lookup_event_name( event_id ), event_id );
      return;
    }
    else
    {
        if ( call_info_ptr->call_type == CM_CALL_TYPE_EMERGENCY )
        {
           QCRIL_LOG_DEBUG( "Route RID %d for %s(%d), as_id %d for emergency call\n", route_instance_id, qcril_log_lookup_event_name( event_id ), event_id,
                          call_info_ptr->asubs_id );
        }
        else
        {
           QCRIL_LOG_DEBUG( "Route RID %d for %s(%d), as_id %d in case of hotswap for pending call\n", route_instance_id, qcril_log_lookup_event_name( event_id ), event_id,
                          call_info_ptr->asubs_id );
        }
    }
  }
  else
  {
    QCRIL_LOG_DEBUG( "Route RID %d for %s(%d), as_id %d\n", route_instance_id, qcril_log_lookup_event_name( event_id ), event_id, 
                     call_info_ptr->asubs_id );
  }
  #endif /* FEATURE_QCRIL_DSDS */

  /* Call event handler for CM Call Service event */
  qcril_event_queue( route_instance_id, modem_id, QCRIL_DATA_ON_STACK, event_id, (void *) call_info_ptr, 
                     sizeof( cm_mm_call_info_s_type ), (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

} /* qcril_cm_process_callsvc_event_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_callback

===========================================================================*/
/*!
    @brief
    Callback to handle CM Call event callback.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_callback
(
  cm_call_event_e_type call_event,
  const cm_mm_call_info_s_type *call_info_ptr
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_DEFAULT_MODEM_ID;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( call_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process CM Call Services event callback */
  qcril_cm_process_callsvc_event_callback( instance_id, modem_id, call_event, call_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_callsvc_event_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_callback_fusion

===========================================================================*/
/*!
    @brief
    Callback to handle CM Call event callback.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_callback_fusion
(
  cm_call_event_e_type call_event,
  const cm_mm_call_info_s_type *call_info_ptr
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_SECOND_MODEM_ID;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( call_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process CM Call Services event callback */
  qcril_cm_process_callsvc_event_callback( instance_id, modem_id, call_event, call_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_callsvc_event_callback_fusion */


/*=========================================================================
  FUNCTION:  qcril_cm_inband_command_callback

===========================================================================*/
/*!
    @brief
    Callback to handle CM Inband command callback.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_cm_inband_command_callback
(
  void                     *data_block_ptr,
  cm_inband_cmd_e_type     inband_cmd,
  cm_inband_cmd_err_e_type inband_cmd_err
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  uint32 user_data;
  uint16 req_id;
  qcril_reqlist_public_type req_info;
  qcril_cm_command_callback_params_type params;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( data_block_ptr != NULL );
  user_data = ( uint32 ) data_block_ptr;
  instance_id = QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( user_data );
  modem_id = QCRIL_EXTRACT_MODEM_ID_FROM_USER_DATA( user_data );
  req_id = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA( user_data );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "RID %d MID %d Received CM_INBAND_COMMAND_CALLBACK : Req ID %d\n", instance_id, modem_id, req_id );

  /* Lookup the Token ID */
  if ( qcril_reqlist_query_by_req_id( req_id, &instance_id, &req_info ) == E_SUCCESS )
  {
    /* Call CM command callback event handler */
    params.command = QCRIL_CM_COMMAND_INBAND;
    params.command_info.inband.cmd = inband_cmd;
    params.command_info.inband.cmd_err = inband_cmd_err;

    qcril_event_queue( instance_id, modem_id, QCRIL_DATA_ON_STACK, QCRIL_EVT_CM_COMMAND_CALLBACK, 
                       (void *)&params, sizeof( params ), req_info.t );
  }
  else
  {
    QCRIL_LOG_ERROR( "Req ID %d not found for CM_INBAND_COMMAND_CALLBACK\n", req_id );
  }
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_inband_command_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_process_inband_event_callback

===========================================================================*/
/*!
    @brief
    Process CM Inband event callback.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_process_inband_event_callback
(
  qcril_instance_id_e_type instance_id,
  qcril_modem_id_e_type modem_id,
  cm_inband_event_e_type inband_event,
  const cm_inband_info_s_type *inband_info_ptr
)
{
  qcril_instance_id_e_type route_instance_id = instance_id;
  qcril_evt_e_type event_id;
  #ifdef FEATURE_QCRIL_DSDS
  qcril_cm_clist_call_ids_list_type call_ids_list;
  uint8 i;
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( inband_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Figure out Event ID */
  event_id = QCRIL_EVT_CM_INBAND_BASE + inband_event;

  QCRIL_LOG_DEBUG( "RID %d MID %d Received inband event : %s (%d)\n", instance_id, modem_id, 
                   qcril_log_lookup_event_name(event_id), event_id );

  #ifdef FEATURE_QCRIL_DSDS
  for ( i = 0; i < QCRIL_ARB_MAX_INSTANCES; i++ )
  {
    /* Check whether there is active or alerting voice call */
    qcril_cm_clist_query_voice_call_ids_list_by_state( i, QCRIL_CM_CLIST_STATE_ACTIVE|QCRIL_CM_CLIST_STATE_ALERTING, 
                                                       &call_ids_list );
    if ( call_ids_list.num_of_call_ids != 0 )
    {
      route_instance_id = i;
      QCRIL_LOG_DEBUG( "Route RID %d for %s(%d)\n", route_instance_id, qcril_log_lookup_event_name( event_id ), event_id ); 
      break;
    }
  }

  if ( i == QCRIL_ARB_MAX_INSTANCES )
  {
    QCRIL_LOG_DEBUG( "Ignore %s(%d)\n", qcril_log_lookup_event_name( event_id ), event_id );
    return;
  }
  #endif /* FEATURE_QCRIL_DSDS */

  /* Call event handler for CM Inband Service event */
  qcril_event_queue( route_instance_id, modem_id, QCRIL_DATA_ON_STACK, event_id, 
                     (void *) inband_info_ptr, sizeof( cm_inband_info_s_type ), (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

} /* qcril_cm_process_inband_event_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_inband_event_callback

===========================================================================*/
/*!
    @brief
    Handle CM Inband event callback.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inband_event_callback
(
  cm_inband_event_e_type inband_event,
  const cm_inband_info_s_type *inband_info_ptr
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_DEFAULT_MODEM_ID;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( inband_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process CM Inband event callback */
  qcril_cm_process_inband_event_callback( instance_id, modem_id, inband_event, inband_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_inband_event_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_inband_event_callback_fusion

===========================================================================*/
/*!
    @brief
    Handle CM Inband event callback for MDM.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inband_event_callback_fusion
(
  cm_inband_event_e_type inband_event,
  const cm_inband_info_s_type *inband_info_ptr
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_SECOND_MODEM_ID;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( inband_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process CM Inband event callback */
  qcril_cm_process_inband_event_callback( instance_id, modem_id, inband_event, inband_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_inband_event_callback_fusion */


#ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
/*========================================================================= 
  FUNCTION:  qcril_cm_supsvc_command_callback_exten
 
===========================================================================*/
/*!
    @brief
    Handle CM Supplementary Services command callback.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_cm_supsvc_command_callback_exten
(
  void                  *data_block_ptr,
  cm_sups_cmd_e_type     sups_cmd,
  cm_sups_cmd_err_e_type sups_cmd_err,
  cm_sups_cmd_err_cause_e_type err_cause,
  cm_alpha_s_type              alpha
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  uint32 user_data;
  uint16 req_id;
  qcril_reqlist_public_type req_info;
  qcril_cm_command_callback_params_type params;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( data_block_ptr != NULL );
  user_data = ( uint32 ) data_block_ptr;
  instance_id = QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( user_data );
  modem_id = QCRIL_EXTRACT_MODEM_ID_FROM_USER_DATA( user_data );
  req_id = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA( user_data );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_INFO( "RID %d MID %d Received CM_SUPSVC_COMMAND_CALLBACK : Req ID %d\n", instance_id, modem_id, req_id );

  /* Lookup the Instance ID */
  if ( qcril_reqlist_query_by_req_id( req_id, &instance_id, &req_info ) == E_SUCCESS )
  {
    /* Supplementary Service event handler for CM command callback */
    params.command = QCRIL_CM_COMMAND_SUPS;
    params.command_info.sups.cmd = sups_cmd;
    params.command_info.sups.cmd_err = sups_cmd_err;
    params.command_info.sups.err_cause = err_cause;
    qcril_event_queue( instance_id, modem_id, QCRIL_DATA_ON_STACK, QCRIL_EVT_CM_COMMAND_CALLBACK, 
                       (void *) &params, sizeof( params ), req_info.t );
  }
  else
  {
    QCRIL_LOG_ERROR( "Req ID %d not found for CM_SUPSVC_COMMAND_CALLBACK\n", req_id );
  }
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_supsvc_command_callback */
#endif /* FEATURE_QCRIL_SUPS_CC_EXTEN */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_command_callback

===========================================================================*/
/*!
    @brief
    Handle CM Supplementary Services command callback.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_cm_supsvc_command_callback
(
  void                  *data_block_ptr,
  cm_sups_cmd_e_type     sups_cmd,
  cm_sups_cmd_err_e_type sups_cmd_err
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  uint32 user_data;
  uint16 req_id;
  qcril_reqlist_public_type req_info;
  qcril_cm_command_callback_params_type params;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( data_block_ptr != NULL );
  user_data = ( uint32 ) data_block_ptr;
  instance_id = QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( user_data );
  modem_id = QCRIL_EXTRACT_MODEM_ID_FROM_USER_DATA( user_data );
  req_id = QCRIL_EXTRACT_USER_ID_FROM_USER_DATA( user_data );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "RID %d MID %d Received CM_SUPSVC_COMMAND_CALLBACK : Req ID %d\n", instance_id, modem_id, req_id );

  /* Lookup the Instance ID */
  if ( qcril_reqlist_query_by_req_id( req_id, &instance_id, &req_info ) == E_SUCCESS )
  {
    /* Supplementary Service event handler for CM command callback */
    params.command = QCRIL_CM_COMMAND_SUPS;
    params.command_info.sups.cmd = sups_cmd;
    params.command_info.sups.cmd_err = sups_cmd_err;
    qcril_event_queue( instance_id, modem_id, QCRIL_DATA_ON_STACK, QCRIL_EVT_CM_COMMAND_CALLBACK, 
                       (void *) &params, sizeof( params ), req_info.t );
  }
  else
  {
    QCRIL_LOG_ERROR( "Req ID %d not found for CM_SUPSVC_COMMAND_CALLBACK\n", req_id );
  }
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_supsvc_command_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_process_supsvc_event_callback

===========================================================================*/
/*!
    @brief
    Process CM Supplementary Services event callback.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_cm_process_supsvc_event_callback
(
  qcril_instance_id_e_type  instance_id,
  qcril_modem_id_e_type     modem_id,
  cm_sups_event_e_type      sups_event,
  const cm_sups_info_s_type *sups_info_ptr
)
{
  qcril_instance_id_e_type route_instance_id = instance_id;
  qcril_evt_e_type event_id;
  #ifdef FEATURE_QCRIL_DSDS
  qcril_reqlist_public_type req_info;
  #endif
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( sups_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Figure out Event ID */
  event_id = QCRIL_EVT_CM_SUPS_BASE + sups_event;

  QCRIL_LOG_DEBUG( "RID %d MID %d Received supsvc event : %s (%d)\n", instance_id, modem_id, 
                   qcril_log_lookup_event_name(event_id), event_id );

  #ifdef FEATURE_QCRIL_DSDS
  if ( qcril_arb_lookup_instance_id_from_as_id( sups_info_ptr->asubs_id, &route_instance_id ) != E_SUCCESS )
  {
     route_instance_id = (sups_info_ptr->asubs_id == SYS_MODEM_AS_ID_1) ? QCRIL_DEFAULT_INSTANCE_ID: QCRIL_SECOND_INSTANCE_ID;

     if( qcril_reqlist_query_by_event( route_instance_id, modem_id, event_id, &req_info ) != E_SUCCESS )
     {
        QCRIL_LOG_DEBUG( "Ignore %s(%d), asid %d\n", qcril_log_lookup_event_name( event_id ), event_id,
                         sups_info_ptr->asubs_id );
        return;
     }
     else
     {
        QCRIL_LOG_DEBUG( "Route RILD %d for %s(%d), asid %d due to hotswap for penging request\n", route_instance_id, qcril_log_lookup_event_name( event_id ), event_id,
                         sups_info_ptr->asubs_id );
     }
  }
  else
  {
    QCRIL_LOG_DEBUG( "Route RID %d for %s(%d), asid %d\n", route_instance_id, qcril_log_lookup_event_name( event_id ), event_id, 
                     sups_info_ptr->asubs_id );
  }
  #endif /* FEATURE_QCRIL_DSDS*/

  /* Call event handler for CM Supplementary Service event */
  qcril_event_queue( route_instance_id, modem_id, QCRIL_DATA_ON_STACK, event_id, (void *) sups_info_ptr, 
                     sizeof( cm_sups_info_s_type ), (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

} /* qcril_cm_process_subsvc_event_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_callback

===========================================================================*/
/*!
    @brief
    Handle CM Supplementary Services event callback.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_callback
(
  cm_sups_event_e_type      sups_event,
  const cm_sups_info_s_type *sups_info_ptr
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_DEFAULT_MODEM_ID;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( sups_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process CM Supplementary Services callback */
  qcril_cm_process_supsvc_event_callback( instance_id, modem_id, sups_event, sups_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_subsvc_event_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_callback_fusion

===========================================================================*/
/*!
    @brief
    Handle CM Supplementary Services event callback.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_callback_fusion
(
  cm_sups_event_e_type      sups_event,
  const cm_sups_info_s_type *sups_info_ptr
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_SECOND_MODEM_ID;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( sups_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process CM Supplementary Services callback */
  qcril_cm_process_supsvc_event_callback( instance_id, modem_id, sups_event, sups_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_subsvc_event_callback_fusion */


#ifdef FEATURE_QCRIL_NCELL
/*=========================================================================
  FUNCTION:  qcril_cm_process_stats_event_callback

===========================================================================*/
/*!
    @brief
    Process CM Statistics event callback.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_cm_process_stats_event_callback
( 
  qcril_instance_id_e_type instance_id,
  qcril_modem_id_e_type modem_id,
  cm_stats_event_e_type stats_event, 
  const sys_modem_stats_info_s_type *stats_info_ptr 
)
{
  qcril_evt_e_type event_id;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( stats_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Figure out Event ID */
  event_id = QCRIL_EVT_CM_STATS_BASE + stats_event;

  QCRIL_LOG_DEBUG( "RID %d MID %d Received stats event : %s (%d)\n", instance_id, modem_id, 
                   qcril_log_lookup_event_name(event_id), event_id );

  /* Call event handler for CM Supplementary Service event */
  qcril_event_queue( instance_id, modem_id, QCRIL_DATA_ON_STACK, event_id, (void *) stats_info_ptr, 
                     sizeof( sys_modem_stats_info_s_type ), (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

} /* qcril_cm_process_stats_event_callback */ 


/*=========================================================================
  FUNCTION:  qcril_cm_stats_event_callback

===========================================================================*/
/*!
    @brief
    Handle CM Statistics event callback.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_stats_event_callback
( 
  cm_stats_event_e_type stats_event, 
  const sys_modem_stats_info_s_type *stats_info_ptr 
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_DEFAULT_MODEM_ID;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( stats_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process CM Statistics event callback */
  qcril_cm_process_stats_event_callback( instance_id, modem_id, stats_event, stats_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_stats_event_callback */ 


/*=========================================================================
  FUNCTION:  qcril_cm_stats_event_callback_fusion

===========================================================================*/
/*!
    @brief
    Handle CM Statistics event callback for MDM.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_stats_event_callback_fusion
( 
  cm_stats_event_e_type stats_event, 
  const sys_modem_stats_info_s_type *stats_info_ptr 
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_SECOND_MODEM_ID;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( stats_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process CM Statistics event callback */
  qcril_cm_process_stats_event_callback( instance_id, modem_id, stats_event, stats_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_stats_event_callback_fusion */ 
#endif /* FEATURE_QCRIL_NCELL */


#ifdef FEATURE_QCRIL_DSDS
/*=========================================================================
  FUNCTION:  qcril_cm_process_subs_event_callback

===========================================================================*/
/*!
    @brief
    Process Subs event callback.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_cm_process_subs_event_callback
( 
  qcril_instance_id_e_type instance_id,
  qcril_modem_id_e_type modem_id,
  cm_ph_event_e_type subs_event,
  const cm_subs_info_s_type *subs_info_ptr
)
{
  qcril_instance_id_e_type route_instance_id = instance_id;
  qcril_evt_e_type event_id;
  uint8 i;
  uint32 sub_id;
  boolean found_pending_request = FALSE;
  qcril_reqlist_public_type req_info;
  qcril_sub_ids_list_type sub_ids_list;
  qcril_arb_subs_prov_status_e_type subs_state;
  RIL_SelectUiccSub uicc_sub;
  qmi_uim_session_type session_type;
  qcril_cm_struct_type *i_ptr;
  qcril_unsol_resp_params_type unsol_resp;
  sys_modem_as_id_e_type as_id;
  int subs_status;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( subs_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Figure out Event ID */
  event_id = QCRIL_EVT_CM_PH_BASE + subs_event;

  QCRIL_LOG_DEBUG( "RID %d MID %d Received subs event : %s (%d), subs_is_opr = %d  session_type = %d\n", instance_id, modem_id,
                   qcril_log_lookup_event_name( event_id ), event_id,  subs_info_ptr->is_operational, subs_info_ptr->session_type);

  if ( subs_event != CM_PH_EVENT_SUBSCRIPTION_PREF_INFO ) 
  {
    QCRIL_LOG_DEBUG( "Ignore subs event %d\n", subs_event );
    return;
  }

  if ( qcril_arb_ma_is_dsds() )
  {
    /* Figure out sub id */
    sub_id = (uint32) subs_info_ptr->session_type;

    /* Check which instance is waiting for the event */
    if ( qcril_arb_lookup_instance_id_from_session_type( subs_info_ptr->session_type,
                                                         &route_instance_id ) == E_SUCCESS )
    {
      qcril_arb_query_subs(route_instance_id, &subs_state, &uicc_sub, &as_id, &session_type);

      /* allow it only when subscription is not provisioned */
      if( subs_state != QCRIL_ARB_SUBS_PROVISIONED )
      {
        /* Call event handler for CM Subscription event */
        qcril_event_queue( route_instance_id, modem_id, QCRIL_DATA_ON_STACK, event_id, (void *) subs_info_ptr,
                           sizeof( cm_subs_info_s_type ), (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
        return;
      }
    }
    else
    {
      /* check to see if CM event has come before UIM event for activation */
      for ( i = 0; i < QCRIL_ARB_MAX_INSTANCES; i++ )
      {
        if ( qcril_reqlist_query_by_event_and_sub_id( i, QCRIL_DEFAULT_MODEM_ID,
                                                      QCRIL_EVT_CM_ACTIVATE_PROVISION_STATUS, sub_id,
                                                      &req_info ) == E_SUCCESS )
        {
          qcril_cm[ i ].subs_pref_info.is_pending = TRUE;
          memcpy( &qcril_cm[ i ].subs_pref_info.cm_subs_info, subs_info_ptr, sizeof( cm_subs_info_s_type ) );

          QCRIL_LOG_DEBUG( "RID %d CM_PH_EVENT_SUBSCRIPTION_PREF_INFO pending for processing, asid %d, session_type %d\n",
                           i, subs_info_ptr->subscription_id, subs_info_ptr->session_type );
          return;
        }
      }

      QCRIL_LOG_DEBUG( "RID %d Ignore not operational CM_PH_EVENT_SUBSCRIPTION_PREF_INFO, asid %d, session_type %d\n",
                       route_instance_id, subs_info_ptr->subscription_id, subs_info_ptr->session_type );
    }
  }

  /* for supporting HOT-SWAP scenario, where SIM card is removed, CM will set is_operational field to "0" */
  if ( (!subs_info_ptr ->is_operational)  &&
       ( qcril_arb_lookup_subs_from_session_type ( subs_info_ptr->session_type, &subs_state,  &uicc_sub, &as_id, &instance_id ) == E_SUCCESS ) )
  {

    QCRIL_LOG_DEBUG( "RIL %d is deactivated at modem, checking for card status\n", instance_id);
    i_ptr = &qcril_cm[instance_id];

    if( qcril_arb_query_card_removed_flag(instance_id) )
    {
      /* card is removed, subscription is deactivated at modem,
           clear the subscription information, send deactivation indication to telephony */

      QCRIL_LOG_DEBUG( "RID %d, card removed, deactivating the subscription, asid %d, session_type %d\n",
                     instance_id, subs_info_ptr->subscription_id, subs_info_ptr->session_type );

      /* Mark subscription deactivated */
      qcril_arb_deactivate_subs( instance_id );

      /* send unsolicited event to telephony indicating subscription is ready at modem */
      qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, &unsol_resp );
      subs_status = QCRIL_CM_SUBSCRIPTION_DEACTIVATED;
      unsol_resp.resp_pkt = (void *)&subs_status;
      unsol_resp.resp_len = sizeof(subs_status);

      qcril_send_unsol_response( &unsol_resp );

      for(i = 0; i < QCRIL_MAX_MODEM_ID; i++)
      {
         i_ptr->ss_info[i].srv_status = SYS_SRV_STATUS_NO_SRV;
         i_ptr->ss_info[i].changed_fields |= CM_SS_SRV_STATUS_MASK;
      }
      qcril_cm_process_network_info(instance_id, modem_id,  QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED);
    }
    else
    {
      qcril_arb_update_subs_deactivation_pending_flag( instance_id, TRUE);
    }
  }
} /* qcril_cm_process_subs_event_callback */ 


/*=========================================================================
  FUNCTION:  qcril_cm_subs_event_callback

===========================================================================*/
/*!
    @brief
    Handle CM Subs event callback.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_subs_event_callback
( 
  cm_ph_event_e_type subs_event,
  const cm_subs_info_s_type *subs_info_ptr
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_modem_id_e_type modem_id = QCRIL_DEFAULT_MODEM_ID;
  uint8 i;
  uint32 sub_id;
  boolean found_pending_request = FALSE;
  qcril_reqlist_public_type req_info;

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( subs_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Process CM Subs event callback */
  qcril_cm_process_subs_event_callback( instance_id, modem_id, subs_event, subs_info_ptr );
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_subs_event_callback */ 
#endif /* FEATURE_QCRIL_DSDS */


/*=========================================================================
  FUNCTION:  qcril_cm_force_state_transition_to_wait_amss_event

===========================================================================*/
/*!
    @brief
    Change the state of the entry in the ReqList to QCRIL_REQ_AWAITING_AMSS_EVENTS.

    @return
    None
*/
/*=========================================================================*/
void qcril_cm_force_state_transition_to_wait_amss_event
( 
  qcril_instance_id_e_type instance_id,
  qcril_modem_id_e_type modem_id,
  RIL_Token t,
  int request,
  qcril_evt_e_type pending_event_id
)
{
  IxErrnoType err_no;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  /* Change the state of the entry in ReqList to QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS */
  err_no = qcril_reqlist_update_state( instance_id, modem_id, t, QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS );

  /* State transition failure */
  if ( err_no == E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "Change the state of ReqList entry to AWAITING_MORE_AMSS_EVENTS state : %s (%d), Token ID %d, pending %s (%d)\n", 
                     qcril_log_lookup_event_name( request ), request, qcril_log_get_token_id( t ),  
                     qcril_log_lookup_event_name( pending_event_id ), pending_event_id ); 
  }
  else if ( err_no == E_NOT_ALLOWED )
  {
    QCRIL_LOG_ERROR( "Fail to change the state of ReqList entry to AWAITING_MORE_AMSS_EVENTS state : %s (%d), Token ID %d, pending %s (%d)\n", 
                     qcril_log_lookup_event_name( request ), request, qcril_log_get_token_id( t ),  
                     qcril_log_lookup_event_name( pending_event_id ), pending_event_id ); 

    /* Send RIL_E_GENERIC_FAILURE response*/
    qcril_default_request_resp_params( instance_id, t, request, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    QCRIL_LOG_ERROR( "ReqList entry not found : %s (%d), Token ID %d\n", 
                     qcril_log_lookup_event_name( request ), request, qcril_log_get_token_id( t ) );  
  }

} /* qcril_cm_force_state_transition_to_wait_amss_event */


/*===========================================================================

  FUNCTION:  qcril_cm_poll_network_selection

===========================================================================*/
/*!
    @brief
    Sends response to RIL_REQUEST_NETWORK_SELECTION_MANUAL if UE stills
    unable to camp on the network.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_cm_poll_network_selection
(
  void *param
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( param != NULL );
  user_data = ( uint32 ) param;
  instance_id = QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( user_data );
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = QCRIL_EXTRACT_MODEM_ID_FROM_USER_DATA( user_data );
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "Poll Network Selection Timer expired with ID %d\n", user_data );

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, QCRIL_EVT_CM_SS_SRV_CHANGED, user_data, 
                                                &req_info ) == E_SUCCESS ) 
  {
    if ( req_info.request == RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL )
    {
      /* Check whether in Full service */
      if ( QCRIL_CM_SRV_STATUS_INDICATES_GW_FULL_SRV( i_ptr->ss_info[ modem_id ].srv_status, i_ptr->ss_info[ modem_id ].sys_mode ) )
      {
        QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Registered on system (Manual network selection mode)\n" ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        qcril_send_request_response( &resp );
      }
      /* SIM error */
      else if( ( QCRIL_CM_SYS_MODE_IS_GW( i_ptr->ss_info[ modem_id ].sys_mode ) ) &&
               ( ( i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state == SYS_SIM_STATE_NOT_AVAILABLE ) ||
                 ( i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state == SYS_SIM_STATE_CS_PS_INVALID ) ) )
      {
        QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Failed to register on system due to SIM error (Manual network selection mode)\n" );
        qcril_cancel_timed_callback( (void*) req_info.sub_id );
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_ILLEGAL_SIM_OR_ME, &resp );
        qcril_send_request_response( &resp ); 
      }
      else
      {
        QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Failed to register on system (Manual network selection mode)\n" ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
    }
    else if ( req_info.request == RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC )
    {
      /* SIM error */
      if( ( QCRIL_CM_SYS_MODE_IS_GW( i_ptr->ss_info[ modem_id ].sys_mode ) ) &&
          ( ( i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state == SYS_SIM_STATE_NOT_AVAILABLE ) ||
            ( i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state == SYS_SIM_STATE_CS_PS_INVALID ) ) && 
          ( !QCRIL_CM_SRV_STATUS_INDICATES_FULL_SRV( i_ptr->ss_info[ modem_id ].srv_status ) ) )
      {
        QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Failed to register on system due to SIM error (Automatic network selection mode)\n" );
        qcril_cancel_timed_callback( (void*) req_info.sub_id );
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_ILLEGAL_SIM_OR_ME, &resp );
        qcril_send_request_response( &resp ); 
      }
      else
      {
        QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Registered on system (Automatic network selection mode)\n" ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        qcril_send_request_response( &resp );
      }
    }
    else
    {
      QCRIL_LOG_DEBUG( "%s\n", "Poll network selection result, no outstanding request found" );
    }
  }
  else
  {
    QCRIL_LOG_DEBUG( "%s\n", "Poll network selection result, no outstanding request found" );
  }

} /* qcril_cm_poll_network_selection */


/*=========================================================================
  FUNCTION:  qcril_cm_event_command_callback

===========================================================================*/
/*!
    @brief
    Handle CM command callback event.

    @return
    None
*/
/*=========================================================================*/
void qcril_cm_event_command_callback
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id, match_instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_cm_command_callback_params_type *callback_params_ptr;
  qcril_reqlist_public_type req_info, match_req_info;
  qcril_modem_ids_list_type modem_ids_done_list;
  boolean cmd_exec_success = TRUE;
  qcril_request_resp_params_type resp;
  uint32 timer_id;
  IxErrnoType result;
  char details[ 40 ];

  QCRIL_LOG_ADB_MAIN("Enter %s\n", __func__);
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id];
  callback_params_ptr = (qcril_cm_command_callback_params_type *) params_ptr->data;
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Check to see whether is any error reported for the command execution */
  switch ( callback_params_ptr->command )
  {
    case QCRIL_CM_COMMAND_PH:
      if ( callback_params_ptr->command_info.ph.cmd_err != CM_PH_CMD_ERR_NOERR )
      {
        cmd_exec_success = FALSE;
        QCRIL_LOG_ERROR( "CM PH cmd %d, err %d, Token ID %d\n", callback_params_ptr->command_info.ph.cmd, 
                         callback_params_ptr->command_info.ph.cmd_err, qcril_log_get_token_id( params_ptr->t ) ); 
        }
      break;

    case QCRIL_CM_COMMAND_SS:
      if ( callback_params_ptr->command_info.ss.cmd_err != CM_SS_CMD_ERR_NOERR )
      {
        cmd_exec_success = FALSE;
        QCRIL_LOG_ERROR( "CM SS cmd %d, err %d, Token ID %d\n", callback_params_ptr->command_info.ss.cmd, 
                         callback_params_ptr->command_info.ss.cmd_err, qcril_log_get_token_id( params_ptr->t ) ); 
        }
      break;

    case QCRIL_CM_COMMAND_CALL:

      /* If the command was an Origination, and there was an error, update the
         call_fail_cause. */
      if ( ( callback_params_ptr->command_info.call.cmd == CM_CALL_CMD_ORIG ) &&
           ( callback_params_ptr->command_info.call.cmd_err != CM_CALL_CMD_ERR_NOERR ) )
      {
        cmd_exec_success = FALSE;

        /* Record last call failure cause */
        QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].call_fail_cause_mutex\n", instance_id );
        QCRIL_MUTEX_LOCK( &i_ptr->call_fail_cause_mutex, details );

        if ( callback_params_ptr->command_info.call.cmd_err == CM_CALL_CMD_ERR_EMERGENCY_MODE_S )
        {
          /* Record that the last call failed because modem is in emergency callback modem */

          i_ptr->call_fail_cause = CALL_FAIL_CDMA_NOT_EMERGENCY;
          QCRIL_LOG_ERROR( "CM CALL command %d failed, in Emergency Callback mode, Token ID %d\n", 
                           callback_params_ptr->command_info.call.cmd, qcril_log_get_token_id( params_ptr->t ) ); 
        }
        else if ( callback_params_ptr->command_info.call.cmd_err == CM_CALL_CMD_ERR_NO_FUNDS_S )
        {
          /* Record that the last call failed because the phone is out of funds */
          i_ptr->call_fail_cause = CALL_FAIL_ACM_LIMIT_EXCEEDED;
          QCRIL_LOG_ERROR( "CM CALL command %d failed, out of funds, Token ID %d\n", 
                           callback_params_ptr->command_info.call.cmd, 
                           qcril_log_get_token_id( params_ptr->t ) ); 
        }
        #ifdef FEATURE_QCRIL_CALL_ORIG_EXTEN3
        else if ( ( callback_params_ptr->command_info.call.cmd_err == CM_CALL_CMD_ERR_CALL_CONTROL_REJECTED ) &&
                  ( callback_params_ptr->command_info.call.err_cause == CM_CALL_CMD_ERR_CAUSE_FDN_FAIL ) )
        {
          /* Record that the last call failed because of FDN check failure */
          i_ptr->call_fail_cause = CALL_FAIL_FDN_BLOCKED;
          QCRIL_LOG_ERROR( "CM CALL command %d failed, fdn failure, Token ID %d\n",
                           callback_params_ptr->command_info.call.cmd,
                           qcril_log_get_token_id( params_ptr->t ) );
        }
        #endif
        else
        {
          /* Record the reason for the call failure */
          i_ptr->call_fail_cause = CALL_FAIL_ERROR_UNSPECIFIED;
          QCRIL_LOG_ERROR( "CM CALL command %d, err %d, Token ID %d\n", 
                           callback_params_ptr->command_info.call.cmd, 
                           callback_params_ptr->command_info.call.cmd_err, 
                           qcril_log_get_token_id( params_ptr->t ) ); 
        }

        QCRIL_MUTEX_UNLOCK( &i_ptr->call_fail_cause_mutex, details );
      }
      /* Handle all other CM CALL command failures */
      else if ( callback_params_ptr->command_info.call.cmd_err != CM_CALL_CMD_ERR_NOERR )
      {
        cmd_exec_success = FALSE;
        QCRIL_LOG_ERROR( "CM CALL command %d, err %d, Token ID %d\n", 
                         callback_params_ptr->command_info.call.cmd, 
                         callback_params_ptr->command_info.call.cmd_err, 
                         qcril_log_get_token_id( params_ptr->t ) ); 
      }
      break;

    case QCRIL_CM_COMMAND_INBAND:
      if ( callback_params_ptr->command_info.inband.cmd_err != CM_INBAND_CMD_ERR_NOERR )
      {
        cmd_exec_success = FALSE;
        QCRIL_LOG_ERROR( "CM INBAND command, %d err %d, Token ID %d\n", 
                         callback_params_ptr->command_info.inband.cmd, callback_params_ptr->command_info.inband.cmd_err, 
                         qcril_log_get_token_id( params_ptr->t ) ); 
        }
      break;

    case QCRIL_CM_COMMAND_SUPS:
      if ( callback_params_ptr->command_info.sups.cmd_err != CM_SUPS_CMD_ERR_NOERR )
      {
        cmd_exec_success = FALSE;
        QCRIL_LOG_ERROR( "CM SUPS command %d, err %d, Token ID %d\n", 
                         callback_params_ptr->command_info.sups.cmd, callback_params_ptr->command_info.sups.cmd_err, 
                         qcril_log_get_token_id( params_ptr->t ) ); 
        }
      break;

    default:
      cmd_exec_success = FALSE;
      QCRIL_LOG_ERROR( "Unhandled CM command %d, Token ID %d\n", callback_params_ptr->command, 
                       qcril_log_get_token_id( params_ptr->t ) ); 
      break;

  } /* end switch */

  /* Entry found in the ReqList */
  if ( qcril_reqlist_query( instance_id, params_ptr->t, &req_info ) == E_SUCCESS )
  {
    /* Fail to execute the RIL command */
    if ( !cmd_exec_success )
    {
      if ( qcril_reqlist_complete_all_amss_events( instance_id, modem_id, params_ptr->t, QCRIL_REQ_COMPLETED_FAILURE, 
                                                   &modem_ids_done_list, &result ) == E_SUCCESS )
      {
        if ( req_info.request == RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE )
        {
          /* Send RIL_E_SUBSCRIPTION_NOT_AVAILABLE response */
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUBSCRIPTION_NOT_AVAILABLE, &resp );
          qcril_send_request_response( &resp );
        }
        #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
        else if ( ( callback_params_ptr->command == QCRIL_CM_COMMAND_SUPS ) &&
                  ( callback_params_ptr->command_info.sups.cmd_err == CM_SUPS_CMD_ERR_CALL_CONTROL_REJECTED ) && 
                  ( callback_params_ptr->command_info.sups.err_cause == CM_SUPS_CMD_ERR_CAUSE_FDN_FAIL ) )
        {
          /* Send RIL_E_FDN_CHECK_FAILURE response */
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_FDN_CHECK_FAILURE, &resp );
          qcril_send_request_response( &resp );
        }
        #endif
        #ifdef FEATURE_QCRIL_CALL_ORIG_EXTEN3
        else if ( ( callback_params_ptr->command == QCRIL_CM_COMMAND_CALL ) &&
                  ( callback_params_ptr->command_info.call.cmd_err == CM_CALL_CMD_ERR_CALL_CONTROL_REJECTED ) &&
                  ( callback_params_ptr->command_info.call.err_cause == CM_CALL_CMD_ERR_CAUSE_FDN_FAIL ) )
        {
          /* Send RIL_E_FDN_CHECK_FAILURE response */
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_FDN_CHECK_FAILURE, &resp );
          qcril_send_request_response( &resp );
        }
        #endif
        else
        {
          /* Send RIL_E_GENERIC_FAILURE response */
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );

          if ( req_info.request == RIL_REQUEST_RADIO_POWER )
          {
            /* Response also for RIL_REQUEST_RADIO_POWER for the other instance */
            if ( qcril_arb_ma_is_dsds() && req_info.valid_sub_id )
            {
              if ( qcril_reqlist_query_by_req_id( req_info.sub_id, &match_instance_id, &match_req_info ) == E_SUCCESS )
              {                                                                                   
                qcril_default_request_resp_params( match_instance_id, match_req_info.t, match_req_info.request, 
                                                   RIL_E_GENERIC_FAILURE, &resp );
                qcril_send_request_response( &resp );
              }
            }
            qcril_send_radio_response_process_blocked_request(instance_id,
                            modem_id, RIL_E_GENERIC_FAILURE, req_info.sub.cm.info.radio_mode.oprt_mode, req_info.req_id );
          }
        }
      }

      QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);
      return;
    }

    /* Force state transition to WaitingMoreAMSSEvents if there are pending AMSS events */
    if ( req_info.pending_event_id[ modem_id ] != QCRIL_EVT_NONE )
    {
      qcril_cm_force_state_transition_to_wait_amss_event( instance_id, modem_id, params_ptr->t, 
                                                          req_info.request, req_info.pending_event_id[ modem_id ] );
      /* Depending on scenarios, modem may not response back with new service indication. Setup time callback to send 
         RIL response back (if had not done so) to Android Framework after the expiration of the maximum time needed for
         network re-selection */
      if ( ( req_info.request == RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL ) ||
           ( req_info.request == RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC ) )
      {
        qcril_setup_timed_callback( instance_id, modem_id, qcril_cm_poll_network_selection,
                                    &QCRIL_CM_TIMEVAL_NETSELPOLL, &timer_id );
        qcril_reqlist_update_sub_id( instance_id, params_ptr->t, timer_id );
      }
    }
    else
    {
      /* Received all AMSS events */
      if ( qcril_reqlist_complete_all_amss_events( instance_id, modem_id, params_ptr->t, QCRIL_REQ_COMPLETED_SUCCESS, 
                                                   &modem_ids_done_list, &result ) == E_SUCCESS )
      {
        if ( result == E_SUCCESS )
        {
          /* Send RIL_E_SUCCESS response */
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
          qcril_send_request_response( &resp );
        }
        else
        {
          /* Send RIL_E_GENERIC_FAILURE response */
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
        }
      }
    }
  }  
  /* Entry not found in the ReqList */
  else if ( params_ptr->t != (void *)QCRIL_TOKEN_ID_INTERNAL )
  {
    QCRIL_LOG_ERROR( "ReqList entry not found : Token ID %d\n", qcril_log_get_token_id( params_ptr->t ) ); 
  }
  QCRIL_LOG_ADB_MAIN("Exit %s\n", __func__);

} /* qcril_cm_event_command_callback */


/*=========================================================================
  FUNCTION:  qcril_cm_init

===========================================================================*/
/*!
    @brief
    Initialize the CM subsystem of the RIL.

    @return
    E_SUCCESS or E_FAILURE
*/
/*=========================================================================*/
errno_enum_type qcril_cm_init
( 
  void 
)
{
  uint8 i, j; 
  qcril_cm_struct_type *i_ptr;
  cm_client_id_type client_id = 0;
  errno_enum_type return_errno = E_SUCCESS;
  char args[ PROPERTY_VALUE_MAX ];
  int clir_len, ecio_delta_len, apm_sim_not_pwdn_len, power_save_len;
  int process_ussd_len;
  #ifdef FEATURE_QCRIL_DSDS
  int tuneaway_len, tune_away_status = FALSE;
  int paging_priority_len, paging_priority_status;
  #endif /* FEATURE_QCRIL_DSDS */
  char *end_ptr;
  unsigned long ret_val;
  char property_name[ 40 ];
  uint32 user_data;
  char details[ 40 ];

  cm_ph_event_e_type ph_event_list[] = { 
    CM_PH_EVENT_SYS_SEL_PREF,
    CM_PH_EVENT_OPRT_MODE,
    CM_PH_EVENT_INFO,

    #ifdef FEATURE_QCRIL_PRL_INIT
    CM_PH_EVENT_PRL_INIT,
    #endif /* FEATURE_QCRIL_PRL_INIT */

    CM_PH_EVENT_SUBSCRIPTION_AVAILABLE,
    #ifdef FEATURE_QCRIL_SUBS_CTRL
    CM_PH_EVENT_SUBSCRIPTION_NOT_AVAILABLE,
    #endif /* FEATURE_QCRIL_SUBS_CTRL */

    #ifdef FEATURE_QCRIL_DSDS
    CM_PH_EVENT_DUAL_STANDBY_PREF,
    CM_PH_EVENT_SUBSCRIPTION_PREF_INFO,
    #endif /* FEATURE_QCRIL_DSDS */

    CM_PH_EVENT_AVAILABLE_NETWORKS_CONF,
    CM_PH_EVENT_TERMINATE_GET_NETWORKS,
    CM_PH_EVENT_NVRUIM_CONFIG_CHANGED
  };

  cm_ss_event_e_type ss_event_list[] = { 
    CM_SS_EVENT_SRV_CHANGED,
    CM_SS_EVENT_RSSI,
    CM_SS_EVENT_HDR_RSSI,
    CM_SS_EVENT_EMERG_NUM_LIST,
    CM_SS_EVENT_INFO,
    #ifdef FEATURE_QCRIL_DSAC
    CM_SS_EVENT_CELL_ACCESS_IND,
    #endif /* FEATURE_QCRIL_DSAC */
    CM_SS_EVENT_REG_REJECT
  };

  cm_call_event_e_type call_event_list[] = { 
    CM_CALL_EVENT_ORIG,
    CM_CALL_EVENT_SETUP_IND,
    CM_CALL_EVENT_PROGRESS_INFO_IND,
    CM_CALL_EVENT_INCOM,
    CM_CALL_EVENT_ANSWER,
    CM_CALL_EVENT_END,
    CM_CALL_EVENT_SUPS,
    CM_CALL_EVENT_CONNECT,
    CM_CALL_EVENT_PRIVACY,
    CM_CALL_EVENT_PRIVACY_PREF,
    CM_CALL_EVENT_MNG_CALLS_CONF,
    CM_CALL_EVENT_ORIG_FWD_STATUS,
    CM_CALL_EVENT_CALL_BEING_FORWARDED,
    CM_CALL_EVENT_CALL_IS_WAITING,
    CM_CALL_EVENT_CALL_BARRED,
    CM_CALL_EVENT_INCOM_FWD_CALL,
    CM_CALL_EVENT_CUG_INFO_RECEIVED,
    CM_CALL_EVENT_CALL_ON_HOLD,
    CM_CALL_EVENT_CALL_RETRIEVED,
    CM_CALL_EVENT_CALL_FORWARDED,
    CM_CALL_EVENT_CALL_RESTRICTED,
    CM_CALL_EVENT_TRANSFERRED_CALL,
    CM_CALL_EVENT_CALL_DEFLECTION,
    CM_CALL_EVENT_CNAP_INFO_RECEIVED,
    CM_CALL_EVENT_OTASP_STATUS,
    CM_CALL_EVENT_DISPLAY,
    CM_CALL_EVENT_CALLED_PARTY,
    CM_CALL_EVENT_CALLER_ID,
    CM_CALL_EVENT_CONNECTED_NUM,
    CM_CALL_EVENT_SIGNAL,
    CM_CALL_EVENT_REDIRECTING_NUMBER,
    CM_CALL_EVENT_LINE_CTRL,
    CM_CALL_EVENT_EXT_DISP,
    CM_CALL_EVENT_EXT_BRST_INTL,
    CM_CALL_EVENT_NSS_CLIR_REC,
    CM_CALL_EVENT_NSS_REL_REC,
    CM_CALL_EVENT_NSS_AUD_CTRL,
    CM_CALL_EVENT_USER_DATA_IND
  };

  cm_inband_event_e_type inband_event_list[] = { 
    CM_INBAND_EVENT_REV_BURST_DTMF,
    CM_INBAND_EVENT_REV_START_CONT_DTMF,
    CM_INBAND_EVENT_REV_START_CONT_DTMF_CONF,
    CM_INBAND_EVENT_REV_STOP_CONT_DTMF,
    CM_INBAND_EVENT_REV_STOP_CONT_DTMF_CONF,
    CM_INBAND_EVENT_FWD_BURST_DTMF,
    CM_INBAND_EVENT_FWD_START_CONT_DTMF,
    CM_INBAND_EVENT_FWD_STOP_CONT_DTMF
  };

  cm_sups_event_e_type sups_event_list[] = { 
    CM_SUPS_EVENT_ACTIVATE,
    CM_SUPS_EVENT_ACTIVATE_CONF,
    CM_SUPS_EVENT_DEACTIVATE,
    CM_SUPS_EVENT_DEACTIVATE_CONF,
    CM_SUPS_EVENT_ERASE,
    CM_SUPS_EVENT_ERASE_CONF,
    CM_SUPS_EVENT_INTERROGATE,
    CM_SUPS_EVENT_INTERROGATE_CONF,
    CM_SUPS_EVENT_REGISTER,
    CM_SUPS_EVENT_REGISTER_CONF,
    CM_SUPS_EVENT_REG_PASSWORD,
    CM_SUPS_EVENT_REG_PASSWORD_CONF,
    CM_SUPS_EVENT_PROCESS_USS,
    CM_SUPS_EVENT_PROCESS_USS_CONF,
    CM_SUPS_EVENT_USS_IND,
    CM_SUPS_EVENT_USS_NOTIFY_IND,
    CM_SUPS_EVENT_RELEASE_USS_IND,
    CM_SUPS_EVENT_GET_PASSWORD_IND
  };

  #ifdef FEATURE_QCRIL_NCELL
  cm_stats_event_e_type stats_event = CM_STATS_EVENT_MODEM_INFO;
  #endif /* FEATURE_QCRIL_NCELL */

  /*-----------------------------------------------------------------------*/

  /* Allow cache */
  qcril_cm = (qcril_cm_struct_type *) qcril_arb_allocate_cache( QCRIL_ARB_CACHE_CM );
  QCRIL_ASSERT( qcril_cm != NULL );

  /* Initialize internal data */
  for ( i = 0 ; i < QCRIL_MAX_INSTANCE_ID; i++ )
  {
    i_ptr = &qcril_cm[ i ];

    /* Default Call Fail Cause to CALL_FAIL_NORMAL */
    i_ptr->call_fail_cause = CALL_FAIL_NORMAL;

    /* Default Call Info Rec Time ID to 0xFFFF */
    i_ptr->cdma_info_recs_timer_id = 0xFFFF; 

    /* Default CLIR */
    i_ptr->clir = ( uint8 ) QCRIl_CM_SS_CLIR_PRESENTATION_INDICATOR;

    /* Use saved CLIR setting if available */
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s_%d", QCRIL_CM_CLIR, i );

    property_get( property_name, args, "" );
    clir_len = strlen( args );
    if ( clir_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 ); 
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) ) 
      {
        QCRIL_LOG_ERROR( "RID %d Fail to convert CLIR %s\n", i, args );
      }
      else if ( ret_val > QCRIL_CM_SS_CLIR_SUPPRESSION_OPTION )
      {
        QCRIL_LOG_ERROR( "RID %d Invalid saved CLIR %ld, use default\n", i, ret_val );
      }
      else
      {
        i_ptr->clir = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "RID %d CLIR=%d\n", i, i_ptr->clir );

    /* Default ECIO Delta for reporting */
    i_ptr->ecio_delta = QCRIL_CM_ECIO_DELTA_DEFAULT;

    /* Use saved ECIO delta setting if available */
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s_%d", QCRIL_ECIO_DELTA, i );

    property_get( property_name, args, "" );
    ecio_delta_len = strlen( args );
    if ( ecio_delta_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 ); 
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) ) 
      {
        QCRIL_LOG_ERROR( "RID %d Fail to convert ECIO_DELTA %s\n", i, args );
      }
      else if ( ret_val > QCRIL_CM_ECIO_DELTA_MAX )
      {
        QCRIL_LOG_ERROR( "RID %d Invalid saved ECIO_DELTA %ld, use default\n", i, ret_val );
      }
      else
      {
        i_ptr->ecio_delta = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "RID %d ECIO_DELTA=%d\n", i, i_ptr->ecio_delta );

    /* Default Airplane mode SIM not powerdown setting */
    i_ptr->apm_sim_not_pwdn = FALSE;

    /* Use saved ECIO delta setting if available */
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_APM_SIM_NOT_PWDN );

    property_get( property_name, args, "" );
    apm_sim_not_pwdn_len = strlen( args );
    if ( apm_sim_not_pwdn_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 ); 
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) ) 
      {
        QCRIL_LOG_ERROR( "RID %d Fail to convert APM_SIM_NOT_PWDN %s\n", i, args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "RID %d Invalid saved APM_SIM_NOT_PWDN %ld, use default\n", i, ret_val );
      }
      else
      {
        i_ptr->apm_sim_not_pwdn = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "RID %d APM_SIM_NOT_PWDN=%d\n", i, i_ptr->apm_sim_not_pwdn );


    /* Default settting is not to handle USSD from other clients */
    i_ptr->process_ussd_from_other_clients = FALSE;

    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s",
          QCRIL_PROCESS_USSD_FROM_OTHER_CLIENTS );

    property_get( property_name, args, "" );
    process_ussd_len = strlen( args );
    if ( process_ussd_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "RID %d Fail to convert QCRIL_PROCESS_USSD_FROM_OTHER_CELINTS %s\n", i, args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "RID %d Invalid saved QCRIL_PROCESS_USSD_FROM_OTHER_CLIENTS %ld,"
              "use default\n", i, ret_val );
      }
      else
      {
        i_ptr->process_ussd_from_other_clients = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "RID %d QCRIL_PROCESS_USSD_FROM_OTHER_CLIENTS=%d\n", i,
          i_ptr->process_ussd_from_other_clients );


    /* Default TTY mode */
    i_ptr->tty_mode = QCRIL_CM_TTY_MODE_OFF;

    /* Default Screen State is On */
    i_ptr->screen_state = QCRIL_CM_SCREEN_STATE_ON;

    /* Default Location Update State */
    i_ptr->report_location_updates = TRUE;

    /* Default Registration Reject values */
    i_ptr->reg_reject_info.cm_reg_reject_info.reject_srv_domain = SYS_SRV_DOMAIN_NONE;
    i_ptr->reg_reject_info.cm_reg_reject_info.reject_cause = 0;
    i_ptr->reg_reject_info.reg_reject_reported = FALSE;
    i_ptr->reg_reject_info.managed_roaming_enabled = FALSE;

    /* Default Card Status */
    for ( j = 0; j < QMI_UIM_MAX_CARD_COUNT; j++ )
    {
      i_ptr->card_info[ j ].pwr_oprt_in_progress = FALSE;
      i_ptr->card_info[ j ].status = QCRIL_CARD_STATUS_UNKNOWN;
    }

    /* Default Emergency callback mode as OFF */
    i_ptr->emer_cb_state = CM_PH_STATE_NORMAL;

    /* Initialize the info recs array */
    i_ptr->cdma_info_recs.recs.numberOfInfoRecs = 0;

    /* Default FDN status */
    i_ptr->fdn_enabled = FALSE;

    #ifdef FEATURE_QCRIL_NCELL
    /* Default Neighbor Cell Info for GSM network */
    memset( &i_ptr->nmr_info, 0, sizeof( i_ptr->nmr_info ) );

    /* Default Neighbor Cell Info for WCDMA network */
    memset( &i_ptr->monitored_set_info, 0, sizeof( i_ptr->monitored_set_info ) );
    #endif /* FEATURE_QCRIL_NCELL */

    /* Initialize the mutex */
    pthread_mutex_init( &i_ptr->card_info_mutex, NULL );
    pthread_mutex_init( &i_ptr->call_fail_cause_mutex, NULL );
    pthread_mutex_init( &i_ptr->fdn_status_mutex, NULL );
    pthread_mutex_init( &i_ptr->cdma_info_rec_mutex, NULL );
    pthread_mutex_init( &i_ptr->emer_cb_state_mutex, NULL );
    pthread_mutex_init( &i_ptr->ph_mutex, NULL );
    pthread_mutex_init( &i_ptr->ss_mutex, NULL );

    for ( j = 0; j < QCRIL_ARB_MAX_MODEMS; j++ ) 
    {
      #ifdef FEATURE_QCRIL_SUBS_CTRL
      /* Initialize subscription state */
      i_ptr->ph_info[ j ].pri_gw_subscription_state = QCRIL_CM_SUBSCRIPTION_DISABLED;
      i_ptr->ph_info[ j ].pri_cdma_subscription_state = QCRIL_CM_SUBSCRIPTION_DISABLED;
      #endif /* FEATURE_QCRIL_SUBS_CTRL */

      /* Initialize operating mode */
      i_ptr->ph_info[ j ].oprt_mode = SYS_OPRT_MODE_NONE;

      /* Initialize mode capability */
      i_ptr->ph_info[ j ].mode_capability = SYS_SYS_MODE_MASK_NONE;  

      /* Initialize band capability */
      i_ptr->ph_info[ j ].band_capability = 0;    

      /* Initialize RTRE configuration */
      i_ptr->ph_info[ j ].rtre_config = CM_RTRE_CONFIG_NONE;

      /* Initialize RTRE control */
      i_ptr->ph_info[ j ].rtre_control = CM_RTRE_CONTROL_NONE;

      /* Default current phone settings to unknown */
      i_ptr->ph_info[ j ].mode_pref = CM_MODE_PREF_NONE;
      i_ptr->ph_info[ j ].gw_acq_order_pref = CM_GW_ACQ_ORDER_PREF_NONE;
      i_ptr->ph_info[ j ].band_pref = CM_BAND_PREF_NONE;
      i_ptr->ph_info[ j ].network_sel_mode_pref = CM_NETWORK_SEL_MODE_PREF_NONE;
      i_ptr->ph_info[ j ].plmn_pref.identity[ 0 ] = 0xFF;
      i_ptr->ph_info[ j ].plmn_pref.identity[ 1 ] = 0xFF;
      i_ptr->ph_info[ j ].plmn_pref.identity[ 2 ] = 0xFF;
      i_ptr->ph_info[ j ].roam_pref = CM_ROAM_PREF_NONE;
                         
      #ifdef FEATURE_QCRIL_DSDS
      /* Default standby and subscription info */
      i_ptr->ph_info[ j ].standby_pref = SYS_MODEM_DS_PREF_NONE;
      i_ptr->ph_info[ j ].active_subs = SYS_MODEM_AS_ID_NONE;
      i_ptr->ph_info[ j ].default_voice_subs = SYS_MODEM_AS_ID_NONE;
      i_ptr->ph_info[ j ].default_data_subs = SYS_MODEM_AS_ID_NONE;
      i_ptr->ph_info[ j ].priority_subs = SYS_MODEM_AS_ID_NONE;

      /* Default TUNE AWAY */
      i_ptr->ph_info[ j ].tune_away = TRUE;

      /* Use saved TUNE AWAY setting if available */
      QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_TUNE_AWAY);

      property_get( property_name, args, "" );
      tuneaway_len = strlen( args );
      if ( tuneaway_len > 0 )
      {
        ret_val = strtoul( args, &end_ptr, 0 );
        if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
        {
          QCRIL_LOG_ERROR( "RID %d Fail to convert TUNE AWAY %s\n", i, args );
        }
        else if ( ret_val > TRUE )
        {
          QCRIL_LOG_ERROR( "RID %d Invalid saved TUNE AWAY %ld, use default\n", i, ret_val );
        }
        else
        {
          i_ptr->ph_info[ j ].tune_away = ( boolean ) ret_val;
          tune_away_status = TRUE;
        }
      }
      QCRIL_LOG_DEBUG( "RID %d TUNE AWAY=%d\n", i, i_ptr->ph_info[ j ].tune_away );

      if(!tune_away_status)
      {
        /* Save TUNE AWAY setting to system property */
        QCRIL_SNPRINTF( args, sizeof( args ), "%d", i_ptr->ph_info[ j ].tune_away);
        if ( property_set( property_name, args ) != E_SUCCESS )
        {
          QCRIL_LOG_ERROR( "RID %d Fail to save %s to system property\n", i, QCRIL_TUNE_AWAY );
        }
      }

      /* Default PAGING PRIORITY to primiary subscription */
      i_ptr->ph_info[ j ].paging_priority = RIL_SUBSCRIPTION_1;

      /* Use saved PAGING PRIORITY setting if available */
      QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_PAGING_PRIORITY);

      property_get( property_name, args, "" );
      paging_priority_len = strlen( args );
      if ( paging_priority_len > 0 )
      {
        ret_val = strtoul( args, &end_ptr, 0 );
        if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
        {
          QCRIL_LOG_ERROR( "RID %d Fail to convert PAGING PRIORITY %s\n", i, args );
        }
        else if ( ret_val > RIL_SUBSCRIPTION_2 )
        {
          QCRIL_LOG_ERROR( "RID %d Invalid saved PAGING PRIORTY %ld, use default\n", i, ret_val );
        }
        else
        {
          i_ptr->ph_info[ j ].paging_priority = ( RIL_SubscriptionType ) ret_val;
          paging_priority_status = TRUE;
        }
      }
      QCRIL_LOG_DEBUG( "RID %d paging priority=%d\n", i, i_ptr->ph_info[ j ].paging_priority);

      if(!paging_priority_status)
      {
        /* Save PAGING PRIORITY setting to system property */
        QCRIL_SNPRINTF( args, sizeof( args ), "%d", i_ptr->ph_info[ j ].paging_priority);
        if ( property_set( property_name, args ) != E_SUCCESS )
        {
          QCRIL_LOG_ERROR( "RID %d Fail to save %s to system property\n", i, QCRIL_PAGING_PRIORITY);
        }
      }
      #endif /* FEATURE_QCRIL_DSDS */

      /* Default Serving System Info to No Service */
      i_ptr->ss_info[ j ].srv_status = SYS_SRV_STATUS_NO_SRV;
      i_ptr->ss_info[ j ].true_srv_status = SYS_SRV_STATUS_NO_SRV;

      /* Default CM client ID data */
      i_ptr->client_info[ j ].client_id_is_valid = FALSE;
      if ( QCRIL_PRIMARY_INSTANCE( i ) )
      {
        i_ptr->client_info[ j ].client_is_primary = TRUE;
      }
      else
      {
        i_ptr->client_info[ j ].client_is_primary = FALSE;
      }
    }

    /* Use saved power save setting if available */
    i_ptr->power_save_enabled = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_ADD_POWER_SAVE);
    property_get( property_name, args, "" );
    power_save_len = strlen( args );
    if ( power_save_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 ); 
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) ) 
      {
        QCRIL_LOG_ERROR( "RID %d Fail to convert power save property %s\n", i, args );
      }
      else if ( ret_val > TRUE )
      {
        QCRIL_LOG_ERROR( "RID %d Invalid power save property value %ld, use default\n", i, ret_val );
      }
      else
      {
        i_ptr->power_save_enabled = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "RID %d power save enabled =%d\n", i, i_ptr->power_save_enabled );

  }

  /* Setup QCRIL CM as CM Client */
  for ( i = 0; i < QCRIL_ARB_MAX_MODEMS; i++ )
  {
    /* Initialize QCRIL CM as CM client */
    QCRIL_LOG_RPC( i, "cm_client_init()", "CM_CLIENT_TYPE_UI client_id", client_id );
    if ( qcril_cm_api_funcs[ i ].cm_client_init_func( CM_CLIENT_TYPE_UI, &client_id ) != CM_CLIENT_OK ) 
    {
      QCRIL_LOG_ERROR( "MID %d Fail to register as CM client\n", i );
      return_errno = E_FAILURE;
    }
    else                                           
    {
      /* Record clilent ID */
      for ( j = 0 ; j < QCRIL_MAX_INSTANCE_ID; j++ )
      {
        i_ptr = &qcril_cm[ j ];
        i_ptr->client_info[ i ].client_id_is_valid = TRUE;
        i_ptr->client_info[ i ].client_id = client_id;
      }

      /* Register for Phone events */
      QCRIL_LOG_RPC( i, "cm_client_ph_reg()", "client_id", client_id );
      for ( j = 0; j < QCRIL_ARR_SIZE( ph_event_list ); j++ )
      {
        if ( qcril_cm_api_funcs[ i ].cm_client_ph_reg_func( client_id, 
                                                            qcril_cm_api_callbacks[ i ].ph_event_callback_func, 
                                                            CM_CLIENT_EVENT_REG,
                                                            ph_event_list[ j ], 
                                                            ph_event_list[ j ], 
                                                            NULL
                                                          ) != CM_CLIENT_OK ) 
        {
          QCRIL_LOG_ERROR( "MID %d Fail to register CM PH event %d\n", i, ph_event_list[ j ] );
          return_errno = E_FAILURE;
        }
      }

      #ifdef FEATURE_QCRIL_DSDS
      /* Register for Subs events */
      QCRIL_LOG_RPC( i, "cm_client_subs_reg()", "client_id", client_id );
      if ( qcril_cm_api_funcs[ i ].cm_client_subs_reg_func( client_id, 
                                                            qcril_cm_api_callbacks[ i ].subs_event_callback_func 
                                                          ) != CM_CLIENT_OK ) 
      {
        QCRIL_LOG_ERROR( "MID %d Fail to register CM Subs\n", i );
        return_errno = E_FAILURE;
      }
      #endif /* FEATURE_QCRIL_DSDS */

      /* Register for Serving System events */
      QCRIL_LOG_RPC( i, "cm_mm_client_ss_reg()", "client_id", client_id );
      for ( j = 0; j < QCRIL_ARR_SIZE( ss_event_list ); j++ )
      {
        if ( qcril_cm_api_funcs[ i ].cm_mm_client_ss_reg_func( client_id, 
                                                               qcril_cm_api_callbacks[ i ].ss_event_callback_func, 
                                                               CM_CLIENT_EVENT_REG,
                                                               ss_event_list[ j ], 
                                                               ss_event_list[ j ],
                                                               NULL
                                                             ) != CM_CLIENT_OK ) 
        {
          QCRIL_LOG_ERROR( "MID %d Fail to register CM SS event %d\n", i, ss_event_list[ j ] );
          return_errno = E_FAILURE;
        }
      }

      /* Register for Call events */
      QCRIL_LOG_RPC( i, "cm_mm_client_call_reg()", "client_id", client_id );
      for ( j = 0; j < QCRIL_ARR_SIZE( call_event_list ); j++ )
      {
        if ( qcril_cm_api_funcs[ i ].cm_mm_client_call_reg_func( client_id, 
                                                                 qcril_cm_api_callbacks[ i ].call_event_callback_func, 
                                                                 CM_CLIENT_EVENT_REG,
                                                                 call_event_list[ j ], 
                                                                 call_event_list[ j ], 
                                                                 NULL
                                                               ) != CM_CLIENT_OK ) 
        {
          QCRIL_LOG_ERROR( "MID %d Fail to register CM Call event %d\n", i, call_event_list[ j ] );
          return_errno = E_FAILURE;
        }
      }

      /* Register for Inband events */
      QCRIL_LOG_RPC( i, "cm_mm_client_inband_reg()", "client_id", client_id );
      for ( j = 0; j < QCRIL_ARR_SIZE( inband_event_list ); j++ )
      {
        if ( qcril_cm_api_funcs[ i ].cm_mm_client_inband_reg_func( client_id, 
                                                                   qcril_cm_api_callbacks[ i ].inband_event_callback_func, 
                                                                   CM_CLIENT_EVENT_REG,
                                                                   inband_event_list[ j ], 
                                                                   inband_event_list[ j ], 
                                                                   NULL
                                                                 ) != CM_CLIENT_OK ) 
        {
          QCRIL_LOG_ERROR( "MID %d Fail to register CM Inband event %d\n", i, inband_event_list[ j ] );
          return_errno = E_FAILURE;
        }
      }

      /* Register for Supplementary Services events */
      QCRIL_LOG_RPC( i, "cm_client_sups_reg()", "client_id", client_id );
      for ( j = 0; j < QCRIL_ARR_SIZE( sups_event_list ); j++ )
      {
        if ( qcril_cm_api_funcs[ i ].cm_client_sups_reg_func( client_id, 
                                                              qcril_cm_api_callbacks[ i ].sups_event_callback_func, 
                                                              CM_CLIENT_EVENT_REG,
                                                              sups_event_list[ j ], 
                                                              sups_event_list[ j ], 
                                                              NULL 
                                                            ) != CM_CLIENT_OK ) 
        {
          QCRIL_LOG_ERROR( "MID %d Fail to register CM Sups event %d\n", i, sups_event_list[ j ] );
          return_errno = E_FAILURE;
        }
      }        

      #ifdef FEATURE_QCRIL_NCELL
      /* Register for Neighbor Cell Information events */
      QCRIL_LOG_RPC( i, "cm_client_stats_reg()", "client_id", client_id );
      if ( qcril_cm_api_funcs[ i ].cm_client_stats_reg_func( client_id, 
                                   qcril_cm_api_callbacks[ i ].stats_event_callback_func, 
                                   CM_CLIENT_EVENT_REG,
                                   stats_event,
                                   stats_event,
                                   NULL 
                                 ) != CM_CLIENT_OK ) 
      {
        QCRIL_LOG_ERROR( "MID %d Fail to register CM Stats event %d\n", i, stats_event );
        return_errno = E_FAILURE;
      }
      else
      {
        QCRIL_LOG_RPC( i, "cm_stats_set_modem_info_mask()", "client_id", client_id );
        if ( !qcril_cm_api_funcs[ i ].cm_stats_set_modem_info_mask_func( NULL, 
                                                                         NULL,
                                                                         client_id, 
                                                                         SYS_MODEM_MODULE_GSM, 
                                                                         CM_GERAN_ENG_MODE_NMR_INFO ) )
        {
          QCRIL_LOG_ERROR( "MID %d Fail to set CM Stats modem GSM info mask %d\n", i, CM_GERAN_ENG_MODE_NMR_INFO );
          return_errno = E_FAILURE;
        }
        if ( !qcril_cm_api_funcs[ i ].cm_stats_set_modem_info_mask_func( NULL,
                                                                         NULL,
                                                                         client_id,
                                                                         SYS_MODEM_MODULE_WCDMA, CM_WCDMA_MONITORED_SET_BIT_MASK ) )
        {
          QCRIL_LOG_ERROR( "MID %d Fail to set CM Stats modem WCDMA info mask %d\n", i, CM_WCDMA_MONITORED_SET_BIT_MASK );
          return_errno = E_FAILURE;
        }
      }
      #endif /* FEATURE_QCRIL_NCELL */
                     
      /* Activate QCRIL CM client */
      QCRIL_LOG_RPC( i, "cm_client_act()", "client_id", client_id );
      if ( qcril_cm_api_funcs[ i ].cm_client_act_func( client_id ) != CM_CLIENT_OK )
      {
        QCRIL_LOG_ERROR( "MID %d Fail to activate CM client %d\n", i, client_id );
        return_errno = E_FAILURE;
      }

      /* Program ECIO delta reporting */
      user_data = QCRIL_COMPOSE_USER_DATA( QCRIL_DEFAULT_INSTANCE_ID, i, QCRIL_REQ_ID_INTERNAL );
      QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, ECIO delta %d", 
                      qcril_log_get_token_id( (RIL_Token) QCRIL_TOKEN_ID_INTERNAL ), i_ptr->ecio_delta );
      QCRIL_LOG_RPC( i, "cm_ph_cmd_signal_strength_delta()", "client_id", client_id );
      if ( !qcril_cm_api_funcs[ i ].cm_ph_cmd_signal_strength_delta_func( qcril_cm_phonesvc_command_callback,
                                                                          (void *) user_data, 
                                                                          client_id,
                                                                          QCRIL_CM_RSSI_DELTA_DEFAULT,
                                                                          i_ptr->ecio_delta,
                                                                          QCRIL_CM_IO_DELTA_DEFAULT ) )
      {
        QCRIL_LOG_ERROR( "MID %d Fail to change rssi delta %d\n", i, i_ptr->ecio_delta );
      }
    }
  }

  memset( &previous_waiting_call_number, 0, sizeof(previous_waiting_call_number) );

  return return_errno;

} /* qcril_cm_init() */


/*=========================================================================
  FUNCTION:  qcril_cm_release

===========================================================================*/
/*!
    @brief
    Release the CM client object.

    @return
    none
*/
/*=========================================================================*/
void qcril_cm_release
( 
  void 
)
{
  uint8 i, j;
  qcril_cm_struct_type *i_ptr;
  cm_client_id_type client_id = 0;

  cm_ph_event_e_type ph_event_list[] = {
    CM_PH_EVENT_SYS_SEL_PREF,
    CM_PH_EVENT_OPRT_MODE,
    CM_PH_EVENT_INFO,

    #ifdef FEATURE_QCRIL_PRL_INIT
    CM_PH_EVENT_PRL_INIT,
    #endif /* FEATURE_QCRIL_PRL_INIT */

    #ifdef FEATURE_QCRIL_SUBS_CTRL
    CM_PH_EVENT_SUBSCRIPTION_AVAILABLE,
    CM_PH_EVENT_SUBSCRIPTION_NOT_AVAILABLE,
    #endif /* FEATURE_QCRIL_SUBS_CTRL */

    #ifdef FEATURE_QCRIL_DSDS
    CM_PH_EVENT_DUAL_STANDBY_PREF,
    CM_PH_EVENT_SUBSCRIPTION_PREF_INFO,
    #endif /* FEATURE_QCRIL_DSDS */

    CM_PH_EVENT_AVAILABLE_NETWORKS_CONF,
    CM_PH_EVENT_TERMINATE_GET_NETWORKS,
    CM_PH_EVENT_NVRUIM_CONFIG_CHANGED
  };

  cm_ss_event_e_type ss_event_list[] = {
    CM_SS_EVENT_SRV_CHANGED,
    CM_SS_EVENT_RSSI,
    CM_SS_EVENT_HDR_RSSI,
    CM_SS_EVENT_EMERG_NUM_LIST,
    CM_SS_EVENT_INFO,
    #ifdef FEATURE_QCRIL_DSAC
    CM_SS_EVENT_CELL_ACCESS_IND,
    #endif /* FEATURE_QCRIL_DSAC */
    CM_SS_EVENT_REG_REJECT
  };

  cm_call_event_e_type call_event_list[] = {
    CM_CALL_EVENT_ORIG,
    CM_CALL_EVENT_SETUP_IND,
    CM_CALL_EVENT_PROGRESS_INFO_IND,
    CM_CALL_EVENT_INCOM,
    CM_CALL_EVENT_ANSWER,
    CM_CALL_EVENT_END,
    CM_CALL_EVENT_SUPS,
    CM_CALL_EVENT_CONNECT,
    CM_CALL_EVENT_PRIVACY,
    CM_CALL_EVENT_PRIVACY_PREF,
    CM_CALL_EVENT_MNG_CALLS_CONF,
    CM_CALL_EVENT_ORIG_FWD_STATUS,
    CM_CALL_EVENT_CALL_BEING_FORWARDED,
    CM_CALL_EVENT_CALL_IS_WAITING,
    CM_CALL_EVENT_CALL_BARRED,
    CM_CALL_EVENT_INCOM_FWD_CALL,
    CM_CALL_EVENT_CUG_INFO_RECEIVED,
    CM_CALL_EVENT_CALL_ON_HOLD,
    CM_CALL_EVENT_CALL_RETRIEVED,
    CM_CALL_EVENT_CALL_FORWARDED,
    CM_CALL_EVENT_CALL_RESTRICTED,
    CM_CALL_EVENT_TRANSFERRED_CALL,
    CM_CALL_EVENT_CALL_DEFLECTION,
    CM_CALL_EVENT_CNAP_INFO_RECEIVED,
    CM_CALL_EVENT_OTASP_STATUS,
    CM_CALL_EVENT_DISPLAY,
    CM_CALL_EVENT_CALLED_PARTY,
    CM_CALL_EVENT_CALLER_ID,
    CM_CALL_EVENT_CONNECTED_NUM,
    CM_CALL_EVENT_SIGNAL,
    CM_CALL_EVENT_REDIRECTING_NUMBER,
    CM_CALL_EVENT_LINE_CTRL,
    CM_CALL_EVENT_EXT_DISP,
    CM_CALL_EVENT_EXT_BRST_INTL,
    CM_CALL_EVENT_NSS_CLIR_REC,
    CM_CALL_EVENT_NSS_REL_REC,
    CM_CALL_EVENT_NSS_AUD_CTRL,
    CM_CALL_EVENT_USER_DATA_IND
  };

  cm_inband_event_e_type inband_event_list[] = {
    CM_INBAND_EVENT_REV_BURST_DTMF,
    CM_INBAND_EVENT_REV_START_CONT_DTMF_CONF,
    CM_INBAND_EVENT_REV_STOP_CONT_DTMF_CONF,
    CM_INBAND_EVENT_FWD_BURST_DTMF,
    CM_INBAND_EVENT_FWD_START_CONT_DTMF,
    CM_INBAND_EVENT_FWD_STOP_CONT_DTMF
  };

  cm_sups_event_e_type sups_event_list[] = {
    CM_SUPS_EVENT_ACTIVATE,
    CM_SUPS_EVENT_ACTIVATE_CONF,
    CM_SUPS_EVENT_DEACTIVATE,
    CM_SUPS_EVENT_DEACTIVATE_CONF,
    CM_SUPS_EVENT_ERASE,
    CM_SUPS_EVENT_ERASE_CONF,
    CM_SUPS_EVENT_INTERROGATE,
    CM_SUPS_EVENT_INTERROGATE_CONF,
    CM_SUPS_EVENT_REGISTER,
    CM_SUPS_EVENT_REGISTER_CONF,
    CM_SUPS_EVENT_REG_PASSWORD,
    CM_SUPS_EVENT_REG_PASSWORD_CONF,
    CM_SUPS_EVENT_PROCESS_USS,
    CM_SUPS_EVENT_PROCESS_USS_CONF,
    CM_SUPS_EVENT_USS_IND,
    CM_SUPS_EVENT_USS_NOTIFY_IND,
    CM_SUPS_EVENT_RELEASE_USS_IND,
    CM_SUPS_EVENT_GET_PASSWORD_IND
  };

  /*-----------------------------------------------------------------------*/
   i_ptr = &qcril_cm[ QCRIL_DEFAULT_INSTANCE_ID ];

  /* De-register all the command call backs */
  for ( i = 0 ; i < QCRIL_ARB_MAX_MODEMS; i++ )
  {

    client_id = i_ptr->client_info[ i ].client_id;

      /* De-register for Phone events */
      QCRIL_LOG_RPC( i, "cm_client_ph_reg()", "client_id", client_id );
      for ( j = 0; j < QCRIL_ARR_SIZE( ph_event_list ); j++ )
      {
        if ( qcril_cm_api_funcs[ i ].cm_client_ph_reg_func( client_id,
                                                            qcril_cm_api_callbacks[ i ].ph_event_callback_func,
                                                            CM_CLIENT_EVENT_DEREG,
                                                            ph_event_list[ j ],
                                                            ph_event_list[ j ],
                                                            NULL
                                                          ) != CM_CLIENT_OK )
        {
          QCRIL_LOG_ERROR( "MID %d Fail to de-register CM PH event %d\n", i, ph_event_list[ j ] );
        }
      }

      #ifdef FEATURE_QCRIL_DSDS
      /* De-register for Subs events */
/*      QCRIL_LOG_RPC( i, "cm_client_subs_reg()", "client_id", client_id );
      if ( qcril_cm_api_funcs[ i ].cm_client_subs_reg_func( client_id,
                                                            qcril_cm_api_callbacks[ i ].subs_event_callback_func
                                                          ) != CM_CLIENT_OK )
      {
        QCRIL_LOG_ERROR( "MID %d Fail to De-register CM Subs\n", i );
      } */
      #endif /* FEATURE_QCRIL_DSDS */

      /* De-register for Serving System events */
      QCRIL_LOG_RPC( i, "cm_mm_client_ss_reg()", "client_id", client_id );
      for ( j = 0; j < QCRIL_ARR_SIZE( ss_event_list ); j++ )
      {
        if ( qcril_cm_api_funcs[ i ].cm_mm_client_ss_reg_func( client_id,
                                                               qcril_cm_api_callbacks[ i ].ss_event_callback_func,
                                                               CM_CLIENT_EVENT_DEREG,
                                                               ss_event_list[ j ], 
                                                               ss_event_list[ j ],
                                                               NULL
                                                             ) != CM_CLIENT_OK )
        {
          QCRIL_LOG_ERROR( "MID %d Fail to De-register CM SS event %d\n", i, ss_event_list[ j ] );
        }
      }

      /* De-register for Call events */
      QCRIL_LOG_RPC( i, "cm_mm_client_call_reg()", "client_id", client_id );
      for ( j = 0; j < QCRIL_ARR_SIZE( call_event_list ); j++ )
      {
        if ( qcril_cm_api_funcs[ i ].cm_mm_client_call_reg_func( client_id,
                                                                 qcril_cm_api_callbacks[ i ].call_event_callback_func,
                                                                 CM_CLIENT_EVENT_DEREG,
                                                                 call_event_list[ j ],
                                                                 call_event_list[ j ],
                                                                 NULL
                                                               ) != CM_CLIENT_OK )
        {
          QCRIL_LOG_ERROR( "MID %d Fail to De-register CM Call event %d\n", i, call_event_list[ j ] );
        }
      }

      /* De-register for Inband events */
      QCRIL_LOG_RPC( i, "cm_mm_client_inband_reg()", "client_id", client_id );
      for ( j = 0; j < QCRIL_ARR_SIZE( inband_event_list ); j++ )
      {
        if ( qcril_cm_api_funcs[ i ].cm_mm_client_inband_reg_func( client_id,
                                                                   qcril_cm_api_callbacks[ i ].inband_event_callback_func,
                                                                   CM_CLIENT_EVENT_DEREG,
                                                                   inband_event_list[ j ],
                                                                   inband_event_list[ j ],
                                                                   NULL
                                                                 ) != CM_CLIENT_OK )
        {
          QCRIL_LOG_ERROR( "MID %d Fail to De-register CM Inband event %d\n", i, inband_event_list[ j ] );
        }
      }

      /* De-register for Supplementary Services events */
      QCRIL_LOG_RPC( i, "cm_client_sups_reg()", "client_id", client_id );
      for ( j = 0; j < QCRIL_ARR_SIZE( sups_event_list ); j++ )
      {
        if ( qcril_cm_api_funcs[ i ].cm_client_sups_reg_func( client_id,
                                                              qcril_cm_api_callbacks[ i ].sups_event_callback_func,
                                                              CM_CLIENT_EVENT_DEREG,
                                                              sups_event_list[ j ],
                                                              sups_event_list[ j ],
                                                              NULL 
                                                            ) != CM_CLIENT_OK ) 
        {
          QCRIL_LOG_ERROR( "MID %d Fail to De-register CM Sups event %d\n", i, sups_event_list[ j ] );
        }
      }
  }

  /* Release QCRIL CM as CM client */
  for ( i = 0; i < QCRIL_ARB_MAX_INSTANCES; i++ )
  {
    i_ptr = &qcril_cm[ i ];

    for ( j = 0; j < QCRIL_ARB_MAX_MODEMS; j++ ) 
    {
      if ( i_ptr->client_info[ j ].client_id_is_valid )
      {
        i_ptr->client_info[ j ].client_id_is_valid = FALSE;

        if ( i_ptr->client_info[ j ].client_is_primary )
        {
          QCRIL_LOG_RPC( j, "cm_client_release()", "client_id", i_ptr->client_info[ j ].client_id );
          (void) qcril_cm_api_funcs[ j ].cm_client_release_func( i_ptr->client_info[ j ].client_id ); 
        }
      }
    }
  }

} /* qcril_cm_release */


/*=========================================================================
  FUNCTION:  qcril_cm_ftm_mode_is_on

===========================================================================*/
/*!
    @brief
    Check whether phone is currently in FTM mode.

    @return
    True indicates FTM mode on. 
    False indicates FTM mode off.
*/
/*=========================================================================*/
boolean qcril_cm_ftm_mode_is_on
( 
  qcril_instance_id_e_type instance_id
)
{
  uint8 i;
  qcril_cm_struct_type *i_ptr;
  boolean ftm_mode = FALSE;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  for ( i = 0; i < QCRIL_ARB_MAX_MODEMS; i++ )
  {
    if ( i_ptr->ph_info[ i ].oprt_mode == SYS_OPRT_MODE_FTM )
    {
      ftm_mode = TRUE;
      QCRIL_LOG_DEBUG( "MID %d FTM Mode: On\n", i );
      break;
    }
  }

  if ( !ftm_mode ) 
  {
    QCRIL_LOG_DEBUG( "%s\n", "FTM Mode: Off" );
  }
  return ftm_mode;

} /* qcril_cm_ftm_mode_is_on */


/*=========================================================================
  FUNCTION:  qcril_cm_phone_capability_is_reported

===========================================================================*/
/*!
    @brief
    Check whether phone's capability is reported 

    @return
    True indicates phone's capability is already reported 
    False indicates phone's capability is not reported yet
*/
/*=========================================================================*/
boolean qcril_cm_phone_capability_is_reported
( 
  qcril_instance_id_e_type instance_id
)
{
  uint8 i;
  qcril_cm_struct_type *i_ptr;
  boolean phone_capability_known = TRUE;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  for ( i = 0; i < QCRIL_ARB_MAX_MODEMS; i++ )
  {
    if ( !i_ptr->ph_info[ i ].capability_reported )  
    {
      QCRIL_LOG_DEBUG( "MID %d Phone capability not known\n", i );
      phone_capability_known = FALSE;
      break;
    }
  }

  if ( phone_capability_known ) 
  {
    QCRIL_LOG_DEBUG( "%s\n", "Overall phone capability is known" );
  }

  return phone_capability_known;

} /* qcril_cm_phone_capability_is_reported */


/*=========================================================================
  FUNCTION:  qcril_cm_card_status_is_reported

===========================================================================*/
/*!
    @brief
    Check whether card status is reported 

    @return
    True indicates card status is already reported 
    False indicates card status is not reported yet
*/
/*=========================================================================*/
boolean qcril_cm_card_status_is_reported
( 
  qcril_instance_id_e_type instance_id
)
{
  uint8 i;
  qcril_cm_struct_type *i_ptr;
  boolean card_status_known = TRUE;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  for ( i = 0; i < QCRIL_ARB_MAX_SLOTS; i++ )
  {
    if ( i_ptr->card_info[ i ].status == QCRIL_CARD_STATUS_UNKNOWN ) 
    {
      QCRIL_LOG_DEBUG( "Slot %d Card Status unknown", i );
      card_status_known = FALSE;
    }
  }

  if ( card_status_known ) 
  {
    QCRIL_LOG_DEBUG( "%s\n", "Overall card Status is known" );
  }

  return card_status_known;

} /* qcril_cm_card_status_is_reported */


/*=========================================================================
  FUNCTION:  qcril_cm_card_status_is_down

===========================================================================*/
/*!
    @brief
    Check whether card status is DOWN

    @return
    True indicates card status is DOWN 
    False indicates card status is not DOWN
*/
/*=========================================================================*/
boolean qcril_cm_card_status_is_down
( 
  qcril_instance_id_e_type instance_id,
  qcril_slot_ids_list_type *slot_ids_list
)
{
  uint8 i;
  qcril_cm_struct_type *i_ptr;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( slot_ids_list != NULL );

  /*-----------------------------------------------------------------------*/

  slot_ids_list->num_of_slots = 0;

  for ( i = 0; i < QCRIL_ARB_MAX_SLOTS; i++ )
  {
    if ( i_ptr->card_info[ i ].status == QCRIL_CARD_STATUS_DOWN ) 
    {
      QCRIL_LOG_DEBUG( "Slot %d Card Status is DOWN", i );
      slot_ids_list->slot_id[ slot_ids_list->num_of_slots ] = i;
      slot_ids_list->num_of_slots += 1;
    }
  }

  if ( slot_ids_list->num_of_slots > 0 ) 
  {
    QCRIL_LOG_DEBUG( "Overall card Status is DOWN, total num slots %d\n", slot_ids_list->num_of_slots );
    return TRUE;
  }

  return FALSE;

} /* qcril_cm_card_status_is_down */


/*=========================================================================
  FUNCTION:  qcril_cm_card_status_is_up

===========================================================================*/
/*!
    @brief
    Check whether card status is UP

    @return
    True indicates card status is UP 
    False indicates card status is not UP
*/
/*=========================================================================*/
boolean qcril_cm_card_status_is_up
( 
  qcril_instance_id_e_type instance_id,
  qcril_slot_ids_list_type *slot_ids_list
)
{
  uint8 i;
  qcril_cm_struct_type *i_ptr;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( slot_ids_list != NULL );

  /*-----------------------------------------------------------------------*/

  slot_ids_list->num_of_slots = 0;

  for ( i = 0; i < QCRIL_ARB_MAX_SLOTS; i++ )
  {
    if ( ( i_ptr->card_info[ i ].status == QCRIL_CARD_STATUS_UP ) ||
         ( i_ptr->card_info[ i ].status == QCRIL_CARD_STATUS_ILLEGAL ) )
    {
      QCRIL_LOG_DEBUG( "Slot %d Card Status is UP/ILLEGAL, status = %d", i, i_ptr->card_info[ i ].status);
      slot_ids_list->slot_id[ slot_ids_list->num_of_slots ] = i;
      slot_ids_list->num_of_slots += 1;
    }
  }

  if ( slot_ids_list->num_of_slots > 0 ) 
  {
    QCRIL_LOG_DEBUG( "Overall card Status is UP, total num slots %d\n", slot_ids_list->num_of_slots );
    return TRUE;
  }

  return FALSE;

} /* qcril_cm_card_status_is_up */


/*=========================================================================
  FUNCTION:  qcril_cm_card_pwr_oprt_is_completed

===========================================================================*/
/*!
    @brief
    Check whether card(s) power up/down operation is completed.

    @return
    True indicates card(s) power up/down operation is completed. 
    False indicates card(s) power up/down operation is completed.
*/
/*=========================================================================*/
boolean qcril_cm_card_pwr_oprt_is_completed
( 
  qcril_instance_id_e_type instance_id
)
{
  uint8 i;
  qcril_cm_struct_type *i_ptr;
  boolean card_pwr_oprt_in_progress = FALSE;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  for ( i = 0; i < QCRIL_ARB_MAX_SLOTS; i++ )
  {
    if ( i_ptr->card_info[ i ].pwr_oprt_in_progress ) 
    {
      QCRIL_LOG_DEBUG( "Slot %d Card pwr oprt in progress", i );
      card_pwr_oprt_in_progress = TRUE;
      break;
    }
  }

  if ( !card_pwr_oprt_in_progress ) 
  {
    QCRIL_LOG_DEBUG( "%s\n", "All card pwr oprt completed" );
  }

  return !card_pwr_oprt_in_progress;

} /* qcril_cm_card_pwr_oprt_is_completed */


/*=========================================================================
  FUNCTION:  qcril_cm_update_card_status

===========================================================================*/
/*!
    @brief
    Update card status

    @return
    None
*/
/*=========================================================================*/
void qcril_cm_update_card_status
( 
  qcril_instance_id_e_type instance_id,
  uint8 slot,
  boolean pwr_oprt_in_progress,
  qcril_card_status_e_type card_status
)
{
  #ifdef FEATURE_QCRIL_DSDS
  uint8 i;
  #endif /* FEATURE_QCRIL_DSDS */
  qcril_cm_struct_type *i_ptr;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  if ( slot >= QCRIL_ARB_MAX_SLOTS )
  {
    QCRIL_LOG_ERROR( "Unexpected card status update from slot %d\n", slot );
    return;
  }

  #ifdef FEATURE_QCRIL_DSDS
  for ( i = 0; i < QCRIL_ARB_MAX_INSTANCES; i++ )
  #endif /* FEATURE_QCRIL_DSDS */
  {
    #ifdef FEATURE_QCRIL_DSDS
    i_ptr = &qcril_cm[ i ];
    #endif /* FEATURE_QCRIL_DSDS */
     
    i_ptr->card_info[ slot ].pwr_oprt_in_progress = pwr_oprt_in_progress;

    if ( ( card_status != QCRIL_CARD_STATUS_POWERUP_FAILED ) && ( card_status != QCRIL_CARD_STATUS_POWERDOWN_FAILED ) ) 
    {
      i_ptr->card_info[ slot ].status = card_status;
    }

    QCRIL_LOG_DEBUG( "RID %d Slot %d, Pwr oprt in progress %d, Card status %s[%d]\n", 
                     instance_id, slot, i_ptr->card_info[ slot ].pwr_oprt_in_progress,
                     card_status_name[ i_ptr->card_info[ slot ].status ], i_ptr->card_info[ slot ].status );
  }

} /* qcril_cm_update_card_status */


/*=========================================================================
  FUNCTION:  qcril_cm_sync_card_status

===========================================================================*/
/*!
    @brief
    Command modem change tio LPM with subscription disabled. Request an
    update on network state .

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_sync_card_status
(
  qcril_instance_id_e_type instance_id
)
{
  qcril_cm_struct_type *i_ptr;
  uint8 i, j;
  boolean nv_rtre_control = TRUE;
  boolean net_pref_restored;
  qcril_cm_net_pref_e_type net_pref;
  qcril_arb_ma_e_type ma;
  
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  /* Query stored network preference */
  qcril_arb_query_net_pref( instance_id, &net_pref_restored, &net_pref, &ma );

  /* Check whether it is NV only */
  if ( ( net_pref ==  QCRIL_CM_NET_PREF_CDMA_EVDO ) || ( net_pref == QCRIL_CM_NET_PREF_CDMA_ONLY ) || 
       ( net_pref == QCRIL_CM_NET_PREF_EVDO_ONLY ) || ( net_pref == QCRIL_CM_NET_PREF_LTE_CDMA_EVDO ) ||
       ( net_pref == QCRIL_CM_NET_PREF_LTE_ONLY ) )
  {
    for ( i = 0; i < QCRIL_ARB_MAX_MODEMS; i++ )
    {
      if ( i_ptr->ph_info[ i ].rtre_control != CM_RTRE_CONTROL_NV )
      {
        nv_rtre_control = FALSE;
        QCRIL_LOG_DEBUG( "MID %d NV is not the subscription source", i );
        break;
      }
    }
  }
  else
  { 
    QCRIL_LOG_DEBUG( "RID %d preferred network %d requires sim status", instance_id, net_pref );
    nv_rtre_control = FALSE;
  }

  /* NV is the subscription source control, no need to wait for Card Status Update that may never come */
  if ( nv_rtre_control )
  {
    QCRIL_LOG_DEBUG( "%s\n", "Overall NV is the subscription source" );
            
    for ( j = 0; j < QCRIL_ARB_MAX_SLOTS; j++ )
    {
      if ( i_ptr->card_info[ j ].status == QCRIL_CARD_STATUS_UNKNOWN )
      {
        i_ptr->card_info[ j ].status = QCRIL_CARD_STATUS_NOT_APPLICABLE;
        QCRIL_LOG_DEBUG( "No need to wait for card %d status update - NV\n", j );
      }
    }
  }

} /* qcril_cm_sync_card_status */


/*===========================================================================

  FUNCTION:  qcril_cm_validate_net_pref_vs_modem_capability

===========================================================================*/
/*!
    @brief
    Validate the specified network preference against modem capability. Also
    fill up the ReqList entry for the specified network preference.

    @return
    E_SUCCESS if the request should be can be served by QC modem
    E_FAILURE if the request should be cannot be served by QC modem

*/
/*=========================================================================*/
IxErrnoType qcril_cm_validate_net_pref_vs_modem_capability
(
  qcril_instance_id_e_type instance_id,
  int net_pref,
  qcril_cm_network_pref_type *req_network_pref_ptr
)
{
  IxErrnoType status = E_FAILURE;
  qcril_modem_id_e_type cdma_modem_id, evdo_modem_id, gwl_modem_id;
  boolean net_pref_restored;
  qcril_cm_net_pref_e_type net_pref_stored;
  qcril_arb_ma_e_type ma;
  qcril_cm_struct_type *i_ptr;
  uint8 i;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( req_network_pref_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  i_ptr = &qcril_cm[ instance_id ];

  /* Query stored network preference */
  qcril_arb_query_net_pref( instance_id, &net_pref_restored, &net_pref_stored, &ma );

  /* Lookup modem ids based on the underlyig architecture */
  qcril_arb_query_arch_modem_id( &cdma_modem_id, &evdo_modem_id, &gwl_modem_id );

  /* Map specified network preference to mode pref, acquisition order and operating mode */
  for ( i = 0; i < QCRIL_MAX_MODEM_ID; i++ )
  {
    req_network_pref_ptr->mode_pref[ i ] = CM_MODE_PREF_NONE;
    req_network_pref_ptr->acq_order_pref[ i ] = CM_GW_ACQ_ORDER_PREF_NONE;
    req_network_pref_ptr->oprt_mode[ i ] = SYS_OPRT_MODE_NONE ;
  }

  switch ( net_pref )
  {
    case QCRIL_CM_NET_PREF_GSM_WCDMA_PREFERRED:
      /* Split modem QC Solution or Standalone solution */
      if ( ma != QCRIL_ARB_MA_FUSION_TPS ) 
      {
        if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_GSM( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) ||
             QCRIL_CM_MODE_CAPABILITY_SUPPORT_WCDMA( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) ) 
        {
          req_network_pref_ptr->mode_pref[ gwl_modem_id ] = CM_MODE_PREF_GSM_WCDMA_ONLY;
          req_network_pref_ptr->acq_order_pref[ gwl_modem_id ] = CM_GW_ACQ_ORDER_PREF_WCDMA_GSM;
          req_network_pref_ptr->oprt_mode[ gwl_modem_id ] = SYS_OPRT_MODE_ONLINE;
          if ( ma == QCRIL_ARB_MA_FUSION_QCS ) 
          {
            req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
          }
          status = E_SUCCESS;
        }
      }
      /* Split modem Third Party Solution */
      else  
      {
        req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
        status = E_SUCCESS;
      }
      break;

    case QCRIL_CM_NET_PREF_GSM_WCDMA_AUTO:
      /* Standalone modem or Split modem QC Solution */
      if ( ma != QCRIL_ARB_MA_FUSION_TPS )
      {
        if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_GSM( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) ||
             QCRIL_CM_MODE_CAPABILITY_SUPPORT_WCDMA( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) )
        {
          req_network_pref_ptr->mode_pref[ gwl_modem_id ] = CM_MODE_PREF_GSM_WCDMA_ONLY;
          req_network_pref_ptr->acq_order_pref[ gwl_modem_id ] = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
          req_network_pref_ptr->oprt_mode[ gwl_modem_id ] = SYS_OPRT_MODE_ONLINE;
          if ( ma == QCRIL_ARB_MA_FUSION_QCS ) 
          {
            req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
          }

          status = E_SUCCESS;
        }
      }
      else 
      {
        req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
        status = E_SUCCESS;
      }
      break;

    case QCRIL_CM_NET_PREF_GSM_ONLY:
      /* Standalone modem or Split modem QC Solution */
      if ( ma != QCRIL_ARB_MA_FUSION_TPS ) 
      {
        if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_GSM( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) )
        {
          req_network_pref_ptr->mode_pref[ gwl_modem_id ] = CM_MODE_PREF_GSM_ONLY;
          req_network_pref_ptr->acq_order_pref[ gwl_modem_id ] = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
          req_network_pref_ptr->oprt_mode[ gwl_modem_id ] = SYS_OPRT_MODE_ONLINE;
          if ( ma == QCRIL_ARB_MA_FUSION_QCS ) 
          {
            req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
          }

          status = E_SUCCESS;
        }
      }
      /* Split modem Third Party Solution */
      else  
      {
        req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
        status = E_SUCCESS;
      }
      break;

    case QCRIL_CM_NET_PREF_WCDMA_ONLY:
      /* Standalone modem or Split modem QC Solution */
      if ( ma != QCRIL_ARB_MA_FUSION_TPS ) 
      {
        if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_WCDMA( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) )
        {
          req_network_pref_ptr->mode_pref[ gwl_modem_id ] = CM_MODE_PREF_WCDMA_ONLY;
          req_network_pref_ptr->acq_order_pref[ gwl_modem_id ] = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
          req_network_pref_ptr->oprt_mode[ gwl_modem_id ] = SYS_OPRT_MODE_ONLINE;
          if ( ma == QCRIL_ARB_MA_FUSION_QCS ) 
          {
            req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
          }

          status = E_SUCCESS;
        }
      }
      /* Split modem Third Party Solution */
      else 
      {
        req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
        status = E_SUCCESS;
      }
      break;

    case QCRIL_CM_NET_PREF_CDMA_EVDO:
      /* Standalone modem or Split modem Third Party Solution */
      if ( ma != QCRIL_ARB_MA_FUSION_QCS )
      {
        if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_CDMA( i_ptr->ph_info[ cdma_modem_id ].mode_capability ) ||
             QCRIL_CM_MODE_CAPABILITY_SUPPORT_HDR( i_ptr->ph_info[ evdo_modem_id ].mode_capability ) ) 
        {
          req_network_pref_ptr->mode_pref[ cdma_modem_id ] = CM_MODE_PREF_CDMA_HDR_ONLY;
          req_network_pref_ptr->acq_order_pref[ cdma_modem_id ] = CM_GW_ACQ_ORDER_PREF_NO_CHANGE;
          req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_ONLINE;
          status = E_SUCCESS;
        }
      }
      /* Split modem QC Solution */
      else
      {
        if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_CDMA( i_ptr->ph_info[ cdma_modem_id ].mode_capability ) &&
             QCRIL_CM_MODE_CAPABILITY_SUPPORT_HDR( i_ptr->ph_info[ evdo_modem_id ].mode_capability ) ) 
        {
          req_network_pref_ptr->mode_pref[ cdma_modem_id ] = CM_MODE_PREF_CDMA_ONLY;
          req_network_pref_ptr->acq_order_pref[ cdma_modem_id ] = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
          req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_ONLINE;
          req_network_pref_ptr->mode_pref[ evdo_modem_id ] = CM_MODE_PREF_HDR_ONLY;
          req_network_pref_ptr->acq_order_pref[ evdo_modem_id ] = CM_GW_ACQ_ORDER_PREF_NO_CHANGE;
          req_network_pref_ptr->oprt_mode[ evdo_modem_id ] = SYS_OPRT_MODE_ONLINE;
          status = E_SUCCESS;
        }
      }
      break;

    case QCRIL_CM_NET_PREF_CDMA_ONLY:
      if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_CDMA( i_ptr->ph_info[ cdma_modem_id ].mode_capability ) )
      {
        req_network_pref_ptr->mode_pref[ cdma_modem_id ] = CM_MODE_PREF_CDMA_ONLY;
        req_network_pref_ptr->acq_order_pref[ cdma_modem_id ] = CM_GW_ACQ_ORDER_PREF_NO_CHANGE;
        req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_ONLINE;
        if ( ma == QCRIL_ARB_MA_FUSION_QCS ) 
        {
          req_network_pref_ptr->oprt_mode[ gwl_modem_id ] = SYS_OPRT_MODE_LPM;
        }

        status = E_SUCCESS;
      }
      break;

    case QCRIL_CM_NET_PREF_EVDO_ONLY:
      if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_HDR( i_ptr->ph_info[ evdo_modem_id ].mode_capability ) )
      {
        req_network_pref_ptr->mode_pref[ evdo_modem_id ] = CM_MODE_PREF_HDR_ONLY;
        req_network_pref_ptr->acq_order_pref[ evdo_modem_id ] = CM_GW_ACQ_ORDER_PREF_NO_CHANGE;
        req_network_pref_ptr->oprt_mode[ evdo_modem_id ] = SYS_OPRT_MODE_ONLINE;
        if ( ma == QCRIL_ARB_MA_FUSION_QCS ) 
        {
          req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
        }

        status = E_SUCCESS;
      }
      break;

    case QCRIL_CM_NET_PREF_GSM_WCDMA_CDMA_EVDO:
      /* Standalone modem */
      if ( ( ma == QCRIL_ARB_MA_MULTIMODE ) || ( ma == QCRIL_ARB_MA_DSDS ) )
      {
        req_network_pref_ptr->mode_pref [ cdma_modem_id ]= CM_MODE_PREF_DIGITAL_ONLY;
        req_network_pref_ptr->acq_order_pref [ cdma_modem_id ]= CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
        req_network_pref_ptr->oprt_mode [ cdma_modem_id ]= SYS_OPRT_MODE_ONLINE;
        status = E_SUCCESS;
      }
      break;

    case QCRIL_CM_NET_PREF_LTE_CDMA_EVDO:
      /* Split modem Third Party Solution */
      if ( ma == QCRIL_ARB_MA_FUSION_TPS ) 
      {
        if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_CDMA( i_ptr->ph_info[ cdma_modem_id ].mode_capability ) ||
             QCRIL_CM_MODE_CAPABILITY_SUPPORT_HDR( i_ptr->ph_info[ evdo_modem_id ].mode_capability ) ) 
        {
          req_network_pref_ptr->mode_pref[ cdma_modem_id ] = CM_MODE_PREF_CDMA_HDR_ONLY;
          req_network_pref_ptr->acq_order_pref[ cdma_modem_id ] = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
          req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_ONLINE;
          status = E_SUCCESS;
        }
      }
      #ifdef FEATURE_QCRIL_LTE
      /* Split modem QC Solution */
      else if ( ma == QCRIL_ARB_MA_FUSION_QCS ) 
      {
        if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_CDMA( i_ptr->ph_info[ cdma_modem_id ].mode_capability ) &&
             ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_HDR( i_ptr->ph_info[ evdo_modem_id ].mode_capability ) ||
               QCRIL_CM_MODE_CAPABILITY_SUPPORT_LTE( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) ) )
        {
          req_network_pref_ptr->mode_pref[ cdma_modem_id ] = CM_MODE_PREF_CDMA_ONLY;
          req_network_pref_ptr->acq_order_pref[ cdma_modem_id ] = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
          req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_ONLINE;
          req_network_pref_ptr->mode_pref[ gwl_modem_id ] = CM_MODE_PREF_HDR_LTE_ONLY;
          req_network_pref_ptr->acq_order_pref[ gwl_modem_id ] = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
          req_network_pref_ptr->oprt_mode[ gwl_modem_id ] = SYS_OPRT_MODE_ONLINE;
          status = E_SUCCESS;
        }
      }
      #endif /* FEATURE_QCRIL_LTE */
      break;

    case QCRIL_CM_NET_PREF_LTE_GSM_WCDMA:
      /* Split modem Third Party Solution */
      if ( ma == QCRIL_ARB_MA_FUSION_TPS ) 
      {
        req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
        status = E_SUCCESS;
      }
      #ifdef FEATURE_QCRIL_LTE
      /* Split modem QC Solution */
      else if ( ma == QCRIL_ARB_MA_FUSION_QCS ) 
      {
        if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_GSM( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) ||
             QCRIL_CM_MODE_CAPABILITY_SUPPORT_WCDMA( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) ||
             QCRIL_CM_MODE_CAPABILITY_SUPPORT_LTE( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) )
        {
          req_network_pref_ptr->mode_pref[ gwl_modem_id ] = CM_MODE_PREF_GWL;
          req_network_pref_ptr->acq_order_pref[ gwl_modem_id ] = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
          req_network_pref_ptr->oprt_mode[ gwl_modem_id ] = SYS_OPRT_MODE_ONLINE;
          req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
          status = E_SUCCESS;
        }
      }
      #endif /* FEATURE_QCRIL_LTE */
      break;

    case QCRIL_CM_NET_PREF_LTE_CDMA_EVDO_GSM_WCDMA:
      /* Split modem Third Party Solution */
      if ( ma == QCRIL_ARB_MA_FUSION_TPS ) 
      {
        if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_CDMA( i_ptr->ph_info[ cdma_modem_id ].mode_capability ) ||
             QCRIL_CM_MODE_CAPABILITY_SUPPORT_HDR( i_ptr->ph_info[ evdo_modem_id ].mode_capability ) ) 
        {
          req_network_pref_ptr->mode_pref[ cdma_modem_id ] = CM_MODE_PREF_CDMA_HDR_ONLY;
          req_network_pref_ptr->acq_order_pref[ cdma_modem_id ] = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
          req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_ONLINE;
          status = E_SUCCESS;
        }
      }
      #ifdef FEATURE_QCRIL_LTE
      /* Split modem QC Solution */
      else if ( ma == QCRIL_ARB_MA_FUSION_QCS ) 
      {
        if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_CDMA( i_ptr->ph_info[ cdma_modem_id ].mode_capability ) &&
             ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_HDR( i_ptr->ph_info[ evdo_modem_id ].mode_capability ) ||
               QCRIL_CM_MODE_CAPABILITY_SUPPORT_GSM( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) ||
               QCRIL_CM_MODE_CAPABILITY_SUPPORT_WCDMA( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) ||
               QCRIL_CM_MODE_CAPABILITY_SUPPORT_LTE( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) ) )
        {
          req_network_pref_ptr->mode_pref[ cdma_modem_id ] = CM_MODE_PREF_CDMA_ONLY;
          req_network_pref_ptr->acq_order_pref[ cdma_modem_id ] = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
          req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_ONLINE;
          req_network_pref_ptr->mode_pref[ gwl_modem_id ] = CM_MODE_PREF_DIGITAL_ONLY;
          req_network_pref_ptr->acq_order_pref[ gwl_modem_id ] = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
          req_network_pref_ptr->oprt_mode[ gwl_modem_id ] = SYS_OPRT_MODE_ONLINE;
          status = E_SUCCESS;
        }
      }
      #endif /* FEATURE_QCRIL_LTE */
      break;

    case QCRIL_CM_NET_PREF_LTE_ONLY:
      /* Split modem Third Party Solution */
      if ( ma == QCRIL_ARB_MA_FUSION_TPS ) 
      {
        req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
        status = E_SUCCESS;
      }
      #ifdef FEATURE_QCRIL_LTE
      /* Split modem QC Solution */
      else if ( ma == QCRIL_ARB_MA_FUSION_QCS ) 
      {
        if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_LTE( i_ptr->ph_info[ gwl_modem_id ].mode_capability ) )
        {
          req_network_pref_ptr->mode_pref[ gwl_modem_id ] = CM_MODE_PREF_LTE_ONLY;
          req_network_pref_ptr->acq_order_pref[ gwl_modem_id ] = CM_GW_ACQ_ORDER_PREF_AUTOMATIC;
          req_network_pref_ptr->oprt_mode[ gwl_modem_id ] = SYS_OPRT_MODE_ONLINE;
          req_network_pref_ptr->oprt_mode[ cdma_modem_id ] = SYS_OPRT_MODE_LPM;
          status = E_SUCCESS;
        }
      }
      #endif /* FEATURE_QCRIL_LTE */
      break;

    default:
      status = E_FAILURE;
      break;
  }

  return status;

} /* qcril_cm_validate_net_pref_vs_modem_capability */


/*=========================================================================
  FUNCTION:  qcril_cm_sync_network_preference

===========================================================================*/
/*!
    @brief
    Command modem change tio LPM with subscription disabled. Request an
    update on network state .

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_sync_network_preference
(
  qcril_instance_id_e_type instance_id
)
{
  qcril_modem_id_e_type modem_id, cdma_modem_id, evdo_modem_id, gwl_modem_id;
  boolean net_pref_restored, valid_net_pref = FALSE, net_pref_changed = FALSE;
  qcril_cm_net_pref_e_type net_pref;
  qcril_arb_ma_e_type ma;
  uint32 user_data;
  char details[ 40 ];
  qcril_cm_struct_type *i_ptr;
  qcril_reqlist_u_type u_info;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref_per_subs()";
  #else
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  /* Query stored network preference */
  qcril_arb_query_net_pref( instance_id, &net_pref_restored, &net_pref, &ma );

  /* Valid network preference against modem settings */
  if ( qcril_arb_ma_is_fusion() && net_pref_restored )
  {
    QCRIL_LOG_DEBUG( "%s\n", "Checking saved net pref vs modem" );
    /* Find out the mapping of specified network preference we should set on which modem. */
    if ( qcril_cm_validate_net_pref_vs_modem_capability( instance_id, net_pref, &u_info.cm.info.network_pref ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "%s\n", "Fail to check saved net pref vs modem" );
      return;
    }

    /* Match saved net pref vs modem setting */
    for ( modem_id = 0; modem_id < QCRIL_MAX_MODEM_ID; modem_id++ )
    {
      /* Don't care operating mode at this point */
      u_info.cm.info.network_pref.oprt_mode[ modem_id ] = SYS_OPRT_MODE_NONE;

      if ( ( u_info.cm.info.network_pref.mode_pref[ modem_id ] != CM_MODE_PREF_NONE ) || 
           ( u_info.cm.info.network_pref.acq_order_pref[ modem_id ] != CM_GW_ACQ_ORDER_PREF_NONE ) )
      {
        if ( ( u_info.cm.info.network_pref.mode_pref[ modem_id ] != i_ptr->ph_info[ modem_id ].mode_pref ) ||
             ( !( QCRIL_CM_NET_PREF_INDICATES_1XEVDO_ONLY(net_pref) ) &&
               ( u_info.cm.info.network_pref.acq_order_pref[ modem_id ] != i_ptr->ph_info[ modem_id ].gw_acq_order_pref ) ) )
        {
          net_pref_changed = TRUE;
        }
        else
        {
          u_info.cm.info.network_pref.mode_pref[ modem_id ] = CM_MODE_PREF_NONE;
          u_info.cm.info.network_pref.acq_order_pref[ modem_id ] = CM_GW_ACQ_ORDER_PREF_NONE;
        }
      }
    }

    if ( !net_pref_changed )
    {
      QCRIL_LOG_DEBUG( "%s\n", "No change in net pref" );
      return;
    }
  }

  /* User did not select network preference before */
  QCRIL_LOG_DEBUG( "%s\n", "Sync network preference from modem" );

  /* Lookup modem ids based on the underlyig architecture */
  qcril_arb_query_arch_modem_id( &cdma_modem_id, &evdo_modem_id, &gwl_modem_id );

  /* Deduce the network preference based on modem(s)' setting */
  switch ( ma )
  {   
    #ifdef FEATURE_QCRIL_FUSION
    /* Third party, split modem*/
    case QCRIL_ARB_MA_FUSION_TPS: 
      if ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_HDR_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_LTE_CDMA_EVDO;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_CDMA_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_HDR_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_EVDO_ONLY;
        valid_net_pref = TRUE;
      }
      break;

    /* Split modem QC Solution */
    case QCRIL_ARB_MA_FUSION_QCS:
      if ( ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_ONLY ) &&
           ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_HDR_LTE_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_LTE_CDMA_EVDO;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GWL ) )
      {
        net_pref = QCRIL_CM_NET_PREF_LTE_GSM_WCDMA;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_HDR_ONLY ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_DIGITAL_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_LTE_CDMA_EVDO_GSM_WCDMA;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_LTE_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_LTE_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_ONLY ) &&
                ( i_ptr->ph_info[ evdo_modem_id ].mode_pref == CM_MODE_PREF_HDR_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_CDMA_EVDO;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_CDMA_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ evdo_modem_id ].mode_pref == CM_MODE_PREF_HDR_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_EVDO_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].gw_acq_order_pref == CM_GW_ACQ_ORDER_PREF_WCDMA_GSM ) )
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_WCDMA_PREFERRED;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].gw_acq_order_pref == CM_GW_ACQ_ORDER_PREF_AUTOMATIC ) )
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_WCDMA_AUTO;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GSM_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_WCDMA_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_WCDMA_ONLY;
        valid_net_pref = TRUE;
      }
      break;
    #endif /* FEATURE_QCRIL_FUSION */

    /* Single modem */
    case QCRIL_ARB_MA_MULTIMODE:
    case QCRIL_ARB_MA_DSDS:
      if ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_DIGITAL_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_WCDMA_CDMA_EVDO;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_HDR_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_CDMA_EVDO;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_ONLY )
      {
        net_pref = QCRIL_CM_NET_PREF_CDMA_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ evdo_modem_id ].mode_pref == CM_MODE_PREF_HDR_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_EVDO_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].gw_acq_order_pref == CM_GW_ACQ_ORDER_PREF_WCDMA_GSM ) )
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_WCDMA_PREFERRED;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].gw_acq_order_pref == CM_GW_ACQ_ORDER_PREF_AUTOMATIC ) )
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_WCDMA_AUTO;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GSM_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_WCDMA_ONLY )
      {
        net_pref = QCRIL_CM_NET_PREF_WCDMA_ONLY;
        valid_net_pref = TRUE;
      }
      break;

    default:
      break;
  }

  if ( valid_net_pref )
  {
    /* Store network preference */
    qcril_arb_store_net_pref( instance_id, net_pref );
    return;
  }

  /* Valid network preference against modem settings */
  if ( !valid_net_pref )
  {
    QCRIL_LOG_DEBUG( "%s\n", "Saved net pref mismatch modem setting, change modem setting per saved net pref" );

    #ifdef FEATURE_QCRIL_DSDS
    /* Lookup as_id */
    if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
    {
      return;
    }
    #endif /* FEATURE_QCRIL_DSDS */

    /* net_pref out of sync, need to config modem setting per saved net pref */
    for ( modem_id = 0; modem_id < QCRIL_MAX_MODEM_ID; modem_id++ )
    {
      if ( ( u_info.cm.info.network_pref.mode_pref[ modem_id ] != CM_MODE_PREF_NONE ) || 
           ( u_info.cm.info.network_pref.acq_order_pref[ modem_id ] != CM_GW_ACQ_ORDER_PREF_NONE ) )
      {
        user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_REQ_ID_INTERNAL );

        /* Command CM to change the phone's system selection preference on network type */
        QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, mode pref %d, acq order pref %d", 
                        qcril_log_get_token_id( (RIL_Token) QCRIL_TOKEN_ID_INTERNAL ), 
                        u_info.cm.info.network_pref.mode_pref[ modem_id ], 
                        u_info.cm.info.network_pref.acq_order_pref[ modem_id ] );

        QCRIL_LOG_RPC2( modem_id, cm_ph_cmd_sys_sel_pref_api_name, details );
        (void) qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_sys_sel_pref_func( qcril_cm_phonesvc_command_callback,
                                                                           (void *) user_data,
                                                                           i_ptr->client_info[ modem_id ].client_id,
                                                                           #ifdef FEATURE_QCRIL_DSDS
                                                                           as_id,
                                                                           #endif /* FEATURE_QCRIL_DSDS */
                                                                           u_info.cm.info.network_pref.mode_pref[ modem_id ],
                                                                           CM_PREF_TERM_PERMANENT,
                                                                           0,
                                                                           u_info.cm.info.network_pref.acq_order_pref[ modem_id ],
                                                                           CM_BAND_PREF_NO_CHANGE,
                                                                           CM_PRL_PREF_NO_CHANGE,
                                                                           CM_ROAM_PREF_NO_CHANGE,
                                                                           CM_HYBR_PREF_NO_CHANGE,
                                                                           CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                                           CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                                                           NULL 
                                                                           #ifndef FEATURE_QCRIL_DSDS
                                                                           , NULL
                                                                           #endif /* !FEATURE_QCRIL_DSDS */
                                                                         );
      }
    }
  }

} /* qcril_cm_sync_network_preference */


/*=========================================================================
  FUNCTION:  qcril_cm_sync_network_preference_and_oprt_mode

===========================================================================*/
/*!
    @brief
    Command modem change tio LPM with subscription disabled. Request an
    update on network state .

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_sync_network_preference_and_oprt_mode
(
  qcril_instance_id_e_type instance_id
)
{
  qcril_modem_id_e_type cdma_modem_id, evdo_modem_id, gwl_modem_id;
  boolean net_pref_restored, valid_net_pref = FALSE;
  qcril_cm_net_pref_e_type net_pref;
  qcril_arb_ma_e_type ma;
  qcril_cm_struct_type *i_ptr;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  /* Query stored network preference */
  qcril_arb_query_net_pref( instance_id, &net_pref_restored, &net_pref, &ma );

  QCRIL_LOG_DEBUG( "%s\n", "Sync network preference from modem" );

  /* Lookup modem ids based on the underlyig architecture */
  qcril_arb_query_arch_modem_id( &cdma_modem_id, &evdo_modem_id, &gwl_modem_id );

  /* Deduce the network preference based on modem(s)' setting */
  switch ( ma )
  {   
    #ifdef FEATURE_QCRIL_FUSION
    /* Third party, split modem*/
    case QCRIL_ARB_MA_FUSION_TPS: 
      if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
           ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_HDR_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_LTE_CDMA_EVDO;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_CDMA_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_HDR_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_EVDO_ONLY;
        valid_net_pref = TRUE;
      }
      break;

    /* Split modem QC Solution */
    case QCRIL_ARB_MA_FUSION_QCS:
      if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
           ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_ONLY ) &&
           ( i_ptr->ph_info[ gwl_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
           ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_HDR_LTE_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_LTE_CDMA_EVDO;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_LPM ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GWL ) )
      {
        net_pref = QCRIL_CM_NET_PREF_LTE_GSM_WCDMA;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_HDR_ONLY ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_DIGITAL_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_LTE_CDMA_EVDO_GSM_WCDMA;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_LPM ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_LTE_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_LTE_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_ONLY ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ evdo_modem_id ].mode_pref == CM_MODE_PREF_HDR_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_CDMA_EVDO;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_ONLY ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].oprt_mode == SYS_OPRT_MODE_LPM ) )
      {
        net_pref = QCRIL_CM_NET_PREF_CDMA_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_LPM ) &&
                ( i_ptr->ph_info[ evdo_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ evdo_modem_id ].mode_pref == CM_MODE_PREF_HDR_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_EVDO_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_LPM ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].gw_acq_order_pref == CM_GW_ACQ_ORDER_PREF_WCDMA_GSM ) )
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_WCDMA_PREFERRED;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_LPM ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].gw_acq_order_pref == CM_GW_ACQ_ORDER_PREF_AUTOMATIC ) )
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_WCDMA_AUTO;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_LPM ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GSM_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ cdma_modem_id ].oprt_mode == SYS_OPRT_MODE_LPM ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_WCDMA_ONLY ) )
      {
        net_pref = QCRIL_CM_NET_PREF_WCDMA_ONLY;
        valid_net_pref = TRUE;
      }
      break;
    #endif /* FEATURE_QCRIL_FUSION */

    /* Single modem */
    case QCRIL_ARB_MA_MULTIMODE:
    case QCRIL_ARB_MA_DSDS:
      if ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_DIGITAL_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_WCDMA_CDMA_EVDO;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_HDR_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_CDMA_EVDO;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ cdma_modem_id ].mode_pref == CM_MODE_PREF_CDMA_ONLY )
      {
        net_pref = QCRIL_CM_NET_PREF_CDMA_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ evdo_modem_id ].mode_pref == CM_MODE_PREF_HDR_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_EVDO_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].gw_acq_order_pref == CM_GW_ACQ_ORDER_PREF_WCDMA_GSM ) )
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_WCDMA_PREFERRED;
        valid_net_pref = TRUE;
      }
      else if ( ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GSM_WCDMA_ONLY ) &&
                ( i_ptr->ph_info[ gwl_modem_id ].gw_acq_order_pref == CM_GW_ACQ_ORDER_PREF_AUTOMATIC ) )
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_WCDMA_AUTO;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_GSM_ONLY ) 
      {
        net_pref = QCRIL_CM_NET_PREF_GSM_ONLY;
        valid_net_pref = TRUE;
      }
      else if ( i_ptr->ph_info[ gwl_modem_id ].mode_pref == CM_MODE_PREF_WCDMA_ONLY )
      {
        net_pref = QCRIL_CM_NET_PREF_WCDMA_ONLY;
        valid_net_pref = TRUE;
      }
      break;

    default:
      break;
  }

  if ( valid_net_pref )
  {
    /* Store network preference */
    qcril_arb_store_net_pref( instance_id, net_pref );
  }
  else
  {
    QCRIL_LOG_DEBUG( "Unknown net pref, use stored netpref %d\n", net_pref );
  }

} /* qcril_cm_sync_network_preference_and_oprt_mode */


/*=========================================================================
  FUNCTION:  qcril_cm_sync_modem_state

===========================================================================*/
/*!
    @brief
    Command modem change tio LPM with subscription disabled. Request an
    update on network state .

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_sync_modem_state
(
  qcril_instance_id_e_type instance_id
)
{
  qcril_cm_struct_type *i_ptr;
  uint8 i;
  uint32 user_data;

  #ifdef FEATURE_QCRIL_SUBS_CTRL
  uint16 subscription_disable_mask = QCRIL_MODE_GW_CONFIG_MASK | QCRIL_MODE_1XEVDO_CONFIG_MASK; 
  #endif /* FEATURE_QCRIL_SUBS_CTRL */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "%s\n", "Sync modem state" );

  for ( i = 0; i < QCRIL_ARB_MAX_MODEMS; i++ )
  {

    if( !qcril_arb_ma_is_dsds() )
    {
      /* Command CM to change to LPM */
      if ( i_ptr->ph_info[ i ].oprt_mode != SYS_OPRT_MODE_LPM )
      {
        user_data = QCRIL_COMPOSE_USER_DATA( instance_id, i, QCRIL_REQ_ID_INTERNAL );
        QCRIL_LOG_RPC2A( i, "cm_ph_cmd_oprt_mode()", "LPM" );
        (void) qcril_cm_api_funcs[ i ].cm_ph_cmd_oprt_mode_func( qcril_cm_phonesvc_command_callback,
                                                                 (void *) user_data,
                                                                 i_ptr->client_info[ i ].client_id,
                                                                 SYS_OPRT_MODE_LPM );
      }
    }

    #ifdef FEATURE_QCRIL_SUBS_CTRL
    /* Command CM to disable all subscription */
    if ( i_ptr->ph_info[ i ].pri_gw_subscription_state == QCRIL_CM_SUBSCRIPTION_ENABLED )
    {
      QCRIL_LOG_RPC2A( i, "cm_ph_cmd_subscription_not_available()", "GW" );
      (void) qcril_cm_api_funcs[ i ].cm_ph_cmd_subscription_not_available_func( qcril_cm_phonesvc_command_callback, 
                                                                                (void *) &subscription_disable_mask, 
                                                                                i_ptr->client_info[ i ].client_id,
                                                                                CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                                                                CM_SUBSCRIPTION_STATUS_CHANGE,
                                                                                CM_SUBSCRIPTION_STATUS_NO_CHANGE );
    }

    if ( i_ptr->ph_info[ i ].pri_cdma_subscription_state == QCRIL_CM_SUBSCRIPTION_ENABLED )
    {
      QCRIL_LOG_RPC2A( i, "cm_ph_cmd_subscription_not_available()", "1xEvDo" );
      (void) qcril_cm_api_funcs[ i ].cm_ph_cmd_subscription_not_available_func( qcril_cm_phonesvc_command_callback, 
                                                                                (void *) &subscription_disable_mask, 
                                                                                i_ptr->client_info[ i ].client_id,
                                                                                CM_SUBSCRIPTION_STATUS_CHANGE,
                                                                                CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                                                                CM_SUBSCRIPTION_STATUS_NO_CHANGE );
    }
    #endif /* FEATURE_QCRIL_SUBS_CTRL */

    if ( !qcril_arb_ma_is_dsds() )
    {
      /* Request update on network information */
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, i, QCRIL_REQ_ID_INTERNAL );
      QCRIL_LOG_RPC( i, "cm_ss_cmd_get_ss_info()", "client_id", i_ptr->client_info[ i ].client_id );
      (void) qcril_cm_api_funcs[ i ].cm_ss_cmd_get_ss_info_func( qcril_cm_srvsys_command_callback, 
                                                                 (void *) user_data, 
                                                                 i_ptr->client_info[ i ].client_id );
    }
  }

} /* qcril_cm_sync_modem_state */


/*=========================================================================
  FUNCTION:  qcril_cm_screen_is_off

===========================================================================*/
/*!
    @brief
    Peek screen state to see whether it is currently on or off.

    @return
    True indicates screen off. 
    False indicates screen on.
*/
/*=========================================================================*/
boolean qcril_cm_screen_is_off
( 
  qcril_instance_id_e_type instance_id
)
{
  qcril_cm_struct_type *i_ptr;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ss_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

  if ( i_ptr->screen_state == QCRIL_CM_SCREEN_STATE_OFF )
  {
    QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );
    return TRUE;
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );

  return FALSE;

} /* qcril_cm_screen_is_off */


/*=========================================================================
  FUNCTION:  qcril_cm_fdn_check_is_passed

===========================================================================*/
/*!
    @brief
    Checks against pbm fdn list if fdn check is enabled .

    @return
    True when (fdn check is enabled and passed) or (fdn check is disabled),
    False otherwise.
*/
/*=========================================================================*/
boolean  qcril_cm_fdn_check_is_passed
(
  qcril_instance_id_e_type instance_id,
  qcril_modem_id_e_type modem_id,
  const char *num_buf,
  int num_len
)
{
  qcril_cm_struct_type *i_ptr;
  boolean is_fdn_check_enabled = FALSE;
  char details[ 40 ];

  #if defined(FEATURE_QCRIL_FUSION) || defined(FEATURE_QCRIL_DSDS)
  pbm_phonebook_type pb_id;
  char pbm_find_number_api_name[ 40 ]= "pbm_session_find_number()";
  #else
  char pbm_find_number_api_name[ 40 ]= "pbm_find_number()";
  #endif /* FEATURE_QCRIL_FUSION || FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].fdn_status_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->fdn_status_mutex, details );
  is_fdn_check_enabled = i_ptr->fdn_enabled;
  QCRIL_MUTEX_UNLOCK( &i_ptr->fdn_status_mutex, details );

  if ( is_fdn_check_enabled )
  {
    #ifdef FEATURE_QCRIL_FUSION
    /* Set PB ID */
    qcril_pbm_set_pb_id_for_svlte_1( instance_id, &pb_id, QCRIL_PBM_DEVICE_TYPE_FDN );
    #endif /* FEATURE_QCRIL_FUSION */

    #ifdef FEATURE_QCRIL_DSDS
    /* Set PB ID */
    if ( qcril_pbm_set_pb_id_from_subscription( instance_id, &pb_id, QCRIL_PBM_DEVICE_TYPE_FDN, TRUE ) != E_SUCCESS )
    {
      QCRIL_LOG_DEBUG( "RID %d MID %d Subscription info not available, ignore FDN\n", instance_id, modem_id );
      return FALSE;
    }
    #endif /* FEATURE_QCRIL_DSDS */

    /* Check the number against the FDN entries maintained in PhoneBookManager */
    QCRIL_LOG_RPC2A( instance_id, pbm_find_number_api_name, "Check against PBM FDN " );
    if ( PBM_SUCCESS != qcril_pbm_api_funcs[ modem_id ].pbm_find_number_func(
                                                                              #if defined(FEATURE_QCRIL_FUSION) || defined(FEATURE_QCRIL_DSDS)
                                                                              pb_id,
                                                                              #else
                                                                              PBM_FDN,
                                                                              #endif /* FEATURE_QCRIL_FUSION || FEATURE_QCRIL_DSDS */
                                                                              (byte *) num_buf, num_len, NULL, NULL ) )
    {
      QCRIL_LOG_DEBUG( "%s","FDN check enabled and Dialled string not found in FDN list" );
      return FALSE;
    }
  }

  return TRUE;

} /* qcril_cm_fdn_check_is_passed */


/*=========================================================================
  FUNCTION:  qcril_cm_get_modem_capability

===========================================================================*/
/*!
    @brief
    Query CM for the modem's mode and band capabilities 

    @return
    None
*/
/*=========================================================================*/
void qcril_cm_get_modem_capability
( 
  void
)
{
  uint8 i, j;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_1;
  char *cm_ph_cmd_get_ph_info_api_name = "cm_ph_cmd_get_ph_info_per_subs()";
  char *cm_ph_cmd_get_subs_pref_info_api_name = "cm_ph_cmd_get_subs_pref_info_per_subs()";
  #else
  char *cm_ph_cmd_get_ph_info_api_name = "cm_ph_cmd_get_ph_info()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  /* Request update on modem configuration */
  for ( i = 0; i < QCRIL_ARB_MAX_INSTANCES; i++ )
  {
    i_ptr = &qcril_cm[ i ];

    for ( j = 0; j < QCRIL_ARB_MAX_MODEMS; j++ )
    {
      if ( i_ptr->client_info[ j ].client_is_primary )
      {
        user_data = QCRIL_COMPOSE_USER_DATA( i, j, QCRIL_TOKEN_ID_INTERNAL );

        #ifdef FEATURE_QCRIL_DSDS
        /* For single standby, need to retrieve the default subscription info */
        if ( qcril_arb_ma_is_dsds() && QCRIL_PRIMARY_INSTANCE( i ) )
        {
          QCRIL_LOG_RPC( j, cm_ph_cmd_get_subs_pref_info_api_name, "client_id", i_ptr->client_info[ j ].client_id );
          (void) qcril_cm_api_funcs[ j ].cm_ph_cmd_get_subs_pref_info_func( qcril_cm_phonesvc_command_callback, 
                                                                            (void *) user_data, 
                                                                            i_ptr->client_info[ j ].client_id,
                                                                            as_id
                                                                          );
        }
        #endif /* FEATURE_QCRIL_DSDS */

        /* For multimode, phone info is valid now. For DSDS, common phone info is the same for both stacks */
        if ( !qcril_arb_ma_is_dsds() || QCRIL_PRIMARY_INSTANCE( i ) )
        {
          QCRIL_LOG_RPC( j, cm_ph_cmd_get_ph_info_api_name, "client_id", i_ptr->client_info[ j ].client_id );
          (void) qcril_cm_api_funcs[ j ].cm_ph_cmd_get_ph_info_func( qcril_cm_phonesvc_command_callback, 
                                                                     (void *) user_data, 
                                                                     i_ptr->client_info[ j ].client_id
                                                                     #ifdef FEATURE_QCRIL_DSDS
                                                                     , as_id
                                                                     #endif /* FEATURE_QCRIL_DSDS */
                                                                   );
        }
      }
    }
  }

} /* qcril_cm_get_modem_capability() */


/*=========================================================================
  FUNCTION:  qcril_cm_store_srv_sys_info

===========================================================================*/
/*!
    @brief
    Cache the serving system info and update indicators to report the
    RADIO_STATE_CHANGED and NETWORK_STATE_CHANGED.

    @return
    None
*/
/*=========================================================================*/
static void qcril_cm_store_srv_sys_info
( 
  qcril_instance_id_e_type instance_id,
  qcril_modem_id_e_type modem_id,
  const cm_mm_ss_info_s_type *ss_info_ptr,
  qcril_ssic_notification_status_e_type ssic_notification_status,
  boolean *voice_radio_tech_changed_ptr,
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type *new_voice_radio_tech_ptr,
  #else
  qcril_radio_tech_e_type        *new_voice_radio_tech_ptr,
  #endif
  qcril_ssic_notification_status_e_type *ssic_notification_status_ptr
)
{
  qcril_cm_struct_type *i_ptr;
  qcril_modem_id_e_type voice_modem_id;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  boolean ss_info_updated = FALSE;
  char details[ 40 ];

  #ifdef FEATURE_QCRIL_DSDS
  boolean gw_hybrid = FALSE;
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  qcril_sub_ids_list_type no_of_active_subs;
  sys_srv_status_e_type srv_status;
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ss_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    qcril_arb_query_active_subs_list( &no_of_active_subs );

    /* allow only in case there are no subscriptions and instance-id is primary,
       this is to make sure that serving system information is updated properly for allowing
       emergency calls on primary subscription */
      // update serving system info for both subs even if they are deactivated
      if ( instance_id == QCRIL_DEFAULT_INSTANCE_ID )
      {
          as_id = SYS_MODEM_AS_ID_1;
      }
      else
      {
          as_id = SYS_MODEM_AS_ID_2;
      }
  }
  #endif /* FEATURE_QCRIL_DSDS */

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ss_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

  #ifdef FEATURE_QCRIL_DSDS
  /* in case of DSDS, SYS_MODEM_AS_ID_2 always maps to hybrid stack,
      SYS_MODEM_AS_ID_1 always maps to main stack
  */
  if ( as_id == SYS_MODEM_AS_ID_2 )
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d maps to hybrid stack, using hybrid stack information",
                     instance_id, modem_id);
    QCRIL_LOG_DEBUG( "[SSINFO] Serving info received from CM for AS_ID 2... RID %d MID %d Serving System : srv status %d, sys mode %d, roam status %d, srv cap = %d, srv domain = %d, changed fields =%x",
                     instance_id, modem_id, ss_info_ptr->gw_srv_status, ss_info_ptr->gw_sys_mode,
                     ss_info_ptr->gw_roam_status, ss_info_ptr->gw_srv_capability, ss_info_ptr->gw_srv_domain, ss_info_ptr->hybr_gw_changed_fields);

QCRIL_LOG_DEBUG("[SSINFO] RID %d mode_pref [%d] is_main_operational [%d] is_hybr_gw_operational [%d] ", instance_id, i_ptr->ph_info[ modem_id ].mode_pref, ss_info_ptr->is_main_operational, ss_info_ptr->is_hybr_gw_operational);

    ss_info_updated = TRUE;
    gw_hybrid = TRUE;
    i_ptr->ss_info[ modem_id ].gw_hybrid = TRUE;

    /* in case of status information, store the information as it might have got changed
         when screen state is locked, dont update the changed fields, as it is not populated,
         properly */

    if( ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_REG_REJECT ) ||
        ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED ) )
    {
      i_ptr->ss_info[ modem_id ].changed_fields = ss_info_ptr->hybr_gw_changed_fields;
    }
 
    if( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_INFO )
    {
      /* Store serving system info */
      i_ptr->ss_info[ modem_id ].srv_status = ss_info_ptr->gw_srv_status;
      i_ptr->ss_info[ modem_id ].true_srv_status = ss_info_ptr->true_gw_srv_status;
      i_ptr->ss_info[ modem_id ].srv_domain = ss_info_ptr->gw_srv_domain;
      i_ptr->ss_info[ modem_id ].srv_capability = ss_info_ptr->gw_srv_capability;
      i_ptr->ss_info[ modem_id ].sys_mode = ss_info_ptr->gw_sys_mode;
      i_ptr->ss_info[ modem_id ].roam_status = ss_info_ptr->gw_roam_status;
      i_ptr->ss_info[ modem_id ].sys_id = ss_info_ptr->gw_sys_id;
      i_ptr->ss_info[ modem_id ].is_sys_prl_match = ss_info_ptr->gw_is_sys_prl_match;
      if ( QCRIL_CM_SYS_MODE_IS_GWL(i_ptr->ss_info[ modem_id ].sys_mode) )
      {
        i_ptr->ss_info[ modem_id ].mode_info = ss_info_ptr->gw_mode_info;
      }
      i_ptr->ss_info[ modem_id ].cell_srv_ind = ss_info_ptr->gw_cell_srv_ind;
      i_ptr->ss_info[ modem_id ].cell_info = ss_info_ptr->gw_cell_info;       
    }
 
    if ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED )
    {
      /* update serving system info only if the mask is set*/
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_GW_SRV_STATUS_MASK )
      {
         i_ptr->ss_info[ modem_id ].srv_status = ss_info_ptr->gw_srv_status;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_TRUE_GW_SRV_STATUS_MASK )
      {
         i_ptr->ss_info[ modem_id ].true_srv_status = ss_info_ptr->true_gw_srv_status;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_GW_SRV_DOMAIN_MASK )
      {
         i_ptr->ss_info[ modem_id ].srv_domain = ss_info_ptr->gw_srv_domain;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_GW_SRV_CAPABILITY_MASK )
      {
         i_ptr->ss_info[ modem_id ].srv_capability = ss_info_ptr->gw_srv_capability;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_GW_SYS_MODE_MASK )
      {
         i_ptr->ss_info[ modem_id ].sys_mode = ss_info_ptr->gw_sys_mode;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_GW_ROAM_STATUS_MASK )
      {
         i_ptr->ss_info[ modem_id ].roam_status = ss_info_ptr->gw_roam_status;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_GW_SYS_ID_MASK )
      {
         i_ptr->ss_info[ modem_id ].sys_id = ss_info_ptr->gw_sys_id;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_GW_SYS_PRL_MATCH_MASK )
      {
         i_ptr->ss_info[ modem_id ].is_sys_prl_match = ss_info_ptr->gw_is_sys_prl_match;
      }
      if ( QCRIL_CM_SYS_MODE_IS_GWL( i_ptr->ss_info[ modem_id ].sys_mode ) )
      {
        if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_GW_MOBILITY_MGMT_MASK )
        {
           i_ptr->ss_info[ modem_id ].mode_info.gw_info.mm_information = ss_info_ptr->gw_mode_info.gw_info.mm_information;
           i_ptr->ss_info[ modem_id ].mode_info.gw_info.bit_err_rate = ss_info_ptr->gw_mode_info.gw_info.bit_err_rate;
        }
        if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_GW_SIM_STATE_MASK )
        {
           i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state = ss_info_ptr->gw_mode_info.gw_info.sim_state;
        }
        if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_GW_SYS_FORBIDDEN_MASK )
        {
           i_ptr->ss_info[ modem_id ].mode_info.gw_info.plmn_forbidden = ss_info_ptr->gw_mode_info.gw_info.plmn_forbidden;
        }
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_GW_SRV_IND_MASK )
      {
         i_ptr->ss_info[ modem_id ].cell_srv_ind = ss_info_ptr->gw_cell_srv_ind;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_GW_CELL_INFO_MASK )
      {
         i_ptr->ss_info[ modem_id ].cell_info = ss_info_ptr->gw_cell_info;
      }
    }

    if ( (  ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_RSSI )  ||
          ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED ) )
    {
      /* Store signal strength info */
      i_ptr->ss_info[ modem_id ].rssi = ss_info_ptr->gw_rssi;
      i_ptr->ss_info[ modem_id ].ecio = ss_info_ptr->gw2_ecio;
      i_ptr->ss_info[ modem_id ].sinr = ss_info_ptr->gw_sinr;
    }
    // Handle srv status updation for emergency calls in coverage area.
    #ifdef FEATURE_QCRIL_DSDS
    if ( ss_info_ptr->is_hybr_gw_operational != TRUE )
    {
      QCRIL_LOG_DEBUG( "%s","[SSINFO] Hybrid Stack inactive!!" );
      srv_status = qcril_cm[QCRIL_DEFAULT_INSTANCE_ID].ss_info[modem_id].srv_status;
      if ( srv_status != SYS_SRV_STATUS_SRV )
      {
        QCRIL_LOG_DEBUG( "[SSINFO] No/Limited Coverage!! Mark srv status of instance %d as %d", instance_id, srv_status );
        i_ptr->ss_info[ modem_id ].srv_status = srv_status;
      }
      else
      {
        QCRIL_LOG_DEBUG( "[SSINFO] Main Stack in service. Mark srv status of instance %d as %d", instance_id, SYS_SRV_STATUS_LIMITED );
        i_ptr->ss_info[ modem_id ].srv_status = SYS_SRV_STATUS_LIMITED;
      }
      i_ptr->ss_info[ modem_id ].changed_fields = qcril_cm[QCRIL_DEFAULT_INSTANCE_ID].ss_info[modem_id].changed_fields;
      i_ptr->ss_info[ modem_id ].sys_mode = qcril_cm[QCRIL_DEFAULT_INSTANCE_ID].ss_info[modem_id].sys_mode;
      i_ptr->ss_info[ modem_id ].srv_capability = qcril_cm[QCRIL_DEFAULT_INSTANCE_ID].ss_info[modem_id].srv_capability;
    }
    else if ( ( i_ptr->ss_info[ modem_id ].srv_status == SYS_SRV_STATUS_PWR_SAVE ) && ( ss_info_ptr->is_main_operational == TRUE ) )
    {
      srv_status = qcril_cm[QCRIL_DEFAULT_INSTANCE_ID].ss_info[modem_id].srv_status;

      QCRIL_LOG_DEBUG( "[SSINFO] SUB2 is POWER SAVE! Main Stack Srv Status: %d", srv_status );

      if (( srv_status == SYS_SRV_STATUS_SRV ) || ( srv_status == SYS_SRV_STATUS_LIMITED ) || (srv_status == SYS_SRV_STATUS_LIMITED_REGIONAL ) )
      {
        QCRIL_LOG_DEBUG("[SSINFO] In Coverage area: Dual Standby with SUB2 as POWER SAVE! instance %d as %d",instance_id,SYS_SRV_STATUS_LIMITED,0);
        i_ptr->ss_info[ modem_id ].srv_status = SYS_SRV_STATUS_LIMITED;
        i_ptr->ss_info[ modem_id ].changed_fields = qcril_cm[QCRIL_DEFAULT_INSTANCE_ID].ss_info[modem_id].changed_fields;
        i_ptr->ss_info[ modem_id ].sys_mode = qcril_cm[QCRIL_DEFAULT_INSTANCE_ID].ss_info[modem_id].sys_mode;
        i_ptr->ss_info[ modem_id ].srv_capability = qcril_cm[QCRIL_DEFAULT_INSTANCE_ID].ss_info[modem_id].srv_capability;
      }
    }
    #endif /* FEATURE_QCRIL_DSDS */
    QCRIL_LOG_DEBUG( " [SSINFO]  Serving info updated in cache... RID %d MID %d Serving System : srv status %d, sys mode %d, roam status %d, srv cap = %d, srv domain = %d, changed fields =%x\n",
                     instance_id, modem_id, i_ptr->ss_info[ modem_id ].srv_status, i_ptr->ss_info[ modem_id ].sys_mode,
                     i_ptr->ss_info[ modem_id ].roam_status, i_ptr->ss_info[ modem_id ].srv_capability, i_ptr->ss_info[ modem_id ].srv_domain, i_ptr->ss_info[ modem_id ].changed_fields);

  }
  else if ( as_id == SYS_MODEM_AS_ID_1 )
  #endif /* FEATURE_QCRIL_DSDS */
  {
    QCRIL_LOG_DEBUG( " [SSINFO]  Serving info received from CM for AS_ID 1... RID %d MID %d Serving System : srv status %d, sys mode %d, roam status %d, IDM %d, hdr_hybrid %d, hdr srv status %d, hdr roam status %d, srv cap = %d, changed fields =%d\n",
                     instance_id, modem_id, ss_info_ptr->srv_status, ss_info_ptr->sys_mode, ss_info_ptr->roam_status, ss_info_ptr->cur_idle_digital_mode,
                     ss_info_ptr->hdr_hybrid, ss_info_ptr->hdr_srv_status, ss_info_ptr->hdr_roam_status, ss_info_ptr->srv_capability, ss_info_ptr->changed_fields);

QCRIL_LOG_DEBUG("[SSINFO] RID %d mode_pref [%d] is_main_operational [%d] is_hybr_gw_operational [%d] ", instance_id, i_ptr->ph_info[ modem_id ].mode_pref, ss_info_ptr->is_main_operational, ss_info_ptr->is_hybr_gw_operational);

    ss_info_updated = TRUE;
    /* in case of status information, store the information as it might have got changed
         when screen state is locked, dont update the changed fields, as it is might not be
         populated properly */

    if( ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_REG_REJECT ) ||
        ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED ) )
    {
      i_ptr->ss_info[ modem_id ].changed_fields = ss_info_ptr->changed_fields;
    }

    if( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_INFO )
    {
      /* Store serving system info */
      i_ptr->ss_info[ modem_id ].srv_status = ss_info_ptr->srv_status;;
      i_ptr->ss_info[ modem_id ].true_srv_status = ss_info_ptr->true_srv_status;
      i_ptr->ss_info[ modem_id ].srv_domain = ss_info_ptr->srv_domain;
      i_ptr->ss_info[ modem_id ].srv_capability = ss_info_ptr->srv_capability;
      i_ptr->ss_info[ modem_id ].sys_mode = ss_info_ptr->sys_mode;
      i_ptr->ss_info[ modem_id ].roam_status = ss_info_ptr->roam_status;
      i_ptr->ss_info[ modem_id ].sys_id = ss_info_ptr->sys_id;
      i_ptr->ss_info[ modem_id ].is_sys_prl_match = ss_info_ptr->is_sys_prl_match;
      i_ptr->ss_info[ modem_id ].cur_idle_digital_mode = ss_info_ptr->cur_idle_digital_mode;
      i_ptr->ss_info[ modem_id ].hdr_hybrid = ss_info_ptr->hdr_hybrid;
      i_ptr->ss_info[ modem_id ].hdr_srv_status = ss_info_ptr->hdr_srv_status;
      i_ptr->ss_info[ modem_id ].hdr_roam_status = ss_info_ptr->hdr_roam_status;
      i_ptr->ss_info[ modem_id ].hdr_rssi = ss_info_ptr->hdr_rssi;
      i_ptr->ss_info[ modem_id ].hdr_ecio = ss_info_ptr->hdr_ecio;
      i_ptr->ss_info[ modem_id ].hdr_sinr = ss_info_ptr->hdr_sinr;
      if ( QCRIL_CM_SYS_MODE_IS_GWL( i_ptr->ss_info[ modem_id ].sys_mode ) )
      {
        i_ptr->ss_info[ modem_id ].mode_info.gw_info = ss_info_ptr->mode_info.gw_info;
      }
      else if ( QCRIL_CM_SYS_MODE_IS_1XEVDO ( i_ptr->ss_info[ modem_id ].sys_mode ) )
      {
        i_ptr->ss_info[ modem_id ].mode_info.cdma_info = ss_info_ptr->mode_info.cdma_info;
      }
      i_ptr->ss_info[ modem_id ].hdr_active_prot = ss_info_ptr->hdr_active_prot;
      i_ptr->ss_info[ modem_id ].cell_srv_ind = ss_info_ptr->cell_srv_ind;
      i_ptr->ss_info[ modem_id ].cell_info = ss_info_ptr->cell_info;
      i_ptr->ss_info[ modem_id ].def_roam_ind = ss_info_ptr->def_roam_ind;
      i_ptr->ss_info[ modem_id ].is_sys_prl_match = ss_info_ptr->is_sys_prl_match;
      #ifdef FEATURE_QCRIL_EHRPD
      i_ptr->ss_info[ modem_id ].hdr_personality = ss_info_ptr->hdr_personality;
      #endif /*FEATURE_QCRIL_EHRPD*/
      #ifdef FEATURE_QCRIL_LTE
      i_ptr->ss_info[ modem_id ].tac = ss_info_ptr->tac;
      #endif /* FEATURE_QCRIL_LTE */
    }

    if ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED )
    {
      /* update serving system info only if the mask is set*/
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_SRV_STATUS_MASK )
      {
         i_ptr->ss_info[ modem_id ].srv_status = ss_info_ptr->srv_status;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_TRUE_SRV_STATUS_MASK )
      {
         i_ptr->ss_info[ modem_id ].true_srv_status = ss_info_ptr->true_srv_status;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_SRV_DOMAIN_MASK )
      {
         i_ptr->ss_info[ modem_id ].srv_domain = ss_info_ptr->srv_domain;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_SRV_CAPABILITY_MASK )
      {
         i_ptr->ss_info[ modem_id ].srv_capability = ss_info_ptr->srv_capability;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_SYS_MODE_MASK )
      {
         i_ptr->ss_info[ modem_id ].sys_mode = ss_info_ptr->sys_mode;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_ROAM_STATUS_MASK )
      {
         i_ptr->ss_info[ modem_id ].roam_status = ss_info_ptr->roam_status;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_SYS_ID_MASK )
      {
         i_ptr->ss_info[ modem_id ].sys_id = ss_info_ptr->sys_id;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_SYS_PRL_MATCH_MASK )
      {
         i_ptr->ss_info[ modem_id ].is_sys_prl_match = ss_info_ptr->is_sys_prl_match;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_IDLE_DIGITAL_MODE_MASK )
      {
         i_ptr->ss_info[ modem_id ].cur_idle_digital_mode = ss_info_ptr->cur_idle_digital_mode;
      }
      i_ptr->ss_info[ modem_id ].hdr_hybrid = ss_info_ptr->hdr_hybrid;
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_HDR_SRV_STATUS_MASK )
      {
         i_ptr->ss_info[ modem_id ].hdr_srv_status = ss_info_ptr->hdr_srv_status;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_HDR_ROAM_STATUS_MASK )
      {
         i_ptr->ss_info[ modem_id ].hdr_roam_status = ss_info_ptr->hdr_roam_status;
      }
      i_ptr->ss_info[ modem_id ].hdr_rssi = ss_info_ptr->hdr_rssi;
      i_ptr->ss_info[ modem_id ].hdr_ecio = ss_info_ptr->hdr_ecio;
      i_ptr->ss_info[ modem_id ].hdr_sinr = ss_info_ptr->hdr_sinr;

      if ( QCRIL_CM_SYS_MODE_IS_GWL(i_ptr->ss_info[ modem_id ].sys_mode) )
      {
        /* storing GW information */
        if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_MOBILITY_MGMT_MASK )
        {
           i_ptr->ss_info[ modem_id ].mode_info.gw_info.mm_information = ss_info_ptr->mode_info.gw_info.mm_information;
           i_ptr->ss_info[ modem_id ].mode_info.gw_info.bit_err_rate = ss_info_ptr->mode_info.gw_info.bit_err_rate;
        }
        if (i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_SIM_STATE_MASK)
        {
           i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state = ss_info_ptr->mode_info.gw_info.sim_state;
        }
        if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_SYS_FORBIDDEN_MASK )
        {
           i_ptr->ss_info[ modem_id ].mode_info.gw_info.plmn_forbidden = ss_info_ptr->mode_info.gw_info.plmn_forbidden;
        }
      }
      else if ( QCRIL_CM_SYS_MODE_IS_1XEVDO ( i_ptr->ss_info[ modem_id ].sys_mode ) )
      {
        /* storing CDMA information */
        i_ptr->ss_info[modem_id].mode_info.cdma_info.ccs_supported = ss_info_ptr->mode_info.cdma_info.ccs_supported;
  
        if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_BS_P_REV_MASK )
        {
           i_ptr->ss_info[ modem_id ].mode_info.cdma_info.bs_p_rev = ss_info_ptr->mode_info.cdma_info.bs_p_rev;
        }
        if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_BASE_STATION_PARMS_CHGD_MASK )
        {
           i_ptr->ss_info[ modem_id ].mode_info.cdma_info.srch_win_n = ss_info_ptr->mode_info.cdma_info.srch_win_n;
           i_ptr->ss_info[ modem_id ].mode_info.cdma_info.base_lat = ss_info_ptr->mode_info.cdma_info.base_lat;
           i_ptr->ss_info[ modem_id ].mode_info.cdma_info.base_long = ss_info_ptr->mode_info.cdma_info.base_long;
           i_ptr->ss_info[ modem_id ].mode_info.cdma_info.base_id = ss_info_ptr->mode_info.cdma_info.base_id;
        }
        if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_CDMA_TIME_CHGD_MASK )
        {
           i_ptr->ss_info[ modem_id ].mode_info.cdma_info.time_info = ss_info_ptr->mode_info.cdma_info.time_info;
        }
      }

      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_HDR_ACTIVE_PROT_MASK )
      {
         i_ptr->ss_info[ modem_id ].hdr_active_prot = ss_info_ptr->hdr_active_prot;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_SRV_IND_MASK )
      {
         i_ptr->ss_info[ modem_id ].cell_srv_ind = ss_info_ptr->cell_srv_ind;
      }
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_CELL_INFO_MASK )
      {
         i_ptr->ss_info[ modem_id ].cell_info = ss_info_ptr->cell_info;
      }
      i_ptr->ss_info[ modem_id ].def_roam_ind = ss_info_ptr->def_roam_ind;
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_SYS_PRL_MATCH_MASK )
      {
         i_ptr->ss_info[ modem_id ].is_sys_prl_match = ss_info_ptr->is_sys_prl_match;;
      }
      #ifdef FEATURE_QCRIL_EHRPD 
      if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_HDR_PERSONALITY_MASK )
      {
         i_ptr->ss_info[ modem_id ].hdr_personality = ss_info_ptr->hdr_personality;
      }
      #endif /*FEATURE_QCRIL_EHRPD*/

      #ifdef FEATURE_QCRIL_LTE
      i_ptr->ss_info[ modem_id ].tac = ss_info_ptr->tac;
      #endif /* FEATURE_QCRIL_LTE */
    }

    if ( ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_RSSI )  ||
         ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED ) )
    {
      /* Store signal strength info */
      i_ptr->ss_info[ modem_id ].rssi = ss_info_ptr->rssi;
      i_ptr->ss_info[ modem_id ].ecio = ss_info_ptr->ecio;
      i_ptr->ss_info[ modem_id ].sinr = ss_info_ptr->sinr;
      i_ptr->ss_info[ modem_id ].hdr_rssi = ss_info_ptr->hdr_rssi;
      i_ptr->ss_info[ modem_id ].hdr_ecio = ss_info_ptr->hdr_ecio;
      i_ptr->ss_info[ modem_id ].hdr_sinr = ss_info_ptr->hdr_sinr;
      #ifdef FEATURE_QCRIL_LTE
      i_ptr->ss_info[ modem_id ].rsrp = ss_info_ptr->rsrp;
      i_ptr->ss_info[ modem_id ].rsrq = ss_info_ptr->rsrq;
      i_ptr->ss_info[ modem_id ].sinr = ss_info_ptr->sinr;
      #endif /* FEATURE_QCRIL_LTE */
    }
    // Handle srv status updation for emergency calls in coverage area.
    #ifdef FEATURE_QCRIL_DSDS
    if ( ( ss_info_ptr->is_main_operational != TRUE ) && ( ss_info_ptr->is_hybr_gw_operational == TRUE ) )
      {
        QCRIL_LOG_DEBUG( "%s","[SSINFO] Main Stack Inactive!!" );
        srv_status = qcril_cm[QCRIL_SECOND_INSTANCE_ID].ss_info[modem_id].srv_status;
        if ( srv_status != SYS_SRV_STATUS_SRV )
        {
          QCRIL_LOG_DEBUG( "[SSINFO] No/Limited Coverage!! Mark srv status of instance %d as %d", instance_id, srv_status );
          i_ptr->ss_info[ modem_id ].srv_status = srv_status;
        }
        else
        {
          QCRIL_LOG_DEBUG( "[SSINFO] Hybrid stack in service. Mark srv status of instance %d as %d", instance_id, SYS_SRV_STATUS_LIMITED );
          i_ptr->ss_info[ modem_id ].srv_status = SYS_SRV_STATUS_LIMITED;
        }
        i_ptr->ss_info[ modem_id ].changed_fields = qcril_cm[QCRIL_SECOND_INSTANCE_ID].ss_info[modem_id].changed_fields;
        i_ptr->ss_info[ modem_id ].sys_mode = qcril_cm[QCRIL_SECOND_INSTANCE_ID].ss_info[modem_id].sys_mode;
        i_ptr->ss_info[ modem_id ].srv_capability = qcril_cm[QCRIL_SECOND_INSTANCE_ID].ss_info[modem_id].srv_capability;
      }
      else if ( ( i_ptr->ss_info[ modem_id ].srv_status == SYS_SRV_STATUS_PWR_SAVE ) && ( ss_info_ptr->is_hybr_gw_operational == TRUE ) )
      {
        srv_status = qcril_cm[QCRIL_SECOND_INSTANCE_ID].ss_info[modem_id].srv_status;
        QCRIL_LOG_DEBUG("[SSINFO] SUB1 is Power Save! Hybrid stack srv status [%d].", srv_status );
        if ( ( srv_status == SYS_SRV_STATUS_SRV ) || ( srv_status == SYS_SRV_STATUS_LIMITED ) || (srv_status == SYS_SRV_STATUS_LIMITED_REGIONAL ) )
        {
          QCRIL_LOG_DEBUG("[SSINFO] In Coverage area: Dual Standby with SUB1 as POWER SAVE! instance %d as %d",instance_id,SYS_SRV_STATUS_LIMITED);
          i_ptr->ss_info[ modem_id ].srv_status = SYS_SRV_STATUS_LIMITED;
          i_ptr->ss_info[ modem_id ].changed_fields = qcril_cm[QCRIL_SECOND_INSTANCE_ID].ss_info[modem_id].changed_fields;
          i_ptr->ss_info[ modem_id ].sys_mode = qcril_cm[QCRIL_SECOND_INSTANCE_ID].ss_info[modem_id].sys_mode;
          i_ptr->ss_info[ modem_id ].srv_capability = qcril_cm[QCRIL_SECOND_INSTANCE_ID].ss_info[modem_id].srv_capability;
        }
      }
    QCRIL_LOG_DEBUG( " [SSINFO]  Serving info updated in cache... RID %d MID %d Serving System : srv status %d, sys mode %d, roam status %d, srv cap = %d, srv domain = %d, changed fields =%x\n",
                     instance_id, modem_id, i_ptr->ss_info[ modem_id ].srv_status, i_ptr->ss_info[ modem_id ].sys_mode, 
                     i_ptr->ss_info[ modem_id ].roam_status, i_ptr->ss_info[ modem_id ].srv_capability, i_ptr->ss_info[ modem_id ].srv_domain, i_ptr->ss_info[ modem_id ].changed_fields);
    #endif /* FEATURE_QCRIL_DSDS */
  }

  if ( ss_info_updated  )
  {
    /* Always store ONS info if CM_SS_EVENT_INFO */
    if ( ( ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_INFO ) &&
           ( QCRIL_CM_SYS_MODE_IS_GWL( i_ptr->ss_info[ modem_id ].sys_mode ) ) &&
           ( i_ptr->ss_info[ modem_id ].mode_info.gw_info.mm_information.plmn_avail ) ) ||
         ( i_ptr->ss_info[ modem_id ].changed_fields & QCRIL_CM_SS_MOBILITY_MGMT_MASK( gw_hybrid ) ) )
    {
      /* Store NITZ's ONS info */
      qcril_cm_ons_store_nitz( instance_id, ( const qcril_cm_ss_info_type * ) &i_ptr->ss_info[ modem_id ] );
    }

    /* Managed roaming */
    if ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED )
    {
      if ( ( i_ptr->ss_info[ modem_id ].changed_fields & QCRIL_CM_SS_TRUE_SRV_STATUS_MASK( gw_hybrid ) ) &&
            ( i_ptr->ss_info[ modem_id ].true_srv_status == SYS_SRV_STATUS_LIMITED ) &&
            ( i_ptr->ph_info[ modem_id ].network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL ) )
      {

        i_ptr->reg_reject_info.managed_roaming_enabled = qcril_other_read_managed_roaming_from_nv(instance_id, modem_id );

        QCRIL_LOG_DEBUG( "CM_SS_TRUE_SRV_STATUS_MASK is set, true_srv_status = %d, mgr = %d\n",
                         i_ptr->ss_info[ modem_id ].true_srv_status, i_ptr->reg_reject_info.managed_roaming_enabled);
      }
    }

    /* Registration rejected */
    if ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_REG_REJECT )
    {
      /* storing the received registration reject information to the global variable as
      the registration reject information will be reset in the next serving status event */

      QCRIL_LOG_DEBUG( "RID %d MID %d reg reject received, rej_domain = %d, rej_cause = %d",
                       instance_id, modem_id, ss_info_ptr->reg_reject_info.reject_srv_domain, 
                       ss_info_ptr->reg_reject_info.reject_cause );

      #ifdef FEATURE_QCRIL_DSDS
      if ( ( as_id == SYS_MODEM_AS_ID_2 ) && ss_info_ptr->is_hybr_gw_operational ) 
      {
        if ( ( ss_info_ptr->gw_reg_reject_info.reject_srv_domain == SYS_SRV_DOMAIN_CS_ONLY ) ||
             ( ss_info_ptr->gw_reg_reject_info.reject_srv_domain == SYS_SRV_DOMAIN_CS_PS ) ||
             ( ss_info_ptr->gw_reg_reject_info.reject_srv_domain == SYS_SRV_DOMAIN_PS_ONLY))
        {
          i_ptr->reg_reject_info.cm_reg_reject_info = ss_info_ptr->gw_reg_reject_info;
          i_ptr->reg_reject_info.reg_reject_reported = FALSE;
        }      
      }
      else
      #endif /* FEATURE_QCRIL_DSDS */
      {
        if ( ( ss_info_ptr->reg_reject_info.reject_srv_domain == SYS_SRV_DOMAIN_CS_ONLY ) ||
             ( ss_info_ptr->reg_reject_info.reject_srv_domain == SYS_SRV_DOMAIN_CS_PS ) ||
             ( ss_info_ptr->reg_reject_info.reject_srv_domain == SYS_SRV_DOMAIN_PS_ONLY))
        {
          i_ptr->reg_reject_info.cm_reg_reject_info = ss_info_ptr->reg_reject_info;
          i_ptr->reg_reject_info.reg_reject_reported = FALSE;
        }
      }
    }

    QCRIL_LOG_DEBUG( "RID %d MID %d Serving System : srv status %d, sys mode %d, roam status %d, IDM %d, hdr_hybrid %d, hdr srv status %d, hdr roam status %d, srv cap = %d\n",
                     instance_id, modem_id, i_ptr->ss_info[ modem_id ].srv_status, i_ptr->ss_info[ modem_id ].sys_mode, 
                     i_ptr->ss_info[ modem_id ].roam_status, i_ptr->ss_info[ modem_id ].cur_idle_digital_mode,
                     i_ptr->ss_info[ modem_id ].hdr_hybrid, i_ptr->ss_info[ modem_id ].hdr_srv_status, 
                     i_ptr->ss_info[ modem_id ].hdr_roam_status, i_ptr->ss_info[ modem_id ].srv_capability);

    if ( ssic_notification_status_ptr != NULL )
    {
      *ssic_notification_status_ptr = ssic_notification_status;
    }
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );

  if ( ss_info_updated  )
  {
    /* Check to see whether voice radio technology is changed */
    qcril_arb_query_voice_srv_modem_id( instance_id, &voice_modem_id, &voice_radio_tech );
    if ( ( voice_modem_id != QCRIL_MAX_MODEM_ID ) && ( modem_id == voice_modem_id ) )
    {
      QCRIL_LOG_DEBUG( "RID %d MID %d Update voice radio tech %d\n", instance_id, modem_id, voice_radio_tech );
      if ( ( voice_radio_tech_changed_ptr != NULL ) && ( new_voice_radio_tech_ptr != NULL ) )
      {
        *voice_radio_tech_changed_ptr = TRUE;   
        *new_voice_radio_tech_ptr = voice_radio_tech;
      }
    }
  }

} /* qcril_cm_store_srv_sys_info() */


/*=========================================================================
  FUNCTION:  qcril_cm_event_update_fdn_status

===========================================================================*/
/*!
    @brief
    Update the FDN check status maintained locally.

    @return
    None
*/
/*=========================================================================*/
void qcril_cm_event_update_fdn_status
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_cm_struct_type *i_ptr;
  uint8 *fdn_status;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr-> instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  fdn_status = (uint8*) params_ptr->data;
  QCRIL_ASSERT( fdn_status != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].fdn_status_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->fdn_status_mutex, details );
  i_ptr->fdn_enabled = *fdn_status;
  QCRIL_MUTEX_UNLOCK( &i_ptr->fdn_status_mutex, details );

} /* qcril_cm_event_update_fdn_status() */


/*===========================================================================

  FUNCTION: qcril_cm_event_card_status_updated

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CARD_STATUS_UPDATED.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_event_card_status_updated
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{  
  qcril_instance_id_e_type instance_id, match_instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint8 i, j, slot;
  qcril_modem_ids_list_type modem_ids_list, modem_ids_done_list;
  uint32 user_data;
  qcril_card_info_type *card_info_ptr;
  qcril_reqlist_public_type req_info, match_req_info;
  IxErrnoType err_no, result;
  qcril_request_resp_params_type resp;
  char details[ 40 ];
  boolean card_status_update = TRUE;
  #ifdef FEATURE_QCRIL_DSDS
  qcril_instance_ids_list_type instance_ids_list;
  qcril_unsol_resp_params_type unsol_resp;
  int subs_status;
  qcril_arb_subs_prov_status_e_type subs_state;
  RIL_SelectUiccSub uicc_sub;
  sys_modem_as_id_e_type as_id;
  qmi_uim_session_type session_type;
  #endif /* FEATURE_QCRIL_DSDS */
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  card_info_ptr = ( qcril_card_info_type *) params_ptr->data;
  QCRIL_ASSERT( card_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/
                                                                                          
  slot = card_info_ptr->slot;
  if ( slot > QCRIL_ARB_MAX_SLOTS )
  {
    QCRIL_LOG_ERROR( "Unexpected slot %d card status %s[%d] reported\n", 
                     slot, card_status_name[ card_info_ptr->status ], card_info_ptr->status );
    return;
  }

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].card_info_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->card_info_mutex, details );

  QCRIL_LOG_DEBUG( "Slot %d Card status: %s --> %s\n",
                   slot, card_status_name[ i_ptr->card_info[ slot ].status ], card_status_name[ card_info_ptr->status ] );

  /* The very first time, Card Status is reported */
  if ( ( i_ptr->card_info[ slot ].status == QCRIL_CARD_STATUS_UNKNOWN ) && 
       ( ( card_info_ptr->status == QCRIL_CARD_STATUS_UP ) ||
         ( card_info_ptr->status == QCRIL_CARD_STATUS_DOWN ) ||
         ( card_info_ptr->status == QCRIL_CARD_STATUS_NOT_ACCESSIBLE ) ||
         ( card_info_ptr->status == QCRIL_CARD_STATUS_ILLEGAL ) ||
         ( card_info_ptr->status == QCRIL_CARD_STATUS_ABSENT ) ) )
  {
    qcril_cm_update_card_status( instance_id, card_info_ptr->slot, FALSE, card_info_ptr->status );

    /* If not in FTM mode, band/mode capability info is also known, ready to accept all RIL commands.
       Change Radio State to Modem Off */
    if ( !qcril_cm_ftm_mode_is_on( instance_id ) && qcril_cm_card_status_is_reported( instance_id ) && 
         qcril_cm_phone_capability_is_reported( instance_id ) )
    {
       ret_ptr->modem_state_changed = TRUE;

       QCRIL_LOG_DEBUG("oprt_mode reported by modem = %d\n", i_ptr->ph_info[modem_id].oprt_mode);

       /* In case of DSDS, modem is not moved to LPM during power on, hence report the current modem state */
       /* In case of non-DSDS, modem is moved to LPM during power on hence report radio_off */
       if( qcril_arb_ma_is_dsds() )
       {
          if ( i_ptr->ph_info[modem_id].oprt_mode != SYS_OPRT_MODE_ONLINE )
          {
            ret_ptr->next_modem_state = QCRIL_MODEM_STATE_OFF;
          }
          else
          {
            ret_ptr->next_modem_state = QCRIL_MODEM_STATE_ON;         
          }
       }
       else
       {
           ret_ptr->next_modem_state = QCRIL_MODEM_STATE_OFF;
       }
    }

    QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details );
    return;
  }

  if ( ( i_ptr->card_info[ slot ].status != QCRIL_CARD_STATUS_UNKNOWN ) && 
       ( card_info_ptr->status == QCRIL_CARD_STATUS_REFRESH ) )
  {
    qcril_cm_update_card_status( instance_id, card_info_ptr->slot, FALSE, QCRIL_CARD_STATUS_DOWN );
    QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details );

#ifdef FEATURE_QCRIL_DSDS
   if ( qcril_arb_ma_is_dsds() )
   {
      qcril_arb_query_active_subs_instances_by_card ( card_info_ptr->slot, &instance_ids_list);

      for ( j = 0; j < instance_ids_list.num_of_subs; j++ )
      {
        /* re calculate the i_ptr based on the instance-id tied to the card*/
        instance_id = instance_ids_list.instance_id[j];
        i_ptr = &qcril_cm[ instance_id ];

        /* Mark subscription deactivated on both the instances and clean up the registration states*/
        qcril_arb_deactivate_subs( instance_id );

        /* clear the serving system information, so that UI does not show service and signal strength */
        for(i = 0; i < QCRIL_MAX_MODEM_ID; i++)
        {
           i_ptr->ss_info[i].srv_status = SYS_SRV_STATUS_NO_SRV;
           i_ptr->ss_info[i].changed_fields |= CM_SS_SRV_STATUS_MASK;

          qcril_cm_process_network_info(instance_id, i,  QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED);
        }
     }
   }
#endif

   return;
  }

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) != E_SUCCESS )
  {
     #ifdef FEATURE_QCRIL_DSDS
     if(  qcril_arb_ma_is_dsds()  &&
           qcril_reqlist_query_by_event( QCRIL_DSDS_INSTANCE_PAIR( instance_id ), modem_id, params_ptr->event_id,
                                          &req_info ) != E_SUCCESS )
     {
       card_status_update = TRUE;
     }
     else
     {
        card_status_update = FALSE;
        instance_id = QCRIL_DSDS_INSTANCE_PAIR( instance_id );
     }
     #endif /* FEATURE_QCRIL_DSDS */

     /* Card status updated not initiated by RIL request */
     if( card_status_update )
     {
       qcril_cm_update_card_status( instance_id, card_info_ptr->slot, FALSE, card_info_ptr->status );
       QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details );
       #ifdef FEATURE_QCRIL_DSDS
       if (qcril_arb_ma_is_dsds() )
       {
         /* update the card status information on the other instance */
         QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].card_info_mutex\n", QCRIL_DSDS_INSTANCE_PAIR( instance_id ));
         i_ptr = &qcril_cm[ QCRIL_DSDS_INSTANCE_PAIR( instance_id ) ];

         QCRIL_MUTEX_LOCK( &i_ptr->card_info_mutex, details );
         qcril_cm_update_card_status( QCRIL_DSDS_INSTANCE_PAIR( instance_id ), card_info_ptr->slot, FALSE, card_info_ptr->status );
         QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details );

         if ( card_info_ptr->status == QCRIL_CARD_STATUS_ABSENT )
         {
           qcril_arb_query_active_subs_instances_by_card ( card_info_ptr->slot, &instance_ids_list);

           QCRIL_LOG_DEBUG( "number of subscription tied to the card = %d \n", instance_ids_list.num_of_subs );
           for ( i = 0; i < instance_ids_list.num_of_subs; i++ )
           {
             instance_id = instance_ids_list.instance_id[i];
             qcril_arb_query_subs( instance_id, &subs_state, &uicc_sub, &as_id, &session_type );

             if ( qcril_arb_query_subs_deactivation_pending_flag( instance_id ) || ( subs_state == QCRIL_ARB_SUBS_APPS_SELECTED ) )
             {
                /* card is removed, subscription is deactivated at modem,
                     clear the subscription information, send deactivation indication to telephony */

               QCRIL_LOG_DEBUG( "RID %d, card removed, deactivating the subscription for slot id = %d\n",
                                 instance_id, slot );

               /* Mark subscription deactivated */
               qcril_arb_deactivate_subs( instance_id );

               /* send unsolicited event to telephony indicating subscription is ready at modem */
               qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, &unsol_resp );
               subs_status = QCRIL_CM_SUBSCRIPTION_DEACTIVATED;
               unsol_resp.resp_pkt = (void *)&subs_status;
               unsol_resp.resp_len = sizeof(subs_status);

               qcril_send_unsol_response( &unsol_resp );

               /* re calculate the i_ptr based on the instance-id tied to the card*/
               i_ptr = &qcril_cm[ instance_id ];

               /* Mark subscription deactivated on both the instances and clean up the registration states*/
               for(j = 0; j < QCRIL_ARB_MAX_MODEMS; j++)
               {
                 i_ptr->ss_info[j].srv_status = SYS_SRV_STATUS_NO_SRV;
                 i_ptr->ss_info[j].changed_fields |= CM_SS_SRV_STATUS_MASK;
                 qcril_cm_process_network_info(instance_id, j,  QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED);
               }
             }
             else
             {
                qcril_arb_update_card_removed_flag(instance_id, TRUE);
             }
           }
         }
         return;
       }
       #else
         return;
       #endif /* FEATURE_QCRIL_DSDS */
     }
  }

  if (  req_info.request == RIL_REQUEST_RADIO_POWER )
  {
    /* Card PowerDown operation requested */
    if ( ( req_info.sub.cm.info.radio_mode.oprt_mode == SYS_OPRT_MODE_LPM ) ||
          ( req_info.sub.cm.info.radio_mode.oprt_mode == SYS_OPRT_MODE_PWROFF ) )
    {
      /* Card PowerDown operation completed or failed (e.g. card is unplugged), declare Radio Power (off)  success */
      if ( ( card_info_ptr->status == QCRIL_CARD_STATUS_DOWN ) || 
           ( card_info_ptr->status == QCRIL_CARD_STATUS_POWERDOWN_FAILED ) ||
           ( card_info_ptr->status == QCRIL_CARD_STATUS_NOT_ACCESSIBLE ) ||
           ( card_info_ptr->status == QCRIL_CARD_STATUS_ILLEGAL ) ||
           ( card_info_ptr->status == QCRIL_CARD_STATUS_ABSENT ) )
      {
        qcril_cm_update_card_status( instance_id, card_info_ptr->slot, FALSE, card_info_ptr->status );

        if ( qcril_cm_card_pwr_oprt_is_completed( instance_id ) )
        {

          /* in case of power-off, de-register the event callback functions from RPC and de-register the client */
          if (  req_info.sub.cm.info.radio_mode.oprt_mode == SYS_OPRT_MODE_PWROFF )
          {
             /* de-register the CM/SMS/PBM call backs and release the clients */
             qcril_release();
          }

          #ifdef FEATURE_QCRIL_DSDS
          /* See if subscription info need to be updated for Airplane mode */
          qcril_arb_deactivate_all_subs();

          if( qcril_arb_ma_is_dsds() )
          {
            /* update service status to no service only in case of dsds as subscription mapping is lost */
            for (  i = 0; i < QCRIL_ARB_MAX_INSTANCES; i++ )
            {
              for ( j = 0; j < QCRIL_ARB_MAX_MODEMS; j++ )
              {
                 qcril_cm[ i ].ss_info[ j ].srv_status = SYS_SRV_STATUS_NO_SRV;
              }
            }
          }
          #endif /* FEATURE_QCRIL_DSDS */

          /* Update Radio State */
          ret_ptr->modem_state_changed = TRUE;
          ret_ptr->next_modem_state = QCRIL_MODEM_STATE_OFF;                            

          QCRIL_LOG_DEBUG( "%s\n", "Reply to RIL --> Radio off" );
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
          qcril_send_request_response( &resp );
          // Reset sms ack pending flags.
          qcril_sms_reset_sms_ack_pending_flags( instance_id );

          /* Response also for RIL_REQUEST_RADIO_POWER for the other instance */
          if ( qcril_arb_ma_is_dsds() && req_info.valid_sub_id )
          {
            if ( qcril_reqlist_query_by_req_id( req_info.sub_id, &match_instance_id, &match_req_info ) == E_SUCCESS )
            {                                                                                   
              QCRIL_LOG_DEBUG( "%s\n", "Reply to RIL --> Radio off" );
              qcril_default_request_resp_params( match_instance_id, match_req_info.t, match_req_info.request, 
                                                 RIL_E_SUCCESS, &resp );
              qcril_send_request_response( &resp );
            }
          }
          qcril_send_radio_response_process_blocked_request( instance_id,
                          modem_id, RIL_E_SUCCESS, req_info.sub.cm.info.radio_mode.oprt_mode, req_info.req_id );
        }
      }
    }

    /* Card PowerUp operation requested */
    else if ( req_info.sub.cm.info.radio_mode.oprt_mode == SYS_OPRT_MODE_ONLINE ) 
    {
      /* Card PowerUp operation completed or failed (e.g. card is unplugged), proceed with ONLINE mode switch */
      if ( ( ( i_ptr->card_info[ slot ].status == QCRIL_CARD_STATUS_DOWN ) &&
             ( card_info_ptr->status == QCRIL_CARD_STATUS_UP ) ) ||
           ( card_info_ptr->status == QCRIL_CARD_STATUS_DOWN ) ||
           ( card_info_ptr->status == QCRIL_CARD_STATUS_POWERUP_FAILED ) ||
           ( card_info_ptr->status == QCRIL_CARD_STATUS_NOT_ACCESSIBLE ) ||
           ( card_info_ptr->status == QCRIL_CARD_STATUS_ILLEGAL ) ||
           ( card_info_ptr->status == QCRIL_CARD_STATUS_ABSENT ) )
      {
        qcril_cm_update_card_status( instance_id, card_info_ptr->slot, FALSE, card_info_ptr->status );

        if ( qcril_cm_card_pwr_oprt_is_completed( instance_id ) )
        {
          /* First mark card operation is completed */
          (void) qcril_reqlist_complete_all_amss_events( instance_id, modem_id, req_info.t, QCRIL_REQ_COMPLETED_SUCCESS, 
                                                         &modem_ids_done_list, &result );

          /* Lookup modem to service the request */
          if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_MODE_PREF, instance_id, &modem_ids_list ) != E_SUCCESS )
          {
            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
            qcril_send_request_response( &resp );

            /* Response also for RIL_REQUEST_RADIO_POWER for the other instance */
            if ( qcril_arb_ma_is_dsds() && req_info.valid_sub_id )
            {
              if ( qcril_reqlist_query_by_req_id( req_info.sub_id, &match_instance_id, &match_req_info ) == E_SUCCESS )
              {                                                                                   
                qcril_default_request_resp_params( match_instance_id, match_req_info.t, match_req_info.request, 
                                                   RIL_E_GENERIC_FAILURE, &resp );
                qcril_send_request_response( &resp );
              }
            }
            qcril_send_radio_response_process_blocked_request( instance_id,
                            modem_id, RIL_E_GENERIC_FAILURE, req_info.sub.cm.info.radio_mode.oprt_mode, req_info.req_id );
            QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details );
            return;
          }

          /* Initiate operating modem change */
          for ( i = 0; i < modem_ids_list.num_of_modems; i++ )
          {                                                   
            modem_id = modem_ids_list.modem_id[ i ];
            QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

            err_no = qcril_reqlist_update_pending_event_id( instance_id, modem_id, req_info.t, QCRIL_EVT_CM_PH_OPRT_MODE );
            QCRIL_ASSERT( err_no == E_SUCCESS );
            err_no = qcril_reqlist_update_state( instance_id, modem_id, req_info.t, QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS );
            QCRIL_ASSERT( err_no == E_SUCCESS );

            /* Command CM to change the phone's operating mode */
            user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, req_info.req_id );
            QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_oprt_mode()", "Online" );
            if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_oprt_mode_func( qcril_cm_phonesvc_command_callback,
                                                                           (void *) user_data,
                                                                           i_ptr->client_info[ modem_id ].client_id,
                                                                           req_info.sub.cm.info.radio_mode.oprt_mode ) )
            {
              /* In case of ARM9 reset, the command callback will never be executed. So, need to
                 delete the entry from the ReqList, and call OnRequestComplete() */
              qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
              qcril_send_request_response( &resp );

              /* Response also for RIL_REQUEST_RADIO_POWER for the other instance */
              if ( qcril_arb_ma_is_dsds() && req_info.valid_sub_id )
              {
                if ( qcril_reqlist_query_by_req_id( req_info.sub_id, &match_instance_id, &match_req_info ) == E_SUCCESS )
                {                                                                                   
                  qcril_default_request_resp_params( match_instance_id, match_req_info.t, match_req_info.request, 
                                                     RIL_E_GENERIC_FAILURE, &resp );
                  qcril_send_request_response( &resp );
                }
              }
              qcril_send_radio_response_process_blocked_request( instance_id, modem_id,
                              RIL_E_GENERIC_FAILURE, req_info.sub.cm.info.radio_mode.oprt_mode, req_info.req_id );
              QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details );
              return;
            }
          } /* end for */
        }
      }
    }
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details );

} /* qcril_cm_event_card_status_updated() */


#ifdef FEATURE_QCRIL_SUBS_CTRL
/*===========================================================================

  FUNCTION: qcril_cm_event_enable_subscription

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_ENABLE_SUBSCRIPTION.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_event_enable_subscription
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{  
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  uint16 *subscription_enable_mask_ptr;
  char details[80];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  subscription_enable_mask_ptr = (uint16 *) params_ptr->data;
  QCRIL_ASSERT( subscription_enable_mask_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Enable GW subscription */
  if ( *subscription_enable_mask_ptr & QCRIL_MODE_GW_CONFIG_MASK )  
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d% Enable Pri GW subscription\n", instance_id, modem_id ); 
    /* Command CM to change the phone's subscription state */
    QCRIL_SNPRINTF( details, sizeof( details ), "%s", "GW" ); 
    QCRIL_LOG_RPC2A( instance_id, "cm_ph_cmd_subscription_available()", details );
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_MODE_GW_CONFIG_MASK );
    if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_subscription_available_func( qcril_cm_phonesvc_command_callback,
                                                                                (void *) user_data, 
                                                                                i_ptr->client_info[ modem_id ].client_id,
                                                                                CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                                                                CM_SUBSCRIPTION_STATUS_CHANGE,
                                                                                CM_SUBSCRIPTION_STATUS_NO_CHANGE ) )
    {
      QCRIL_LOG_ERROR( "RID %d MID %d CM fail to take subscription available command\n", instance_id, modem_id );
    }
  }

  /* Enable CDMA subscription */
  if ( *subscription_enable_mask_ptr & QCRIL_MODE_1XEVDO_CONFIG_MASK ) 
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d Enable Pri CDMA subscription\n", instance_id, modem_id ); 
    /* Command CM to change the phone's subscription state */
    QCRIL_SNPRINTF( details, sizeof( details ), "%s", "1xEvDo" ); 
    QCRIL_LOG_RPC2A( instance_id, "cm_ph_cmd_subscription_available()", details );
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_MODE_1XEVDO_CONFIG_MASK );
    if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_subscription_available_func( qcril_cm_phonesvc_command_callback,
                                                                                (void *) user_data, 
                                                                                i_ptr->client_info[ modem_id ].client_id,
                                                                                CM_SUBSCRIPTION_STATUS_CHANGE,
                                                                                CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                                                                CM_SUBSCRIPTION_STATUS_NO_CHANGE ) )
    {
      QCRIL_LOG_ERROR( "RID %d MID %d CM fail to take subscription available command\n", instance_id, modem_id );
    }
  }

} /* qcril_cm_event_enable_subscription() */


/*===========================================================================

  FUNCTION: qcril_cm_event_disable_subscription

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_DISABLE_SUBSCRIPTION.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_event_disable_subscription
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{  
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  uint16 *subscription_disable_mask_ptr;
  char details[80];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  subscription_disable_mask_ptr = (uint16 *) params_ptr->data;
  QCRIL_ASSERT( subscription_disable_mask_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Disable GW subscription */
  if ( *subscription_disable_mask_ptr & QCRIL_MODE_GW_CONFIG_MASK ) 
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d Disable Pri GW subscription\n", instance_id, modem_id ); 
    /* Command CM to change the phone's subscription state */
    QCRIL_SNPRINTF( details, sizeof( details ), "%s", "GW" ); 
    QCRIL_LOG_RPC2A( instance_id, "cm_ph_cmd_subscription_not_available()", details );
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_MODE_GW_CONFIG_MASK );
    if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_subscription_not_available_func( qcril_cm_phonesvc_command_callback,
                                                                                    (void *) user_data, 
                                                                                    i_ptr->client_info[ modem_id ].client_id,
                                                                                    CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                                                                    CM_SUBSCRIPTION_STATUS_CHANGE,
                                                                                    CM_SUBSCRIPTION_STATUS_NO_CHANGE ) )
    {
      QCRIL_LOG_ERROR( "RID %d MID %d CM fail to take subscription not available command\n", instance_id, modem_id );
    }
  }

  /* Disable CDMA subscription */
  if ( *subscription_disable_mask_ptr & QCRIL_MODE_1XEVDO_CONFIG_MASK ) 
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d Disable Pri CDMA subscription\n", instance_id, modem_id ); 
    /* Command CM to change the phone's subscription state */
    QCRIL_SNPRINTF( details, sizeof( details ), "%s", "1xEvDo" ); 
    QCRIL_LOG_RPC2A( instance_id, "cm_ph_cmd_subscription_not_available()", details );
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_MODE_1XEVDO_CONFIG_MASK );
    if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_subscription_not_available_func( qcril_cm_phonesvc_command_callback,
                                                                                    (void *) user_data, 
                                                                                    i_ptr->client_info[ modem_id ].client_id,
                                                                                    CM_SUBSCRIPTION_STATUS_CHANGE,
                                                                                    CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                                                                    CM_SUBSCRIPTION_STATUS_NO_CHANGE ) )
    {
      QCRIL_LOG_ERROR( "RID %d MID %d CM fail to take subscription not available command\n", instance_id, modem_id );
    }
  }

} /* qcril_cm_event_disable_subscription() */
#endif /* FEATURE_QCRIL_SUBS_CTRL */


#ifdef FEATURE_QCRIL_DSDS
/*===========================================================================

  FUNCTION: qcril_cm_event_activate_provision_status

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_ACTIVATE_PROVISION_STATUS.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_event_activate_provision_status
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{  
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_provision_info_type *provision_info_ptr;
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;
  IxErrnoType err_no;
  sys_modem_as_id_e_type as_id;
  qcril_sub_ids_list_type sub_ids_list;
  uint32 user_data;
  char details[ 80 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  provision_info_ptr = ( qcril_provision_info_type *) params_ptr->data;
  QCRIL_ASSERT( provision_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/
                                                                                          
  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS ) 
  {
    if ( ( req_info.request == RIL_REQUEST_SET_UICC_SUBSCRIPTION ) &&
         ( req_info.sub.cm.info.select_uicc_sub.act_status == RIL_UICC_SUBSCRIPTION_ACTIVATE ) )
    {
      /* Provision failure */
      if ( provision_info_ptr->status == QCRIL_PROVISION_STATUS_FAILURE )
      {
        i_ptr->subs_pref_info.is_pending = FALSE;

        QCRIL_LOG_DEBUG( "RID %d, UIM activate subscription failure, slot %d, app_index %d, error_code =%d\n",
                         instance_id, req_info.sub.cm.info.select_uicc_sub.slot, 
                         req_info.sub.cm.info.select_uicc_sub.app_index,  provision_info_ptr->err_code);

        if ( provision_info_ptr->err_code == RIL_E_SUBSCRIPTION_NOT_SUPPORTED )
        {
          QCRIL_LOG_ERROR( "%s", "Incompatible mode preference selected in NV item NV_PREF_MODE_I\n" );
          QCRIL_LOG_ERROR( "%s", "Please change the NV item NV_PREF_MODE_I or Select compatible APP on UI\n" );
        }

        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, 
                                           provision_info_ptr->err_code, &resp );
        qcril_send_request_response( &resp );
      }
      else if ( provision_info_ptr->status == QCRIL_PROVISION_STATUS_IN_PROGRESS )
      {
        QCRIL_LOG_DEBUG( "RID %d, UIM activate subscription in progress, slot %d, app_index %d, session_type %d\n", 
                         instance_id, req_info.sub.cm.info.select_uicc_sub.slot, 
                         req_info.sub.cm.info.select_uicc_sub.app_index,
                         provision_info_ptr->session_type );
        /* Update session type */
        err_no = qcril_reqlist_update_sub_id( instance_id, req_info.t, provision_info_ptr->session_type );
        QCRIL_ASSERT( err_no == E_SUCCESS );
      }
      /* Provision success */
      else 
      {
        QCRIL_LOG_DEBUG( "RID %d, UIM activate subscription success, slot %d, app_index %d, session_type %d\n", 
                         instance_id, req_info.sub.cm.info.select_uicc_sub.slot, 
                         req_info.sub.cm.info.select_uicc_sub.app_index,
                         provision_info_ptr->session_type );

        /* Mark subs apps is selected for the instance */
        qcril_arb_select_subs_apps( instance_id, &req_info.sub.cm.info.select_uicc_sub,
                                    provision_info_ptr->session_type );

        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        qcril_send_request_response( &resp );

        /* Process any pending Subscription Preference info */
        if ( i_ptr->subs_pref_info.is_pending )
        {
           i_ptr->subs_pref_info.is_pending = FALSE;
           QCRIL_LOG_DEBUG( "RID %d, acting on the pending CM_PH_SUBSCRIPTION_PREF_INFO\n", instance_id );
           err_no = qcril_process_event( params_ptr->instance_id, params_ptr->modem_id,
                                         QCRIL_EVT_CM_PH_SUBSCRIPTION_PREF_INFO,
                                         (void *)&i_ptr->subs_pref_info.cm_subs_info,
                                         sizeof( i_ptr->subs_pref_info.cm_subs_info ),
                                         (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
           QCRIL_ASSERT( err_no != E_SUCCESS );
        }
        else
        {
          qcril_arb_query_active_subs_list( &sub_ids_list );
          if ( sub_ids_list.num_of_subs == 0 )
          {
            if ( (provision_info_ptr->session_type == QMI_UIM_SESSION_TYPE_PRI_GW_PROV) ||
                 (provision_info_ptr->session_type == QMI_UIM_SESSION_TYPE_PRI_1X_PROV) )
            {
                as_id = SYS_MODEM_AS_ID_1;
            }
            else
            {
                as_id = SYS_MODEM_AS_ID_2;
            }

            /* Command CM to change to default voice subscription and MT priority subscription */
            QCRIL_SNPRINTF( details, sizeof( details ),
                  "Set Default voice / MT priority subscription, as_id %d", as_id );
            QCRIL_LOG_DEBUG( "RID %d MID %d %s\n", instance_id, modem_id, details );

            QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_dual_standby_pref()", details );
            user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_REQ_ID_INTERNAL );
            (void) qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_dual_standby_pref_func( qcril_cm_phonesvc_command_callback,
                                                                              (void *) user_data,
                                                                              i_ptr->client_info[ modem_id ].client_id,
                                                                              SYS_MODEM_DS_PREF_NO_CHANGE,
                                                                              as_id,
                                                                              as_id,
                                                                              SYS_MODEM_AS_ID_NO_CHANGE,
                                                                              SYS_MODEM_AS_ID_NO_CHANGE );
          }
        }
      }
    }
  }

} /* qcril_cm_event_activate_provision_status() */


/*===========================================================================

  FUNCTION: qcril_cm_event_deactivate_provision_status

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_DEACTIVATE_PROVISION_STATUS.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_event_deactivate_provision_status
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{  
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_provision_info_type *provision_info_ptr;
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;
  char details[ 40 ];
  IxErrnoType err_no;
  qcril_sub_ids_list_type sub_ids_list;
  sys_modem_dual_standby_pref_e_type standby_pref;
  uint32 user_data;
  uint8 i;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  provision_info_ptr = ( qcril_provision_info_type *) params_ptr->data;
  QCRIL_ASSERT( provision_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/
                                                                                          
  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS ) 
  {
    if ( ( req_info.request == RIL_REQUEST_SET_UICC_SUBSCRIPTION ) &&
         ( req_info.sub.cm.info.select_uicc_sub.act_status == RIL_UICC_SUBSCRIPTION_DEACTIVATE ) )
    {
      /* Provision failure */
      if ( provision_info_ptr->status == QCRIL_PROVISION_STATUS_FAILURE )
      {
        i_ptr->subs_pref_info.is_pending = FALSE;

        QCRIL_LOG_DEBUG( "RID %d, UIM deactivate subscription failure, slot %d, app_index %d\n", 
                         instance_id, req_info.sub.cm.info.select_uicc_sub.slot, 
                         req_info.sub.cm.info.select_uicc_sub.app_index );
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
      /* Provision sucess */
      else if ( provision_info_ptr->status == QCRIL_PROVISION_STATUS_SUCCESS )
      {
        QCRIL_LOG_DEBUG( "RID %d, UIM deactivate subscription success, slot %d, app_index %d, session_type %d\n",
                         instance_id, req_info.sub.cm.info.select_uicc_sub.slot,
                         req_info.sub.cm.info.select_uicc_sub.app_index,
                         provision_info_ptr->session_type );

        /* Mark subscription deactivated */
        qcril_arb_deactivate_subs( instance_id );

        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        qcril_send_request_response( &resp );

        /* Check whether standby preference need to be changed */
        qcril_arb_query_active_subs_list( &sub_ids_list );

        standby_pref = i_ptr->ph_info[ modem_id ].standby_pref;
         /* Dual Standby, one active subscriptions, need to change to Single Standby */
        if ( ( standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY ) && ( sub_ids_list.num_of_subs < 2 ) )
        {
           /* Command CM to change to Single Standby mode */
           QCRIL_SNPRINTF( details, sizeof( details ), "Single Standby, Default voice / MT priority subscription %d",
                           sub_ids_list.sub_id[ 0 ] );
           QCRIL_LOG_DEBUG( "RIL %d MID %d %s\n", instance_id, modem_id, details );
     
           QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_dual_standby_pref()", details );
           user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_REQ_ID_INTERNAL );
           (void) qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_dual_standby_pref_func( qcril_cm_phonesvc_command_callback,
                                                                                   (void *) user_data,
                                                                                   i_ptr->client_info[ modem_id ].client_id,
                                                                                   SYS_MODEM_DS_PREF_SINGLE_STANDBY,
                                                                                   sub_ids_list.sub_id[ 0 ],
                                                                                   sub_ids_list.sub_id[ 0 ],
                                                                                   SYS_MODEM_AS_ID_NO_CHANGE,
                                                                                   SYS_MODEM_AS_ID_NO_CHANGE );
        }

        for(i = 0; i < QCRIL_MAX_MODEM_ID; i++)
        {
           i_ptr->ss_info[i].srv_status = SYS_SRV_STATUS_NO_SRV;
           i_ptr->ss_info[i].changed_fields |= CM_SS_SRV_STATUS_MASK;
        }
        qcril_cm_process_network_info(instance_id, modem_id,  QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED);
      }
    }
  }
  else
  {
    QCRIL_LOG_DEBUG( "%s\n", "Late Deactivate provision status event" );
  }

} /* qcril_cm_event_deactivate_provision_status() */
#endif /* FEATURE_QCRIL_DSDS */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_set_preferred_network_type

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_set_preferred_network_type
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{  
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  int *in_data_ptr, net_pref;
  uint32 user_data;
  char details[ 80 ];
  qcril_reqlist_u_type u_info;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref_per_subs()";
  #else
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (int *)params_ptr->data;
  QCRIL_ASSERT( in_data_ptr != NULL );
  net_pref = *in_data_ptr;
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Verify the parameters are valid */
  if ( params_ptr->datalen == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  #endif /* FEATURE_QCRIL_DSDS */

  QCRIL_LOG_DEBUG( "RID %d requested net pref %d\n", instance_id, net_pref );

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );

  /* Find out the mapping of specified network preference  we should set on which modem. */
  if ( qcril_cm_validate_net_pref_vs_modem_capability( instance_id, net_pref, &u_info.cm.info.network_pref ) != E_SUCCESS )
  {
    /* Invalid parameters, send RIL_E_GENERIC_FAILURE response */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_MODE_NOT_SUPPORTED, &resp );
    qcril_send_request_response( &resp );
    QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );
    return;
  }

  /* Add entry to ReqList */
  u_info.cm.info.network_pref.net_pref = net_pref;
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_FREE, 
                               QCRIL_EVT_NONE, &u_info, &reqlist_entry ); 
  /* In case both oprt_mode and mode_pref need to be changed, we change oprt_mode first */
  for ( modem_id = 0; modem_id < QCRIL_MAX_MODEM_ID; modem_id++ )
  {
    QCRIL_LOG_DEBUG( "MID %d, curr mode_pref %d, acq_order_pref %d, oprt_mode %d \n", 
                     modem_id, 
                     i_ptr->ph_info[ modem_id ].mode_pref,              
                     i_ptr->ph_info[ modem_id ].gw_acq_order_pref, 
                     i_ptr->ph_info[ modem_id ].oprt_mode );               

    QCRIL_LOG_DEBUG( "MID %d, exp mode_pref %d, acq_order_pref %d, oprt_mode %d \n", 
                     modem_id, 
                     u_info.cm.info.network_pref.mode_pref[ modem_id ], 
                     u_info.cm.info.network_pref.acq_order_pref[ modem_id ],
                     u_info.cm.info.network_pref.oprt_mode[ modem_id ] );

    if ( qcril_arb_ma_is_fusion() && ( u_info.cm.info.network_pref.oprt_mode[ modem_id ] != SYS_OPRT_MODE_NONE ) ) 
    {
      reqlist_entry.state[ modem_id ] = QCRIL_REQ_AWAITING_CALLBACK;
      reqlist_entry.pending_event_id[ modem_id ] = QCRIL_EVT_CM_PH_OPRT_MODE;
    }
    else if ( u_info.cm.info.network_pref.mode_pref[ modem_id ] != CM_MODE_PREF_NONE ) 
    {
      reqlist_entry.state[ modem_id ] = QCRIL_REQ_AWAITING_CALLBACK;
      reqlist_entry.pending_event_id[ modem_id ] = QCRIL_EVT_CM_PH_SYS_SEL_PREF;
    }
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  for ( modem_id = 0; modem_id < QCRIL_MAX_MODEM_ID; modem_id++ )
  {
    if ( reqlist_entry.state[ modem_id ] == QCRIL_REQ_AWAITING_CALLBACK )
    {
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

      if ( reqlist_entry.pending_event_id[ modem_id ] == QCRIL_EVT_CM_PH_OPRT_MODE )
      {
        /* Command CM to change the phone's operating mode */
        if ( reqlist_entry.sub.cm.info.network_pref.oprt_mode[ modem_id ] == SYS_OPRT_MODE_ONLINE )
        {
          QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_oprt_mode()", "Online" );
        }
        else
        {
          QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_oprt_mode()", "LPM" );
        }

        if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_oprt_mode_func( qcril_cm_phonesvc_command_callback,
                                                                       (void *) user_data,
                                                                       i_ptr->client_info[ modem_id ].client_id,
                                                                       reqlist_entry.sub.cm.info.network_pref.oprt_mode[ modem_id ] ) )
        {
          /* In case of ARM9 reset, the command callback will never be executed. So, need to
             delete the entry from the ReqList, and call OnRequestComplete() */
          qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
          return;
        }
      }
      else
      {
        /* Command CM to change the phone's system selection preference on network type */
        QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, mode pref %d, acq order pref %d", 
                        qcril_log_get_token_id( params_ptr->t ), reqlist_entry.sub.cm.info.network_pref.mode_pref[ modem_id ], 
                        reqlist_entry.sub.cm.info.network_pref.acq_order_pref[ modem_id ] );

        QCRIL_LOG_RPC2( modem_id, cm_ph_cmd_sys_sel_pref_api_name, details );
        if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_sys_sel_pref_func( qcril_cm_phonesvc_command_callback,
                                                                          (void *) user_data,
                                                                          i_ptr->client_info[ modem_id ].client_id,
                                                                          #ifdef FEATURE_QCRIL_DSDS
                                                                          as_id,
                                                                          #endif /* FEATURE_QCRIL_DSDS */
                                                                          reqlist_entry.sub.cm.info.network_pref.mode_pref[ modem_id ],
                                                                          CM_PREF_TERM_PERMANENT,
                                                                          0,
                                                                          reqlist_entry.sub.cm.info.network_pref.acq_order_pref[ modem_id ],
                                                                          CM_BAND_PREF_NO_CHANGE,
                                                                          CM_PRL_PREF_NO_CHANGE,
                                                                          CM_ROAM_PREF_NO_CHANGE,
                                                                          CM_HYBR_PREF_NO_CHANGE,
                                                                          CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                                          CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                                                          NULL 
                                                                          #ifndef FEATURE_QCRIL_DSDS
                                                                          , NULL
                                                                          #endif /* !FEATURE_QCRIL_DSDS */
                                                                        ) )
        {
          /* In case of ARM9 reset, the command callback will never be executed. So, need to
             delete the entry from the ReqList, and call OnRequestComplete() */
          qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
        }
      }
    }
  }

} /* qcril_cm_phonesvc_request_set_preferred_network_type() */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_get_preferred_network_type

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_get_preferred_network_type
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  qcril_modem_ids_list_type modem_ids_list;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  uint8 i;
  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_get_ph_info_api_name = "cm_ph_cmd_get_ph_info_per_subs()";
  #else
  char *cm_ph_cmd_get_ph_info_api_name = "cm_ph_cmd_get_ph_info()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_COMMON, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, 0, QCRIL_REQ_FREE, QCRIL_EVT_NONE, NULL, &reqlist_entry ); 

  for ( i = 0; i < modem_ids_list.num_of_modems && i < QCRIL_MAX_MODEM_ID; i++ )
  {
    modem_id = modem_ids_list.modem_id[ i ];
    reqlist_entry.state[ modem_id ] = QCRIL_REQ_AWAITING_CALLBACK; 
    reqlist_entry.pending_event_id[ modem_id ] = QCRIL_EVT_CM_PH_INFO; 
  }

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  for ( i = 0; i < modem_ids_list.num_of_modems && i < QCRIL_MAX_MODEM_ID; i++ )
  {
    modem_id = modem_ids_list.modem_id[ i ];
    /* Get a snapshot of the current phone information in the CM */
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

    QCRIL_LOG_RPC( modem_id, cm_ph_cmd_get_ph_info_api_name, "Token ID", qcril_log_get_token_id( params_ptr->t ));
    if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_get_ph_info_func( qcril_cm_phonesvc_command_callback, 
                                                                     (void *) user_data, 
                                                                     i_ptr->client_info[ modem_id ].client_id 
                                                                     #ifdef FEATURE_QCRIL_DSDS
                                                                     , as_id
                                                                     #endif /* FEATURE_QCRIL_DSDS */
                                                                   ) )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  }

} /* qcril_cm_phonesvc_request_get_preferred_network_type() */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_set_network_selection_manual

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_set_network_selection_manual
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  uint32 user_data;
  uint8 mcc_mnc_len;
  char *mcc_mnc_ptr;
  qcril_reqlist_u_type u_info;
  qcril_cm_req_info_type *req_info_ptr = &u_info.cm.info;
  qcril_reqlist_public_type reqlist_entry;
  char details[ 120 ];
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref_per_subs()";
  #else
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  mcc_mnc_ptr = (char *) params_ptr->data;
  QCRIL_ASSERT( mcc_mnc_ptr );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  #endif /* FEATURE_QCRIL_DSDS */

  QCRIL_LOG_DEBUG( "Manual network selection : %s\n", mcc_mnc_ptr );

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_3GPP, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Only one modem is configured to support LTE/G/W */
  modem_id = modem_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Invalid MccMnc */
  mcc_mnc_len = strlen( mcc_mnc_ptr );
  if ( ( mcc_mnc_len < 5 ) && 
       ( ( mcc_mnc_len != 1 ) || ( strcmp( mcc_mnc_ptr, "0" ) != 0 ) ) ) 
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Convert MCCMNC from ASCII format to BCD format */
  qcril_cm_ons_convert_mcc_mnc_to_bcd( mcc_mnc_ptr, mcc_mnc_len, &req_info_ptr->manual_network_sel.plmn );

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );
  /* Manual network selection on the same PLMN */
  if ( ( i_ptr->ph_info[ modem_id ].network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL ) &&
       qcril_cm_ons_match_plmn( i_ptr->ph_info[ modem_id ].plmn_pref, req_info_ptr->manual_network_sel.plmn ) )
  {
    req_info_ptr->manual_network_sel.same_plmn = TRUE;
  }
  else
  {
    req_info_ptr->manual_network_sel.same_plmn = FALSE;
  }
  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_PH_SYS_SEL_PREF, &u_info, &reqlist_entry ); 
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /* Command CM to change the phone's system selection preference on network type */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, MODE_PREF_MANUAL, plmn[0] %u, plmn[1] %u, plmn[2] %u", 
                  qcril_log_get_token_id( params_ptr->t ), req_info_ptr->manual_network_sel.plmn.identity[ 0 ],
                  req_info_ptr->manual_network_sel.plmn.identity[ 1 ], req_info_ptr->manual_network_sel.plmn.identity[ 2 ]  );

  QCRIL_LOG_RPC2( modem_id, cm_ph_cmd_sys_sel_pref_api_name, details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_sys_sel_pref_func( qcril_cm_phonesvc_command_callback,
                                                                    (void *) user_data,
                                                                    i_ptr->client_info[ modem_id ].client_id,
                                                                    #ifdef FEATURE_QCRIL_DSDS
                                                                    as_id,
                                                                    #endif /* FEATURE_QCRIL_DSDS */
                                                                    CM_MODE_PREF_NO_CHANGE,
                                                                    CM_PREF_TERM_PERMANENT,
                                                                    0,
                                                                    CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                                    CM_BAND_PREF_NO_CHANGE,
                                                                    CM_PRL_PREF_NO_CHANGE,
                                                                    CM_ROAM_PREF_NO_CHANGE,
                                                                    CM_HYBR_PREF_NO_CHANGE,
                                                                    CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                                    CM_NETWORK_SEL_MODE_PREF_MANUAL,
                                                                    &req_info_ptr->manual_network_sel.plmn 
                                                                    #ifndef FEATURE_QCRIL_DSDS
                                                                    , NULL
                                                                    #endif /* !FEATURE_QCRIL_DSDS */
                                                                  ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_phonesvc_request_set_network_selection_manual() */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_set_network_selection_automatic

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_set_network_selection_automatic
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  uint32 user_data;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref_per_subs()";
  #else
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Lookup the modem that should provide the service */
  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_3GPP, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Only one modem is configured to support LTE/G/W */
  modem_id = modem_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_PH_SYS_SEL_PREF, NULL, &reqlist_entry ); 
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /* Command CM to change the phone's system selection preference on network type */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

  QCRIL_LOG_RPC( modem_id, cm_ph_cmd_sys_sel_pref_api_name, "MODE_PREF_AUTOMATIC Token ID", 
                 qcril_log_get_token_id( params_ptr->t ));
  if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_sys_sel_pref_func( qcril_cm_phonesvc_command_callback,
                                                                    (void *) user_data,
                                                                    i_ptr->client_info[ modem_id ].client_id,
                                                                    #ifdef FEATURE_QCRIL_DSDS
                                                                    as_id,
                                                                    #endif /* FEATURE_QCRIL_DSDS */
                                                                    CM_MODE_PREF_NO_CHANGE,
                                                                    CM_PREF_TERM_PERMANENT,
                                                                    0,
                                                                    CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                                    CM_BAND_PREF_NO_CHANGE,
                                                                    CM_PRL_PREF_NO_CHANGE,
                                                                    CM_ROAM_PREF_NO_CHANGE,
                                                                    CM_HYBR_PREF_NO_CHANGE,
                                                                    CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                                    CM_NETWORK_SEL_MODE_PREF_AUTOMATIC,
                                                                    NULL 
                                                                    #ifndef FEATURE_QCRIL_DSDS
                                                                    , NULL
                                                                    #endif /* !FEATURE_QCRIL_DSDS */
                                                                  ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_phonesvc_request_set_network_selection_automatic() */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_query_network_selection_mode

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_query_network_selection_mode
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  uint32 user_data;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_get_ph_info_api_name = "cm_ph_cmd_get_ph_info_per_subss()";
  char details[ 40 ];
  qcril_reqlist_public_type req_info;
  #else
  char *cm_ph_cmd_get_ph_info_api_name = "cm_ph_cmd_get_ph_info()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* In case of DSDS while airplane mode request is being processed reject the request, as we reject the request while in airplane mode.
       This is done due to race condition where back to back command and event call backs are received.
       Since subscription is deactivated, event call back is incorrectly processed as callback was still on queue */
  if ( qcril_arb_ma_is_dsds() )
  {
    QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
    QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );
 
    if( ( qcril_reqlist_query_by_event( instance_id, QCRIL_DEFAULT_MODEM_ID, RIL_REQUEST_RADIO_POWER, &req_info ) == E_SUCCESS ) ||
         ( i_ptr->ph_info[QCRIL_DEFAULT_MODEM_ID].oprt_mode == SYS_OPRT_MODE_LPM ) )
    {
      QCRIL_LOG_DEBUG( "%s\n", "Airplane mode request in progress, Ignore request" );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );

      QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );
      return;
    }

    QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );
  }
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_3GPP, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Only one modem is configured to support LTE/G/W */
  modem_id = modem_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_PH_INFO, NULL, &reqlist_entry ); 
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /* Get a snapshot of the current phone information in the CM */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

  QCRIL_LOG_RPC( modem_id, cm_ph_cmd_get_ph_info_api_name, "Token ID", qcril_log_get_token_id( params_ptr->t ));
  if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_get_ph_info_func( qcril_cm_phonesvc_command_callback, 
                                                                   (void *) user_data, 
                                                                   i_ptr->client_info[ modem_id ].client_id 
                                                                   #ifdef FEATURE_QCRIL_DSDS
                                                                   , as_id
                                                                   #endif /* FEATURE_QCRIL_DSDS */
                                                                 ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_phonesvc_request_query_network_selection_mode() */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_set_band_mode

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_BAND_MODE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_set_band_mode
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  uint8 i;
  uint32 user_data;
  int *in_data_ptr;
  qcril_reqlist_u_type u_info;
  qcril_cm_req_info_type *req_info_ptr = &u_info.cm.info;
  qcril_reqlist_public_type reqlist_entry;
  char details[ 80 ];
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref_per_subs()";
  #else
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (int *)params_ptr->data;
  QCRIL_ASSERT( in_data_ptr );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Verify the parameters are valid */
  if ( params_ptr->datalen == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  switch ( *in_data_ptr )
  {
    case QCRIL_CM_BAND_MODE_UNSPECIFIED:
      req_info_ptr->band_pref = QCRIL_CM_BAND_PREF_ANY;
      break;

    case QCRIL_CM_BAND_MODE_EURO:
      req_info_ptr->band_pref = QCRIL_CM_BAND_PREF_EURO;
      break;

    case QCRIL_CM_BAND_MODE_US:
      req_info_ptr->band_pref = QCRIL_CM_BAND_PREF_US;
      break;

    case QCRIL_CM_BAND_MODE_JPN:
      req_info_ptr->band_pref = QCRIL_CM_BAND_PREF_JPN;
      break;

    case QCRIL_CM_BAND_MODE_AUS:
      req_info_ptr->band_pref = QCRIL_CM_BAND_PREF_AUS;
      break;

    case QCRIL_CM_BAND_MODE_AUS2:
      req_info_ptr->band_pref = QCRIL_CM_BAND_PREF_AUS2;
      break;

    case QCRIL_CM_BAND_MODE_CELL:
      req_info_ptr->band_pref = CM_BAND_PREF_BC0;
      break;

    case QCRIL_CM_BAND_MODE_PCS:
      req_info_ptr->band_pref = CM_BAND_PREF_BC1;
      break;

    case QCRIL_CM_BAND_MODE_BC3:
      req_info_ptr->band_pref = CM_BAND_PREF_BC3;
      break;

    case QCRIL_CM_BAND_MODE_BC4:
      req_info_ptr->band_pref = CM_BAND_PREF_BC4;
      break;

    case QCRIL_CM_BAND_MODE_BC5:
      req_info_ptr->band_pref = CM_BAND_PREF_BC5;
      break;

    case QCRIL_CM_BAND_MODE_BC6:
      req_info_ptr->band_pref = CM_BAND_PREF_BC6;
      break;

    case QCRIL_CM_BAND_MODE_BC7:
      req_info_ptr->band_pref = CM_BAND_PREF_BC7;
      break;

    case QCRIL_CM_BAND_MODE_BC8:
      req_info_ptr->band_pref = CM_BAND_PREF_BC8;
      break;

    case QCRIL_CM_BAND_MODE_BC9:
      req_info_ptr->band_pref = CM_BAND_PREF_BC9;
      break;

    case QCRIL_CM_BAND_MODE_BC10:
      req_info_ptr->band_pref = CM_BAND_PREF_BC10;
      break;

    case QCRIL_CM_BAND_MODE_BC11:
      req_info_ptr->band_pref = CM_BAND_PREF_BC11;
      break;

    case QCRIL_CM_BAND_MODE_BC15:
      req_info_ptr->band_pref = CM_BAND_PREF_BC15;
      break;

    case QCRIL_CM_BAND_MODE_BC16:
      req_info_ptr->band_pref = CM_BAND_PREF_BC16;
      break;

    default:
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
      return;
  }

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_COMMON, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, 0, QCRIL_REQ_FREE, QCRIL_EVT_NONE, &u_info, &reqlist_entry ); 

  for ( i = 0; i < modem_ids_list.num_of_modems; i++ )
  {
    modem_id = modem_ids_list.modem_id[ i ];
    reqlist_entry.state[ modem_id ] = QCRIL_REQ_AWAITING_CALLBACK; 
    reqlist_entry.pending_event_id[ modem_id ] = QCRIL_EVT_CM_PH_SYS_SEL_PREF; 
  }

  /* Add entry to ReqList */
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /* Command CM to change the phone's system selection preference on network type */
  for ( i = 0; i < modem_ids_list.num_of_modems; i++ )
  {
    modem_id = modem_ids_list.modem_id[ i ];
    QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

    if ( reqlist_entry.state[ modem_id ] == QCRIL_REQ_AWAITING_CALLBACK )
    {
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
      QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, band pref %lld", 
                      qcril_log_get_token_id( params_ptr->t ), req_info_ptr->band_pref );

      QCRIL_LOG_RPC2( modem_id, cm_ph_cmd_sys_sel_pref_api_name, details );
      if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_sys_sel_pref_func( qcril_cm_phonesvc_command_callback,
                                                                        (void *) user_data,
                                                                        i_ptr->client_info[ modem_id ].client_id,
                                                                        #ifdef FEATURE_QCRIL_DSDS
                                                                        as_id,
                                                                        #endif /* FEATURE_QCRIL_DSDS */
                                                                        CM_MODE_PREF_NO_CHANGE,
                                                                        CM_PREF_TERM_PERMANENT,
                                                                        0,
                                                                        CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                                        req_info_ptr->band_pref,
                                                                        CM_PRL_PREF_NO_CHANGE,
                                                                        CM_ROAM_PREF_NO_CHANGE,
                                                                        CM_HYBR_PREF_NO_CHANGE,
                                                                        CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                                        CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                                                        NULL 
                                                                        #ifndef FEATURE_QCRIL_DSDS
                                                                        , NULL
                                                                        #endif /* !FEATURE_QCRIL_DSDS */
                                                                      ) )
      {
        /* In case of ARM9 reset, the command callback will never be executed. So, need to
           delete the entry from the ReqList, and call OnRequestComplete() */
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
    }
  }

} /* qcril_cm_phonesvc_request_set_band_mode() */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_query_available_band_mode

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_query_available_band_mode
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  uint64 band_capability = 0;
  int i;
  char *band_mode_text[] =  
  {
    "Unspecified", 
    "EURO band", 
    "US band", 
    "JPN band", 
    "AUS band", 
    "AUS2 band"
    , "Cellular band"
    , "PCS band"
    , "Band class 3"
    , "Band class 4"
    , "Band class 5"
    , "Band class 6"
    , "Band class 7"
    , "Band class 8"
    , "Band class 9"
    , "Band class 10"
    , "Band class 11"
    , "Band class 15"
    , "Band class 16" 
  };
  qcril_cm_available_band_mode_type *payload_ptr;
  qcril_request_resp_params_type resp;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_COMMON, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );

  /* Combine the band capability of all modems */
  for ( modem_id = 0; modem_id < modem_ids_list.num_of_modems; modem_id++ )
  {
    band_capability |= i_ptr->ph_info[ modem_id ].band_capability;
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

  /* Compose the response for RIL request */
  if ( ( payload_ptr = ( qcril_cm_available_band_mode_type * ) qcril_malloc( sizeof( qcril_cm_available_band_mode_type ) ) ) != NULL )
  {
    payload_ptr->available_band_mode[ 0 ] = 0;

    if ( ( band_capability & QCRIL_CM_BAND_PREF_ANY ) == QCRIL_CM_BAND_PREF_ANY )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_UNSPECIFIED;
    }

    if ( ( band_capability & QCRIL_CM_BAND_PREF_EURO ) == QCRIL_CM_BAND_PREF_EURO )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_EURO;
    }

    if ( ( band_capability & QCRIL_CM_BAND_PREF_US ) == QCRIL_CM_BAND_PREF_US )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_US;
    }

    if ( ( band_capability & QCRIL_CM_BAND_PREF_JPN ) == QCRIL_CM_BAND_PREF_JPN )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_JPN;
    }

    if ( ( band_capability & QCRIL_CM_BAND_PREF_AUS ) == QCRIL_CM_BAND_PREF_AUS )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_AUS;
    }

    if ( ( band_capability & QCRIL_CM_BAND_PREF_AUS2 ) == QCRIL_CM_BAND_PREF_AUS2 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_AUS2;
    }

    if ( ( band_capability & CM_BAND_PREF_BC0 ) == CM_BAND_PREF_BC0 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_CELL;
    }

    if ( ( band_capability & CM_BAND_PREF_BC1 ) == CM_BAND_PREF_BC1 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_PCS;
    }

    if ( ( band_capability & CM_BAND_PREF_BC3 ) == CM_BAND_PREF_BC3 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_BC3;
    }

    if ( ( band_capability & CM_BAND_PREF_BC4 ) == CM_BAND_PREF_BC4 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_BC4;
    }

    if ( ( band_capability & CM_BAND_PREF_BC5 ) == CM_BAND_PREF_BC5 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_BC5;
    }

    if ( ( band_capability & CM_BAND_PREF_BC6 ) == CM_BAND_PREF_BC6 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_BC6;
    }

    if ( ( band_capability & CM_BAND_PREF_BC7 ) == CM_BAND_PREF_BC7 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_BC7;
    }

    if ( ( band_capability & CM_BAND_PREF_BC8 ) == CM_BAND_PREF_BC8 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_BC8;
    }

    if ( ( band_capability & CM_BAND_PREF_BC9 ) == CM_BAND_PREF_BC9 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_BC9;
    }

    if ( ( band_capability & CM_BAND_PREF_BC10 ) == CM_BAND_PREF_BC10 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_BC10;
    }

    if ( ( band_capability & CM_BAND_PREF_BC11 ) == CM_BAND_PREF_BC11 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_BC11;
    }

    if ( ( band_capability & CM_BAND_PREF_BC15 ) == CM_BAND_PREF_BC15 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_BC15;
    }

    if ( ( band_capability & CM_BAND_PREF_BC16 ) == CM_BAND_PREF_BC16 )
    {
      payload_ptr->available_band_mode[ ++payload_ptr->available_band_mode[ 0 ] ] = QCRIL_CM_BAND_MODE_BC16;
    }

    QCRIL_LOG_DEBUG( "Reply to RIL --> Number of band mode support : %d\n", payload_ptr->available_band_mode[ 0 ] );

    for ( i = 0; i < payload_ptr->available_band_mode[ 0 ]; i++ )
    {
      QCRIL_LOG_DEBUG( "Reply to RIL --> supported_band_mode[%d] : %s\n", i, 
                       band_mode_text[ payload_ptr->available_band_mode[ i + 1 ] ] );
    }

    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    resp.resp_pkt = (void *) &payload_ptr->available_band_mode;
    resp.resp_len = ( payload_ptr->available_band_mode[ 0 ] + 1 ) * sizeof( payload_ptr->available_band_mode[ 0 ] );
    qcril_send_request_response( &resp );
    qcril_free( payload_ptr );
  }
  else
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_phonesvc_request_query_available_band_mode() */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_query_available_networks

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_QUERY_AVAILABLE_NETWORKS.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_query_available_networks
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  uint32 user_data;
  cm_network_list_type_e_type list_type = CM_NETWORK_LIST_AVAILABLE;
  char details[ 80 ];
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_get_networks_api_name = "cm_ph_cmd_get_networks_per_subs()";
  #else
  char *cm_ph_cmd_get_networks_api_name = "cm_ph_cmd_get_networks()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_3GPP, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Only one modem is configured to support LTE/G/W */
  modem_id = modem_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_PH_AVAILABLE_NETWORKS_CONF, NULL, &reqlist_entry ); 
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /* Get a snapshot of the current phone information in the CM */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, list_type %d", 
                  qcril_log_get_token_id( params_ptr->t ), list_type );

  QCRIL_LOG_RPC2( modem_id, cm_ph_cmd_get_networks_api_name, details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_get_networks_func( qcril_cm_phonesvc_command_callback, 
                                                                    (void *) user_data, 
                                                                    i_ptr->client_info[ modem_id ].client_id,
                                                                    list_type, 
                                                                    CM_MODE_PREF_NO_CHANGE 
                                                                    #ifdef FEATURE_QCRIL_DSDS
                                                                    , as_id
                                                                    #endif /* FEATURE_QCRIL_DSDS */
                                                                  ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_phonesvc_request_query_available_networks() */



int qcril_find_radio_power_request_pair(
  qcril_instance_id_e_type instance_id,
  int *in_data_ptr
)
{
  qcril_instance_id_e_type pair_instance_id, inst_id;
  qcril_reqlist_public_type match_req_info;
  int i, invalid = -1;
  QCRIL_ASSERT (in_data_ptr);

  QCRIL_LOG_DEBUG ("%s: RID %d in_data %d", __func__, instance_id, *in_data_ptr);

    if ( *in_data_ptr == QCRIL_CM_RADIO_POWER_MODE_ONLINE )
    {
      for ( i = 0; i < num_radio_on_req; i++ )
      {
         QCRIL_LOG_DEBUG ("radio_on_req[%d] = %d", i, radio_on_req[i]);
         if (qcril_reqlist_query_by_req_id( radio_on_req[i],
                    &inst_id, &match_req_info) == E_SUCCESS)
         {
            // Pair with request whose valid_sub_id is FALSE and instance_id matches with
            // the pair instance_id that has been passed.
            if ( (match_req_info.valid_sub_id == FALSE ) && (inst_id == instance_id) )
            {
              QCRIL_LOG_DEBUG ("%s: RID %d Found RADIO_ON request %d! ", __func__, instance_id, radio_on_req[i]);
              return radio_on_req[i];
            }
         }
      }
    }
    else
    {
      for ( i = 0; i < num_radio_off_req; i++ )
      {
         QCRIL_LOG_DEBUG ("radio_off_req[%d] = %d", i, radio_off_req[i]);
         if (qcril_reqlist_query_by_req_id( radio_off_req[i],
                    &inst_id, &match_req_info) == E_SUCCESS)
         {
            // Pair with request whose valid_sub_id is FALSE and instance_id matches with
            // the pair instance_id that has been passed.
            if ( (match_req_info.valid_sub_id == FALSE ) && (inst_id == instance_id) )
            {
              QCRIL_LOG_DEBUG ("%s: RID %d Found RADIO_OFF request %d! ", __func__, instance_id, radio_off_req[i]);
              return radio_off_req[i];
            }
         }
      }
    }
    return invalid;
}

boolean qcril_create_and_bind_radio_power_request(
  qcril_instance_id_e_type instance_id,
  RIL_Token t,
  int event_id,
  qcril_reqlist_public_type match_req_info
)
{
    qcril_reqlist_public_type reqlist_entry;

    QCRIL_LOG_DEBUG ("%s: RID %d Token %d event_id %d", __func__, instance_id,
                    qcril_log_get_token_id(t), event_id);

    qcril_reqlist_default_entry( t, event_id, QCRIL_DEFAULT_MODEM_ID,
           QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS, QCRIL_EVT_CM_PH_OPRT_MODE,
           NULL, &reqlist_entry );

       reqlist_entry.sub = match_req_info.sub;
       reqlist_entry.sub.cm.info.radio_mode.is_command_instance = FALSE;
       reqlist_entry.valid_sub_id = TRUE;
       reqlist_entry.sub_id = match_req_info.req_id;
       reqlist_entry.state[QCRIL_DEFAULT_MODEM_ID] = QCRIL_REQ_BLOCKED;

       if (qcril_reqlist_new( instance_id, &reqlist_entry) != E_SUCCESS)
       {
         // Fail to add entry to ReqList
         QCRIL_LOG_ERROR( "%s: Fail to bundle RIL_REQUEST_RADIO_POWER token %d with token %d\n",
               __func__, qcril_log_get_token_id(match_req_info.t), qcril_log_get_token_id(t));
         return FALSE;
       }

       if (qcril_reqlist_update_sub_id( QCRIL_DSDS_INSTANCE_PAIR( instance_id ), match_req_info.t,
               reqlist_entry.req_id ) != E_SUCCESS )
       {
         QCRIL_LOG_ERROR( "%s: Fail2 to bundle RIL_REQUEST_RADIO_POWER token %d with token %d\n",
               __func__, qcril_log_get_token_id( match_req_info.t ), qcril_log_get_token_id( t ) );
         return FALSE;
       }
       else
       {
         QCRIL_LOG_DEBUG( "%s: Bundle RIL_REQUEST_RADIO_POWER token %d with token %d\n",
             __func__, qcril_log_get_token_id( match_req_info.t ),
             qcril_log_get_token_id( t ) );
         return TRUE;
       }
}

qcril_flow_control_e_type qcril_flow_control_radio_power(
  qcril_instance_id_e_type instance_id,
  qcril_modem_id_e_type modem_id,
  int *in_data_ptr,
  RIL_Token t,
  int event_id
)
{
    boolean is_dup_request = FALSE;
    qcril_reqlist_public_type match_req_info;
    qcril_request_resp_params_type resp;
    qcril_instance_id_e_type pair_instance_id;
    int req_id;

    /*-----------------------------------------------------------------------*/

    QCRIL_LOG_DEBUG ("%s: RID %d modem_id %d Token %d event_id %d in_data %d", __func__, instance_id,
                    modem_id, qcril_log_get_token_id(t), event_id, *in_data_ptr);
    QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
    QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
    QCRIL_ASSERT (in_data_ptr);

    is_dup_request = qcril_reqlist_query_by_request(instance_id , RIL_REQUEST_RADIO_POWER,
                                         &match_req_info) == E_SUCCESS;
    if (is_dup_request)
    {
      if ( qcril_arb_ma_is_dsds() )
      {
        pair_instance_id = QCRIL_DSDS_INSTANCE_PAIR( instance_id );
        /*
         This is a duplicate request. This can be,

        1. Bundled with suitable existing duplicate request OR,

        2. Added to the duplicate request id list (with state as BLOCKED) as
        a suitable match cannot be found. This would be processed after cb for the
        current request is received.
        */
        req_id = qcril_find_radio_power_request_pair (pair_instance_id, in_data_ptr);
        if (req_id >= 0)
        {
          QCRIL_LOG_DEBUG ("%s: RID %d Found request pair req_id = %d", __func__, pair_instance_id, req_id);
          if ( qcril_reqlist_query_by_req_id (req_id, &pair_instance_id,
                          &match_req_info) == E_SUCCESS )
          {
            if ( qcril_create_and_bind_radio_power_request(instance_id, t,
                        event_id, match_req_info) == TRUE )
            {
              QCRIL_LOG_DEBUG("%s: DSDS, duplicate request bundled", __func__);
            }
            else
            {
              QCRIL_LOG_DEBUG("%s: DSDS, fail to bundle duplicate request, return failure"
                            , __func__);
              qcril_default_request_resp_params( instance_id, t, event_id,
                      RIL_E_GENERIC_FAILURE, &resp );
              qcril_send_request_response( &resp );
            }
          }
          else
          {
            QCRIL_LOG_DEBUG("%s: DSDS, Unable to find req_id %d"
                            , __func__, req_id);
          }
          return BINDED_DUP_REQUEST;
        }
        else
        {
          QCRIL_LOG_DEBUG("%s: DSDS, Unable to find any matching request to bundle.", __func__);
        }
      }
      return DUP_REQUEST;
    }
    else
    {
      return NOT_DUP_REQUEST;
    }
}

boolean qcril_send_duplicate_request_response
(
  qcril_instance_id_e_type instance_id,
  int req_id[],
  int num_req,
  RIL_Errno ril_errno,
  sys_oprt_mode_e_type oprt_mode
)
{
  qcril_instance_id_e_type pair_instance_id;
  qcril_request_resp_params_type resp;
  qcril_reqlist_public_type match_req_info, pair_req_info;
  boolean cond = FALSE;
  int i = 0;

  QCRIL_LOG_DEBUG ("%s: RID %d num_req %d ril_errno %d oprt_mode %d", __func__, num_req, ril_errno, oprt_mode);

  if ( num_req > 0 )
  {
    for ( i = 0 ; i < num_req; i++ )
    {
      cond = qcril_reqlist_query_by_req_id ( req_id[i], &instance_id, &match_req_info ) == E_SUCCESS;
      if ( cond == TRUE )
      {
        QCRIL_LOG_DEBUG("%s: RID %d Request req_id %d requested for mode %d. Send response. "
                         , __func__, instance_id, match_req_info.req_id, oprt_mode);
        qcril_default_request_resp_params( instance_id, match_req_info.t, match_req_info.request, ril_errno, &resp );
        qcril_send_request_response( &resp );
        // Send response for other instance
        if ( qcril_arb_ma_is_dsds() && match_req_info.valid_sub_id )
        {
          if ( qcril_reqlist_query_by_req_id( match_req_info.sub_id, &pair_instance_id, &pair_req_info ) == E_SUCCESS )
          {
            QCRIL_LOG_DEBUG( "%s: RID %d Request token %d requested for mode %d. Send response.", __func__,
                            pair_instance_id, qcril_log_get_token_id( pair_req_info.t), oprt_mode);
            qcril_default_request_resp_params( pair_instance_id, pair_req_info.t, pair_req_info.request,
                                             ril_errno, &resp );
            qcril_send_request_response( &resp );
          }
        }
      }
    }
    if ( i == num_req) return TRUE;
  }
  return FALSE;
}

void qcril_process_radio_power_request
(
qcril_instance_id_e_type instance_id,
qcril_modem_ids_list_type modem_ids_list,
qcril_slot_ids_list_type slot_ids_list,
qcril_reqlist_public_type reqlist_entry
)
{
qcril_cm_struct_type *i_ptr;
qcril_reqlist_public_type match_req_info, pair_req_info;
qcril_instance_id_e_type pair_instance_id;
uint32 user_data;
int i, slot;
qcril_modem_id_e_type modem_id;
qcril_request_resp_params_type resp;
IxErrnoType err_no;
char *mode_name;

QCRIL_LOG_DEBUG("Enter %s", __func__);
QCRIL_LOG_DEBUG("instance_id %d", instance_id);
QCRIL_LOG_DEBUG("num_of_modems %d", modem_ids_list.num_of_modems);
QCRIL_LOG_DEBUG("num slots %d", slot_ids_list.num_of_slots);

i_ptr = &qcril_cm[instance_id];
QCRIL_ASSERT( i_ptr );

QCRIL_LOG_DEBUG("%s: RID %d pending_event_id %d token %d ", __func__, instance_id, reqlist_entry.pending_event_id[QCRIL_DEFAULT_MODEM_ID], qcril_log_get_token_id(reqlist_entry.t));

if ( reqlist_entry.pending_event_id[QCRIL_DEFAULT_MODEM_ID] == QCRIL_EVT_CM_PH_OPRT_MODE )
{
  /* Multiple modems may need to request for operating modem change */
  for ( i = 0; i < modem_ids_list.num_of_modems; i++ )
  {
    QCRIL_LOG_DEBUG("%s: RID %d Pending event is QCRIL_EVT_CM_PH_OPRT_MODE", __func__, instance_id);

    modem_id = modem_ids_list.modem_id[ i ];
    QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

    if ( reqlist_entry.state[ modem_id ]== QCRIL_REQ_AWAITING_CALLBACK )
    {
      /* Command CM to change the phone's operating mode */
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
      QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_oprt_mode()", "LPM" );
      QCRIL_LOG_DEBUG("%s: RID %d Calling cm_ph_cmd_oprt_mode clientid %d oprt mode %d", __func__, instance_id, i_ptr->client_info[ modem_id ].client_id, reqlist_entry.sub.cm.info.radio_mode.oprt_mode);
      if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_oprt_mode_func( qcril_cm_phonesvc_command_callback,
                                                                     (void *) user_data,
                                                                     i_ptr->client_info[ modem_id ].client_id,
                                                                     reqlist_entry.sub.cm.info.radio_mode.oprt_mode ) )
      {
        /* In case of ARM9 reset, the command callback will never be executed. So, need to
           delete the entry from the ReqList, and call OnRequestComplete() */
        qcril_default_request_resp_params( instance_id, reqlist_entry.t, reqlist_entry.pending_event_id[QCRIL_DEFAULT_MODEM_ID], RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        // Send response for other instance
        if ( qcril_arb_ma_is_dsds() && reqlist_entry.valid_sub_id )
        {
          if ( qcril_reqlist_query_by_req_id( reqlist_entry.sub_id, &pair_instance_id, &pair_req_info ) == E_SUCCESS )
          {
            qcril_default_request_resp_params( pair_instance_id, pair_req_info.t, pair_req_info.request,
                                             RIL_E_GENERIC_FAILURE, &resp );
            qcril_send_request_response( &resp );
          }
        }
        return;
      }
    }
  }
}
else
{
  /* Multiple cards may need to request for power up */
  for ( i = 0; i < slot_ids_list.num_of_slots; i++ )
  {
    slot = (int) slot_ids_list.slot_id[ i ];
    QCRIL_LOG_DEBUG( "%s: Request QCRIL(UIM) to power up the card in slot %d\n", __func__, slot );
    qcril_cm_update_card_status( instance_id, slot, TRUE, i_ptr->card_info[ slot ].status );
    err_no = qcril_process_event( instance_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_UP,
                                  (void *) &slot, sizeof( slot ),
                                  (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    QCRIL_ASSERT( err_no == E_SUCCESS );
  }
}
}

void qcril_send_radio_response_process_blocked_request
(
  qcril_instance_id_e_type instance_id,
  qcril_modem_id_e_type modem_id,
  RIL_Errno ril_errno,
  sys_oprt_mode_e_type curr_oprt_mode,
  int processed_req_id
)
{
  qcril_instance_id_e_type pair_instance_id;
  qcril_reqlist_public_type match_req_info, pair_req_info;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  qcril_slot_ids_list_type slot_ids_list;
  qcril_evt_e_type pending_event_id;
  qcril_req_state_e_type state;
  sys_oprt_mode_e_type oprt_mode;
  qcril_request_resp_params_type resp;
  IxErrnoType err_no;
  int i, slot, index;
  char details1[ 40 ], details2[ 40 ];
  char *mode_name = NULL;
  boolean cond = FALSE;

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];

  QCRIL_LOG_DEBUG ( "RID %d qcril_send_radio_response_process_blocked_request ril_errno = %d curr_oprt_mode = %d modem_id = %d",
          instance_id, (int) ril_errno, curr_oprt_mode, modem_id );

  /* ---------------------------------------------------------------- */


  /* A RIL_REQUEST_RADIO_POWER just finished execution. Now we are here to,
     1. Send response to other duplicate requests that are blocked and had requested for same operating mode change.
     2. There can be other blocked RADIO_POWER requests requesting different operating mode, unblock first such request.
   */

  if ( curr_oprt_mode == SYS_OPRT_MODE_ONLINE )
  {
    QCRIL_LOG_DEBUG ( "%s: RID %d Send response for online requests. Pending requests = %d", __func__, instance_id, num_radio_on_req);
    cond = qcril_send_duplicate_request_response ( instance_id, radio_on_req, num_radio_on_req, ril_errno, curr_oprt_mode );
    QCRIL_ASSERT ( cond != TRUE );
    if ( cond == TRUE )
    {
      QCRIL_LOG_DEBUG ( "%s: Responded to all duplicate requests. Reset num_radio_on_req (%d) to 0.", __func__, num_radio_on_req);
      for ( i = 0; i < num_radio_on_req; i++ )
      {
        radio_on_req[i] = -1;
      }
      num_radio_on_req = 0;
    }
  }
  else
  {
    QCRIL_LOG_DEBUG ( "%s: RID %d Send response for offline requests. Pending requests = %d", __func__, instance_id, num_radio_off_req);
    cond = qcril_send_duplicate_request_response ( instance_id, radio_off_req, num_radio_off_req, ril_errno, curr_oprt_mode );
    QCRIL_ASSERT ( cond != TRUE );
    if ( cond == TRUE )
    {
      QCRIL_LOG_DEBUG ( "%s: Responded to all duplicate requests. Reset num_radio_off_req (%d) to 0.", __func__, num_radio_off_req);
      for ( i = 0; i < num_radio_off_req; i++ )
      {
        radio_off_req[i] = -1;
      }
      num_radio_off_req = 0;
    }
  }

  /* We have responded to the duplicate requests requesting for same mode change.
     The remaining requests would belong to different operating mode, unblock the first request.
   */
  cond = qcril_reqlist_query_by_request( instance_id, RIL_REQUEST_RADIO_POWER,
                                         &match_req_info ) == E_SUCCESS;
  // The request can belong the other sub too in case of DSDS
  if ( ( cond == FALSE ) && qcril_arb_ma_is_dsds() )
  {
    cond = qcril_reqlist_query_by_request( QCRIL_DSDS_INSTANCE_PAIR( instance_id ), RIL_REQUEST_RADIO_POWER,
                                         &match_req_info ) == E_SUCCESS;
    instance_id = QCRIL_DSDS_INSTANCE_PAIR( instance_id );
  }
  if ( cond )
  {
    oprt_mode = match_req_info.sub.cm.info.radio_mode.oprt_mode;
    QCRIL_LOG_DEBUG ( "%s: RID %d Need to unblock request %d requesting %d", __func__, instance_id, qcril_log_get_token_id( match_req_info.t ), oprt_mode);

    // We had not set the right pending_event_id and state for duplicate requests, do it here.
    if ( ( oprt_mode == SYS_OPRT_MODE_ONLINE ) &&
          ( !i_ptr->apm_sim_not_pwdn && qcril_cm_card_status_is_down( instance_id, &slot_ids_list )))
    {
      QCRIL_LOG_DEBUG ( "%s: RID %d oprt_mode = %d Card needs to be powered on!", __func__, instance_id, oprt_mode);
      pending_event_id = QCRIL_EVT_CM_CARD_STATUS_UPDATED;
      state = QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS;
      if ( qcril_reqlist_update_state (instance_id, modem_id, match_req_info.t, state) != E_SUCCESS )
      {
         QCRIL_LOG_DEBUG ( "%s: RID %d Unable to update state for token %d", __func__, instance_id, qcril_log_get_token_id(match_req_info.t));
      }
      if ( qcril_reqlist_update_pending_event_id (instance_id, modem_id, match_req_info.t, pending_event_id) != E_SUCCESS )
      {
         QCRIL_LOG_DEBUG ( "%s: RID %d Unable to update pending_event_id for token %d", __func__, instance_id, qcril_log_get_token_id (match_req_info.t));
      }
    } else
    {
      QCRIL_LOG_DEBUG ( "%s: RID %d oprt_mode = %d Card already powered on!!", __func__, instance_id, oprt_mode);
      pending_event_id = QCRIL_EVT_CM_PH_OPRT_MODE;
      state = QCRIL_REQ_AWAITING_CALLBACK;
    }
    /* Multiple modems may need to request for operating modem change */
    if ( pending_event_id == QCRIL_EVT_CM_PH_OPRT_MODE )
    {
      if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_MODE_PREF, instance_id, &modem_ids_list ) == E_SUCCESS ) {
        QCRIL_LOG_DEBUG ( "%s: RID %d pending_event_id is QCRIL_EVT_CM_PH_OPRT_MODE. Update state and pending_event_id for the request.", __func__, instance_id );
        for ( i = 0; i < modem_ids_list.num_of_modems; i++ )
        {
          modem_id = modem_ids_list.modem_id[ i ];
          QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
          // Pending event and state were set only for default modem. Set for other instances too
          if ( qcril_reqlist_update_state (instance_id, modem_id, match_req_info.t, state) != E_SUCCESS )
          {
            QCRIL_LOG_DEBUG ( "%s: RID %d Unable to update state for token %d", __func__, instance_id, qcril_log_get_token_id(match_req_info.t));
          }
          if ( qcril_reqlist_update_pending_event_id (instance_id, modem_id, match_req_info.t, pending_event_id) != E_SUCCESS )
          {
            QCRIL_LOG_DEBUG ( "%s: RID %d Unable to update pending_event_id for token %d", __func__, instance_id, qcril_log_get_token_id (match_req_info.t));
          }
        }
      }
    }

    qcril_process_radio_power_request ( instance_id, modem_ids_list, slot_ids_list, match_req_info );
  }
  QCRIL_LOG_DEBUG("%s Exit", __func__);
}

/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_radio_power

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_RADIO_POWER.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_radio_power
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  uint8 i, j;
  int slot;
  uint32 user_data;
  int *in_data_ptr;
  qcril_reqlist_u_type u_info;
  qcril_cm_req_info_type *req_info_ptr = &u_info.cm.info;
  qcril_reqlist_public_type match_req_info;
  qcril_reqlist_public_type reqlist_entry;
  char *mode_name = NULL;
  qcril_req_state_e_type req_state;
  qcril_evt_e_type pending_event_id;
  qcril_slot_ids_list_type slot_ids_list;
  IxErrnoType err_no;
  qcril_request_resp_params_type resp;
  char details1[ 40 ], details2[ 40 ];
  qcril_flow_control_e_type req_type;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (int *)params_ptr->data;
  QCRIL_ASSERT( in_data_ptr );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Since RIL_REQUEST_RADIO_POWER received, need to check operating mode before process PBM event */
  qcril_pbm_enable_oprt_mode_check( instance_id, modem_id );

  /* Invalid parameters, send RIL_E_GENERIC_FAILURE response */
  if ( params_ptr->datalen == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Lookup modem to service the request */
  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_MODE_PREF, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  if ( ( *in_data_ptr == QCRIL_CM_RADIO_POWER_MODE_LPM ) && ( num_radio_off_req == MAX_QUEUED_REQUESTS - 1 ) )
  {
    QCRIL_LOG_DEBUG ( "RID %d qcril_cm_phonesvc_request_radio_power Exceeded MAX requests! Return failure.", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  if ( ( *in_data_ptr == QCRIL_CM_RADIO_POWER_MODE_ONLINE ) && ( num_radio_on_req  ==  MAX_QUEUED_REQUESTS - 1 ) )
  {
    QCRIL_LOG_DEBUG ( "RID %d qcril_cm_phonesvc_request_radio_power Exceeded MAX requests! Return failure.", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_SNPRINTF( details1, sizeof( details1 ), "cm_info[%d].ph_info_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details1 );

  QCRIL_SNPRINTF( details2, sizeof( details2 ), "cm_info[%d].card_info_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->card_info_mutex, details2 );


  QCRIL_LOG_DEBUG ( "RID %d qcril_cm_phonesvc_request_radio_power in_data %d", instance_id, *in_data_ptr);
  req_type = qcril_flow_control_radio_power(instance_id, modem_id, in_data_ptr, params_ptr->t, params_ptr->event_id);
  QCRIL_LOG_DEBUG ( "%s: RID %d req_type = %d", __func__, instance_id, (int) req_type);

  if ( qcril_arb_ma_is_dsds() && ( req_type != DUP_REQUEST ) )
  {
    // Request is a duplicate and already bundled. Just return!
    if (req_type == BINDED_DUP_REQUEST) {
      QCRIL_LOG_DEBUG("%s: RID %d Request is duplicate and already bundled..return", __func__, instance_id);
      QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details2 );
      QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details1 );
      return;
    }

    /* There is pending RIL_REQUEST_RADIO_POWER on another instance */
    if ( qcril_reqlist_query_by_request( QCRIL_DSDS_INSTANCE_PAIR( instance_id ), RIL_REQUEST_RADIO_POWER, 
                                         &match_req_info ) == E_SUCCESS ) 
    {
      /* Add entry to ReqList */
      qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, 
                                   QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS, 
                                   QCRIL_EVT_CM_PH_OPRT_MODE, NULL, &reqlist_entry ); 
      reqlist_entry.sub = match_req_info.sub;
      reqlist_entry.sub.cm.info.radio_mode.is_command_instance = FALSE;
      reqlist_entry.valid_sub_id = TRUE;
      reqlist_entry.sub_id = match_req_info.req_id;

      if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
      {
        /* Fail to add entry to ReqList */
        QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details2 );
        QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details1 );
        return;
      }

      if ( qcril_reqlist_update_sub_id( QCRIL_DSDS_INSTANCE_PAIR( instance_id ), match_req_info.t, 
                                        reqlist_entry.req_id ) != E_SUCCESS ) 
      {
        QCRIL_LOG_ERROR( "Fail to bundle RIL_REQUEST_RADIO_POWER token %d with token %d\n", 
                         qcril_log_get_token_id( match_req_info.t ), qcril_log_get_token_id( params_ptr->t ) );
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details1 );
        QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details2 );
        return;
      }
      else
      {
        QCRIL_LOG_DEBUG( "Bundle RIL_REQUEST_RADIO_POWER token %d with token %d\n", qcril_log_get_token_id( match_req_info.t ), 
                         qcril_log_get_token_id( params_ptr->t ) );
        QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details1 );
        QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details2 );
        return;
      }
    }
  }

  switch ( *in_data_ptr )
  {
    case QCRIL_CM_RADIO_POWER_MODE_LPM:
      QCRIL_LOG_DEBUG( "RID %d Request Radio LPM, APM_SIM_NOT_PWDN=%d\n", instance_id, i_ptr->apm_sim_not_pwdn );
      mode_name = "LPM";
      req_info_ptr->radio_mode.is_command_instance = TRUE;
      req_info_ptr->radio_mode.oprt_mode = SYS_OPRT_MODE_LPM;
      req_state = QCRIL_REQ_AWAITING_CALLBACK;
      pending_event_id = QCRIL_EVT_CM_PH_OPRT_MODE;
      break;

    case QCRIL_CM_RADIO_POWER_MODE_ONLINE:
      QCRIL_LOG_DEBUG( "RID %d Request Radio On, APM_SIM_NOT_PWDN=%d\n", instance_id, i_ptr->apm_sim_not_pwdn );
      mode_name = "Online";
      req_info_ptr->radio_mode.is_command_instance = TRUE;
      req_info_ptr->radio_mode.oprt_mode = SYS_OPRT_MODE_ONLINE;

      // The state and event will be set later for duplicate request.
      if (req_type != DUP_REQUEST)
      {
        /* Card status in DOWN, need to power up the card */
        if ( !i_ptr->apm_sim_not_pwdn && qcril_cm_card_status_is_down( instance_id, &slot_ids_list ) )
        {
          /* Radio Power (on), first request Card PowerUp before switching to Online mode. This is done to get SIM/RUIM ready
          in time as close as it can be by the time of Radio State change back to ON. */
          req_state = QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS;
          pending_event_id = QCRIL_EVT_CM_CARD_STATUS_UPDATED;
        }
        /* Card status in UP */
        else
        {
          req_state = QCRIL_REQ_AWAITING_CALLBACK;
          /* Simply switch to ONLINE mode */
          pending_event_id = QCRIL_EVT_CM_PH_OPRT_MODE;
        }
      }
      else
      {
        // This is a duplicate request. This will be reset once the request is considered for processing.
        pending_event_id = QCRIL_REQ_FREE;
      }
      break;

    case QCRIL_CM_RADIO_POWER_MODE_OFF:
      QCRIL_LOG_DEBUG( "RID %d Request Radio Power Off, APM_SIM_NOT_PWDN=%d\n", instance_id, i_ptr->apm_sim_not_pwdn );
      mode_name = "Power Off";
      req_info_ptr->radio_mode.is_command_instance = TRUE;
      req_info_ptr->radio_mode.oprt_mode = SYS_OPRT_MODE_PWROFF;
      req_state = QCRIL_REQ_AWAITING_CALLBACK;
      pending_event_id = QCRIL_EVT_CM_PH_OPRT_MODE;
      break;

    default:
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
      QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details2 );
      QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details1 );
      return;
  }

  // Set the state as BLOCKED for duplicate request.
  if (req_type == DUP_REQUEST)
  {
    QCRIL_LOG_DEBUG( "%s: RID %d It's a duplicate request. Set the state to BLOCKED.", __func__, instance_id);
    req_state = QCRIL_REQ_BLOCKED;
  }

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_FREE, QCRIL_EVT_NONE, 
                               &u_info, &reqlist_entry ); 


  /* Only one modem need to request for card powerup */
  if ( pending_event_id == QCRIL_EVT_CM_CARD_STATUS_UPDATED )
  {
    reqlist_entry.state[ QCRIL_DEFAULT_MODEM_ID ] = req_state;
    reqlist_entry.pending_event_id[ QCRIL_DEFAULT_MODEM_ID ] = pending_event_id;
  }
  else
  {
    /* Multiple modems may need to request for operating modem change */
    for ( i = 0; i < modem_ids_list.num_of_modems; i++ )
    {
      j = modem_ids_list.modem_id[ i ];
      QCRIL_LOG_DEBUG( "MID %d curr oprt_mode %d exp oprt_mode %d\n", j, i_ptr->ph_info[ j ].oprt_mode,
                       req_info_ptr->radio_mode.oprt_mode );
      reqlist_entry.state[ j ] = req_state;
      reqlist_entry.pending_event_id[ j ] = pending_event_id;
    }
  }

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    QCRIL_LOG_DEBUG( "RID %d Failed to add request!!", instance_id );
    QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details2 );
    QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details1 );
    return;
  }

  if ( *in_data_ptr == QCRIL_CM_RADIO_POWER_MODE_ONLINE)
  {
    radio_on_req[num_radio_on_req] = reqlist_entry.req_id;
    num_radio_on_req++;
    QCRIL_LOG_DEBUG( "Updated num_radio_on_req = %d reqid = %d", num_radio_on_req, reqlist_entry.req_id);
  }
  else {
    radio_off_req[num_radio_off_req] = reqlist_entry.req_id;
    num_radio_off_req++;
    QCRIL_LOG_DEBUG( "Updated num_radio_off_req = %d reqid = %d", num_radio_off_req, reqlist_entry.req_id);
  }

  if ( req_state == QCRIL_REQ_BLOCKED )
  {
    QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details2 );
    QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details1 );
    QCRIL_LOG_DEBUG( "%s: RID %d Blocked request..return!", __func__, instance_id);
    return;
  }

  QCRIL_LOG_DEBUG( "RID %d calling qcril_process_radio_power_request pending_event_id %d token %d oprt_mode %d", instance_id, pending_event_id, qcril_log_get_token_id(reqlist_entry.t), reqlist_entry.sub.cm.info.radio_mode.oprt_mode);
  qcril_process_radio_power_request ( instance_id, modem_ids_list, slot_ids_list, reqlist_entry );

  QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details2 );
  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details1 );

} /* qcril_cm_phonesvc_request_radio_power() */



#ifdef FEATURE_QCRIL_DSDS
/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_set_subscription_mode

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_SUBSCRIPTION_MODE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_set_subscription_mode
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  int *subscription_mode_ptr;
  sys_modem_dual_standby_pref_e_type standby_pref;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  uint32 user_data;
  char details[ 80 ];
  boolean tune_away;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  subscription_mode_ptr = (int *) params_ptr->data;
  QCRIL_ASSERT( subscription_mode_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Check whether the request is valid */
  if ( !qcril_arb_ma_is_dsds() )
  {
    QCRIL_LOG_DEBUG( "RID %d non-DSDS, RIL_REQUEST_SET_SUBSCRIPTION_MODE not supported\n", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, 
                                       RIL_E_REQUEST_NOT_SUPPORTED, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );

  standby_pref = i_ptr->ph_info[ modem_id ].standby_pref;

  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );
 
  QCRIL_LOG_DEBUG( "Subscription mode %d\n", *subscription_mode_ptr );

  if ( *subscription_mode_ptr == 1 ) 
  {
    if ( standby_pref == SYS_MODEM_DS_PREF_SINGLE_STANDBY ) 
    {
      QCRIL_LOG_DEBUG( "Subscription mode %d, already in single standby\n", *subscription_mode_ptr );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
      qcril_send_request_response( &resp );
      return;
    }
    else
    {
      QCRIL_LOG_DEBUG( "Subscription mode %d, change to single standby\n", *subscription_mode_ptr );
      standby_pref = SYS_MODEM_DS_PREF_SINGLE_STANDBY;
    }
  }
  else
  {
    QCRIL_LOG_DEBUG( "Subscription mode %d, already in %s\n", *subscription_mode_ptr, QCRIL_CM_DUAL_STANDBY_PREF_NAME(standby_pref) );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_PH_DUAL_STANDBY_PREF, NULL, &reqlist_entry ); 
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /* Command CM to change default data subscription */
  QCRIL_SNPRINTF( details, sizeof( details ), "Standby preference %s", "Single Standby" );
  QCRIL_LOG_DEBUG( "RID %d MID %d %s\n", details ); 

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_dual_standby_pref()", details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_dual_standby_pref_func( qcril_cm_phonesvc_command_callback,
                                                                         (void *) user_data,
                                                                         i_ptr->client_info[ modem_id ].client_id,
                                                                         standby_pref,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, reqlist_entry.t, reqlist_entry.request, 
                                       RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_phonesvc_request_set_subscription_mode */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_set_uicc_subscription

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_UICC_SUBSCRIPTION.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_set_uicc_subscription
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_arb_subs_prov_status_e_type subs_state;
  RIL_SelectUiccSub original_uicc_sub;
  qmi_uim_session_type session_type;
  RIL_SelectUiccSub *select_uicc_sub_ptr;
  qcril_cm_struct_type *i_ptr;   
  qcril_evt_e_type pending_event_id;
  qcril_req_state_e_type pending_state;
  qcril_reqlist_u_type u_info;
  uint32 user_data;
  qcril_cm_req_info_type *req_info_ptr = &u_info.cm.info;
  qcril_reqlist_public_type reqlist_entry;
  boolean standby_pref_changed = FALSE;
  IxErrnoType err_no;
  qcril_request_resp_params_type resp;
  nv_stat_enum_type nv_status = NV_FAIL_S;
  sys_modem_as_id_e_type as_id;
  nv_item_type nv_item;
  qcril_subs_mode_pref mode_pref;
  qcril_uicc_subs_info_type subs_info;
  char *nv_cmd_api_name = "nv_cmd_ext_remote()";

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  select_uicc_sub_ptr = (RIL_SelectUiccSub *) params_ptr->data;
  QCRIL_ASSERT( select_uicc_sub_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Check whether the request is valid */
  if ( !qcril_arb_ma_is_dsds() )
  {
    QCRIL_LOG_DEBUG( "RID %d non-DSDS, RIL_REQUEST_SET_UICC_SUBSCRIPTION not supported\n", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, 
                                       RIL_E_REQUEST_NOT_SUPPORTED, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_LOG_DEBUG( "%d\n", select_uicc_sub_ptr->act_status );
  
  /* Check whether there is any change in UICC subscription */
  qcril_arb_query_subs( instance_id, &subs_state, &original_uicc_sub, &as_id, &session_type );
  if ( ( select_uicc_sub_ptr->act_status == RIL_UICC_SUBSCRIPTION_ACTIVATE ) && 
       ( subs_state == QCRIL_ARB_SUBS_PROVISIONED ) &&
       ( select_uicc_sub_ptr->act_status == original_uicc_sub.act_status ) &&
       ( select_uicc_sub_ptr->slot == original_uicc_sub.slot ) &&
       ( select_uicc_sub_ptr->app_index == original_uicc_sub.app_index ) &&
       ( select_uicc_sub_ptr->act_status == original_uicc_sub.act_status ) )
  {
    QCRIL_LOG_DEBUG( "RID %d No change in uicc subscription, slot %d, app_index %d, act_status %d\n",
                     instance_id, select_uicc_sub_ptr->slot, select_uicc_sub_ptr->app_index, select_uicc_sub_ptr->act_status );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  else if ( ( select_uicc_sub_ptr->act_status == RIL_UICC_SUBSCRIPTION_DEACTIVATE ) &&
            ( subs_state == QCRIL_ARB_SUBS_NOT_PROVISIONED ) )
  {
    QCRIL_LOG_DEBUG( "RID %d Subscription already deactivated\n", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  
  if ( select_uicc_sub_ptr->act_status == RIL_UICC_SUBSCRIPTION_ACTIVATE )
  {
    QCRIL_LOG_DEBUG( "RID %d Activate sub: slot %d app_index %d\n", instance_id, select_uicc_sub_ptr->slot, 
                     select_uicc_sub_ptr->app_index );
    pending_event_id = QCRIL_EVT_CM_ACTIVATE_PROVISION_STATUS; 
    pending_state = QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS;
  }
  else
  {
    QCRIL_LOG_DEBUG( "RID %d Deactivate sub: slot %d app_index %d\n", instance_id, select_uicc_sub_ptr->slot, 
                     select_uicc_sub_ptr->app_index );
    pending_event_id = QCRIL_EVT_CM_DEACTIVATE_PROVISION_STATUS; 
    pending_state = QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS;
  }

  /* Add entry to ReqList */
  memcpy( &req_info_ptr->select_uicc_sub, select_uicc_sub_ptr, sizeof( RIL_SelectUiccSub ) );
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, pending_state, pending_event_id, &u_info, 
                               &reqlist_entry ); 

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /*  Subscription ID selected from UI is tied to the NV items,
      i.e. RIL_SUBSCRIPTION_1(first subscription) will refer to first set of NV items though SYS_MODEM_AS_ID_1, and
           RIL_SUBSCRIPTION_2(second subscription) will refter to second set of NV items though SYS_MODEM_AS_ID_2,
      We(UIM) also check whether the value in NV item NV_PREF_MODE_I  is compatible with the APP type selected on the
      corresponding subscription, and reject if they are not compatible */
  as_id = ( select_uicc_sub_ptr->sub_type == RIL_SUBSCRIPTION_1 ) ? SYS_MODEM_AS_ID_1 : SYS_MODEM_AS_ID_2;

  QCRIL_LOG_DEBUG( "sub_type =%d, as_id value = %d\n", select_uicc_sub_ptr->sub_type, as_id);

  nv_item.pref_mode.nam = 0;
  QCRIL_LOG_RPC2A( modem_id, nv_cmd_api_name, "read NV_PREF_MODE_I" );
  nv_status = qcril_other_api_funcs[ modem_id ].nv_cmd_remote_func( NV_READ_F, NV_PREF_MODE_I, (nv_item_type *) &nv_item
                                                                    #ifdef FEATURE_QCRIL_DSDS
                                                                    , as_id
                                                                    #endif /* FEATURE_QCRIL_DSDS */
                                                                  );
  QCRIL_LOG_DEBUG( "nv_status value = %d\n", nv_status);
  if ( ( nv_status != NV_DONE_S ) && ( nv_status != NV_NOTACTIVE_S ) )
  {
     QCRIL_LOG_ERROR( "%s", "Reading mode preference from NV NV_PREF_MODE_I failed.\n" );
     qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
     qcril_send_request_response( &resp );
     return;
  }

  if ( !qcril_cm_util_subs_mode_pref( ( qcril_cm_mode_pref_e_type ) nv_item.pref_mode.mode, &mode_pref ) )
  {
    QCRIL_LOG_ERROR( "%s", "Incompatible mode preference selected in NV item NV_PREF_MODE_I\n" );
    QCRIL_LOG_ERROR( "%s", "Please change the NV item NV_PREF_MODE_I or Select compatible APP on UI\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUBSCRIPTION_NOT_SUPPORTED, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  memcpy( &subs_info.uicc_subs_info, select_uicc_sub_ptr, sizeof( RIL_SelectUiccSub ) );
  subs_info.subs_mode_pref = mode_pref;

  if ( select_uicc_sub_ptr->act_status == RIL_UICC_SUBSCRIPTION_ACTIVATE )
  {
    QCRIL_LOG_DEBUG( "Request QCRIL(UIM) to activate slot %d aid %d\n", select_uicc_sub_ptr->slot, select_uicc_sub_ptr->app_index );
    err_no = qcril_process_event( instance_id, modem_id, QCRIL_EVT_INTERNAL_MMGSDI_ACTIVATE_SUBS, 
                                  (void *) &subs_info, sizeof( qcril_uicc_subs_info_type ),
                                  (RIL_Token) QCRIL_TOKEN_ID_INTERNAL ); 
    QCRIL_ASSERT( err_no == E_SUCCESS );
  }
  else
  {
    QCRIL_LOG_DEBUG( "Request QCRIL(UIM) to deactivate slot %d aid %d\n", select_uicc_sub_ptr->slot, 
                     select_uicc_sub_ptr->app_index );
    err_no = qcril_process_event( instance_id, modem_id, QCRIL_EVT_INTERNAL_MMGSDI_DEACTIVATE_SUBS, 
                                  (void *) &subs_info, sizeof( qcril_uicc_subs_info_type ),
                                  (RIL_Token) QCRIL_TOKEN_ID_INTERNAL ); 
    QCRIL_ASSERT( err_no == E_SUCCESS );
  }

} /* qcril_cm_phonesvc_request_set_uicc_subscription */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_get_uicc_subscription

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_GET_UICC_SUBSCRIPTION.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_get_uicc_subscription
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_arb_subs_prov_status_e_type subs_state;
  RIL_SelectUiccSub uicc_sub;
  sys_modem_as_id_e_type as_id;
  qmi_uim_session_type session_type;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Check whether the request is valid */
  if ( !qcril_arb_ma_is_dsds() )
  {
    QCRIL_LOG_DEBUG( "RID %d non-DSDS, RIL_REQUEST_GET_UICC_SUBSCRIPTION not supported\n", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, 
                                       RIL_E_REQUEST_NOT_SUPPORTED, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  qcril_arb_query_subs( instance_id, &subs_state, &uicc_sub, &as_id, &session_type );
  if ( subs_state == QCRIL_ARB_SUBS_NOT_PROVISIONED )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUBSCRIPTION_NOT_AVAILABLE, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> slot %d app_index %d act_status %d\n", uicc_sub.slot, uicc_sub.app_index, uicc_sub.act_status );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    resp.resp_pkt = (void *) &uicc_sub;
    resp.resp_len = sizeof( uicc_sub );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_phonesvc_request_get_uicc_subscription */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_set_data_subscription

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_DATA_SUBSCRIPTION.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_set_data_subscription
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;   
  uint32 user_data;
  qcril_reqlist_public_type reqlist_entry;
  sys_modem_as_id_e_type default_data_subs, as_id;
  qcril_request_resp_params_type resp;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Check whether the request is valid */
  if ( !qcril_arb_ma_is_dsds() )
  {
    QCRIL_LOG_DEBUG( "RID %d non-DSDS, RIL_REQUEST_SET_DATA_SUBSCRIPTION not supported\n", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, 
                                       RIL_E_REQUEST_NOT_SUPPORTED, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );
  default_data_subs = i_ptr->ph_info[ modem_id ].default_data_subs;
  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                 QCRIL_EVT_CM_PH_DUAL_STANDBY_PREF, NULL, &reqlist_entry ); 

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
     /* Fail to add entry to ReqList */
     return;
  }

  /* Command CM to change default data subscription */
  QCRIL_SNPRINTF( details, sizeof( details ), "Default data subscription %d", as_id ); 
  QCRIL_LOG_DEBUG( "RID %d MID %d %s\n", details ); 

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_dual_standby_pref()", details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_dual_standby_pref_func( qcril_cm_phonesvc_command_callback,
                                                                         (void *) user_data,
                                                                         i_ptr->client_info[ modem_id ].client_id,
                                                                         SYS_MODEM_DS_PREF_NO_CHANGE,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE,
                                                                         as_id,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, reqlist_entry.t, reqlist_entry.request, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }


} /* qcril_cm_phonesvc_request_set_data_subscription */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_get_data_subscription

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_GET_DATA_SUBSCRIPTION.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_get_data_subscription
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id, data_instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;   
  sys_modem_as_id_e_type default_data_subs;
  int sub_id;
  qcril_request_resp_params_type resp;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Check whether the request is valid */
  if ( !qcril_arb_ma_is_dsds() )
  {
    QCRIL_LOG_DEBUG( "RID %d non-DSDS, RIL_REQUEST_GET_DATA_SUBSCRIPTION not supported\n", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, 
                                       RIL_E_REQUEST_NOT_SUPPORTED, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );
  default_data_subs = i_ptr->ph_info[ modem_id ].default_data_subs;
  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

  /* Lookup RIL instance that is provisioned with data subscription */
  if ( qcril_arb_lookup_instance_id_from_as_id( default_data_subs, &data_instance_id ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }
  else 
  {
    /* Android Telephony Sub ID is RIL's Instance ID+1*/
    sub_id = data_instance_id + 1;
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    resp.resp_pkt = (void *) &sub_id;
    resp.resp_len = sizeof( sub_id );
    qcril_send_request_response( &resp );
  }
} /* qcril_cm_phonesvc_request_get_data_subscription */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_set_tune_away

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_HOOK_SET_TUNE_AWAY.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_set_tune_away

(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_request_resp_params_type resp;
  char details[ 40 ];
  boolean tune_away, stored_tune_away;
  qcril_reqlist_public_type reqlist_entry;
  sys_modem_dual_standby_pref_e_type standby_pref;
  char property_name[ 40 ];
  char args[ PROPERTY_VALUE_MAX ];
  uint32 user_data;
  sys_modem_as_id_e_type  as_id;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  /* Check whether the request is valid */
  if ( !qcril_arb_ma_is_dsds() )
  {
    QCRIL_LOG_DEBUG( "RID %d non-DSDS, QCRIL_EVT_HOOK_SET_TUNE_AWAY not supported\n", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id,
                                       RIL_E_REQUEST_NOT_SUPPORTED, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  memcpy(&tune_away, params_ptr->data, params_ptr->datalen);
  QCRIL_LOG_DEBUG("tune away preferences received = %d \n", tune_away);

  if( (tune_away != TRUE) && (tune_away != FALSE) )
  {
    QCRIL_LOG_DEBUG( "RID %d received invalid value for tune away preference = %d \n", tune_away );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );
  stored_tune_away = i_ptr->ph_info[ modem_id ].tune_away;
  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

  if(stored_tune_away == tune_away)
  {
    QCRIL_LOG_DEBUG( "RID %d no change in QCRIL_EVT_HOOK_SET_TUNE_AWAY preferences \n", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  standby_pref = i_ptr->ph_info[ modem_id ].standby_pref;

  if( ( tune_away == TRUE ) && (standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY) )
  {
    standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY;
  }
  else if( ( tune_away == FALSE ) && (standby_pref == SYS_MODEM_DS_PREF_DUAL_STANDBY) )
  {
    standby_pref = SYS_MODEM_DS_PREF_DUAL_STANDBY_NO_TUNEAWAY;
  }
  else
  {
     QCRIL_LOG_DEBUG( "RID %d cannot change CM_EVT_HOOK_TUNE_AWAY preferences now due to incompatible DSDS pref,\n", instance_id );
     QCRIL_LOG_DEBUG("%s \n", "or modem is already in requested preference, storing in system prop for using it later on");
     QCRIL_LOG_DEBUG("modem standby preference = %s \n", QCRIL_CM_DUAL_STANDBY_PREF_NAME(i_ptr->ph_info[ modem_id ].standby_pref));

     i_ptr->ph_info[modem_id].tune_away = tune_away;
     /* update the other instance */
     qcril_cm[QCRIL_DSDS_INSTANCE_PAIR(instance_id)].ph_info[modem_id].tune_away = i_ptr->ph_info[ modem_id ].tune_away;

     QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_TUNE_AWAY);

     /* Save TUNE AWAY setting to system property */
     QCRIL_SNPRINTF( args, sizeof( args ), "%d", tune_away);
     if ( property_set( property_name, args ) != E_SUCCESS )
     {
       QCRIL_LOG_ERROR( "RID %d Fail to save %s to system property\n", instance_id, QCRIL_TUNE_AWAY );
     }

     qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
     qcril_send_request_response( &resp );
     return;
  }

  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_CM_PH_DUAL_STANDBY_PREF, NULL, &reqlist_entry );

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Command CM to change to tun away preferences */
  QCRIL_LOG_DEBUG( "RID %d MID %d Change to standby pref %d - %s\n", instance_id, modem_id, standby_pref, QCRIL_CM_DUAL_STANDBY_PREF_NAME(standby_pref) );
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_dual_standby_pref()", QCRIL_CM_DUAL_STANDBY_PREF_NAME(standby_pref) );

  if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_dual_standby_pref_func( qcril_cm_phonesvc_command_callback,
                                                                         (void *) user_data,
                                                                         i_ptr->client_info[ modem_id ].client_id,
                                                                         standby_pref,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, reqlist_entry.t, reqlist_entry.request, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_phonesvc_request_set_tune_away */

/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_get_tune_away

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_HOOK_GET_TUNE_AWAY.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_get_tune_away

(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_request_resp_params_type resp;
  boolean tune_away;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  /* Check whether the request is valid */
  if ( !qcril_arb_ma_is_dsds() )
  {
    QCRIL_LOG_DEBUG( "RID %d non-DSDS, QCRIL_EVT_HOOK_GET_TUNE_AWAY not supported\n", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id,
                                       RIL_E_REQUEST_NOT_SUPPORTED, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  tune_away = i_ptr->ph_info[modem_id].tune_away;

  QCRIL_LOG_DEBUG( "RID %d stored tune away preferences = %d\n", instance_id, tune_away);
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
  resp.resp_pkt = &tune_away;
  resp.resp_len = sizeof(tune_away);
  qcril_send_request_response( &resp );

} /*qcril_cm_phonesvc_request_get_tune_away*/


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_set_paging_priority

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_HOOK_SET_PAGING_PRIORITY.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_set_paging_priority

(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_request_resp_params_type resp;
  char details[ 40 ];
  int new_paging_priority;
  RIL_SubscriptionType stored_paging_priority;
  qcril_reqlist_public_type reqlist_entry;
  sys_modem_dual_standby_pref_e_type standby_pref;
  char property_name[ 40 ];
  char args[ PROPERTY_VALUE_MAX ];
  uint32 user_data;
  sys_modem_as_id_e_type  as_id;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  /* Check whether the request is valid */
  if ( !qcril_arb_ma_is_dsds() )
  {
    QCRIL_LOG_DEBUG( "RID %d non-DSDS, QCRIL_EVT_HOOK_SET_PAGING_PRIORITY not supported\n", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id,
                                       RIL_E_REQUEST_NOT_SUPPORTED, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  memset( &new_paging_priority, 0, sizeof( new_paging_priority ) );
  memcpy(&new_paging_priority, params_ptr->data, params_ptr->datalen);
  QCRIL_LOG_DEBUG("paging priority preference received = %d  data_len = %d\n", new_paging_priority, params_ptr->datalen);

  if ( ( new_paging_priority > RIL_SUBSCRIPTION_2 ) && ( new_paging_priority < RIL_SUBSCRIPTION_1 ) )
  {
    QCRIL_LOG_DEBUG( "RID %d received invalid value for paging priority preference = %d \n", new_paging_priority );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );
  stored_paging_priority = i_ptr->ph_info[ modem_id ].paging_priority;
  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

  if ( (RIL_SubscriptionType) new_paging_priority == stored_paging_priority )
  {
    QCRIL_LOG_DEBUG( "RID %d no change in QCRIL_EVT_HOOK_SET_PAGING_PRIORITY preference \n", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  standby_pref = i_ptr->ph_info[ modem_id ].standby_pref;

  if ( standby_pref == SYS_MODEM_DS_PREF_SINGLE_STANDBY )
  {
     QCRIL_LOG_DEBUG( "RID %d cannot change PAGING_PRIORITY preference now due to incompatible DSDS pref = %s,\n",
                                       instance_id, QCRIL_CM_DUAL_STANDBY_PREF_NAME(standby_pref) );
     QCRIL_LOG_DEBUG("%s \n", "storing in system prop for using it later on");

     i_ptr->ph_info[modem_id].paging_priority = new_paging_priority;
     /* update the other instance */
     qcril_cm[QCRIL_DSDS_INSTANCE_PAIR(instance_id)].ph_info[modem_id].paging_priority = i_ptr->ph_info[ modem_id ].paging_priority;

     QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_PAGING_PRIORITY);

     /* Save PAGING PRIORITY preference to system property */
     QCRIL_SNPRINTF( args, sizeof( args ), "%d", new_paging_priority);
     if ( property_set( property_name, args ) != E_SUCCESS )
     {
       QCRIL_LOG_ERROR( "RID %d Fail to save %s to system property\n", instance_id, QCRIL_PAGING_PRIORITY );
     }

     qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
     qcril_send_request_response( &resp );
     return;
  }

  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK,
                                 QCRIL_EVT_CM_PH_DUAL_STANDBY_PREF, NULL, &reqlist_entry );

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  as_id = ( new_paging_priority ) ? SYS_MODEM_AS_ID_2: SYS_MODEM_AS_ID_1;

  /* Command CM to change the paging priority preference */
  QCRIL_LOG_DEBUG( "RID %d MID %d changing paging priorty to %d\n", instance_id, modem_id, new_paging_priority );
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_dual_standby_pref()", QCRIL_CM_DUAL_STANDBY_PREF_NAME(standby_pref) );

  if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_dual_standby_pref_func( qcril_cm_phonesvc_command_callback,
                                                                         (void *) user_data,
                                                                         i_ptr->client_info[ modem_id ].client_id,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE,
                                                                         SYS_MODEM_AS_ID_NO_CHANGE,
                                                                         as_id ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, reqlist_entry.t, reqlist_entry.request, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_phonesvc_request_set_paging_priority */

/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_get_paging_priority

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_HOOK_GET_PAGING_PRIORITY.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_get_paging_priority

(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_request_resp_params_type resp;
  RIL_SubscriptionType paging_priority;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );
  /*-----------------------------------------------------------------------*/

  /* Check whether the request is valid */
  if ( !qcril_arb_ma_is_dsds() )
  {
    QCRIL_LOG_DEBUG( "RID %d non-DSDS, QCRIL_EVT_HOOK_GET_PAGING_PRIORITY not supported\n", instance_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id,
                                       RIL_E_REQUEST_NOT_SUPPORTED, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  paging_priority = i_ptr->ph_info[modem_id].paging_priority;

  QCRIL_LOG_DEBUG( "RID %d stored paging priority preference = %d\n", instance_id, paging_priority );
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
  resp.resp_pkt = &paging_priority;
  resp.resp_len = sizeof(boolean);
  qcril_send_request_response( &resp );

} /*qcril_cm_phonesvc_request_get_paging_priority*/

#endif /* FEATURE_QCRIL_DSDS*/

#ifdef FEATURE_QCRIL_SAR

/*===========================================================================

  FUNCTION: qcril_sar_request_set_transmit_power

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_TRANSMIT_POWER.

    @return
    None.
*/
/*=========================================================================*/
void qcril_sar_request_set_transmit_power

(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_request_resp_params_type resp;
  int *in_data_ptr;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  in_data_ptr = (int *)params_ptr->data;
  QCRIL_ASSERT( in_data_ptr );

  /*-----------------------------------------------------------------------*/

  if (*in_data_ptr == RF_SAR_STATE_DEFAULT)
  {
      rfm_sar_set_state(RF_SAR_STATE_DEFAULT);
      QCRIL_LOG_DEBUG( "RID %d sar_state set to RF_SAR_STATE_DEFAULT\n", instance_id );
  }
  else if (*in_data_ptr == RF_SAR_STATE_1)
  {
      rfm_sar_set_state(RF_SAR_STATE_1);
      QCRIL_LOG_DEBUG( "RID %d sar_state set to RF_SAR_STATE_1\n", instance_id );
  }
  else
  {
      // Should not come here, as per ril.h RIL_REQUEST_TRANSMIT_POWER should
      // send either 0 (RF_SAR_STATE_DEFAULT) or 1 (RF_SAR_STATE_1).
      QCRIL_LOG_DEBUG( "RID %d Ignore invalid input %d\n", instance_id, *in_data_ptr );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id,
            RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
  }

  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
  qcril_send_request_response( &resp );

} /*qcril_sar_request_set_transmit_power*/

#endif /* FEATURE_QCRIL_SAR */



/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_cdma_set_roaming_preference

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_cdma_set_roaming_preference
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{  
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  uint8 i;
  uint32 user_data;
  int *in_data_ptr;
  qcril_reqlist_u_type u_info;
  qcril_cm_req_info_type *req_info_ptr = &u_info.cm.info;
  qcril_reqlist_public_type reqlist_entry;
  char *roam_pref_name = NULL;
  char details[ 80 ];
  qcril_request_resp_params_type resp;
  boolean net_pref_restored;
  qcril_cm_net_pref_e_type net_pref;
  qcril_arb_ma_e_type ma;
  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref_per_subs()";
  #else
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (int *)params_ptr->data;
  QCRIL_ASSERT( in_data_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Verify the parameters are valid */
  if ( params_ptr->datalen == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  switch ( *in_data_ptr )
  {
    case QCRIL_CM_ROAMING_PREF_HOME_NETWORK_ONLY:
      req_info_ptr->roam_pref = CM_ROAM_PREF_HOME;
      roam_pref_name = "Home Only";
      break;

    case QCRIL_CM_ROAMING_PREF_AFFILIATED_NETWORK_ONLY:
      req_info_ptr->roam_pref = CM_ROAM_PREF_AFFIL;
      roam_pref_name = "Affiliated Only";
      break;

    case QCRIL_CM_ROAMING_PREF_ANY_NETWORK:
      req_info_ptr->roam_pref = CM_ROAM_PREF_ANY;
      roam_pref_name = "Any Network";
      break;

    default:
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
      return;

  } /* end switch */

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_COMMON, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* allow only when the nework preference is compatible */
  /* Query stored network preference */
  qcril_arb_query_net_pref( instance_id, &net_pref_restored, &net_pref, &ma );

  if( !QCRIL_CM_NET_PREF_INDICATES_1XEVDO(net_pref) )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, 0, QCRIL_REQ_FREE, QCRIL_EVT_NONE, &u_info, &reqlist_entry ); 
  for ( modem_id = 0; modem_id < modem_ids_list.num_of_modems; modem_id++ )
  {
    reqlist_entry.state[ modem_id ] = QCRIL_REQ_AWAITING_CALLBACK; 
    reqlist_entry.pending_event_id[ modem_id ] = QCRIL_EVT_CM_PH_SYS_SEL_PREF; 
  }

  /* Add entry to ReqList */
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /* Command CM to change the phone's system selection preference on network type */
  for ( i = 0; i < modem_ids_list.num_of_modems; i++ )
  { 
    modem_id = modem_ids_list.modem_id[ i ];
    QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

    if ( reqlist_entry.state[ modem_id ] == QCRIL_REQ_AWAITING_CALLBACK )
    {
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
      QCRIL_SNPRINTF( details, sizeof( details ), "%s, Token ID %d", roam_pref_name, qcril_log_get_token_id( params_ptr->t ) );

      QCRIL_LOG_RPC2( modem_id, cm_ph_cmd_sys_sel_pref_api_name, details );
      if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_sys_sel_pref_func( qcril_cm_phonesvc_command_callback,
                                                                        (void *) user_data,
                                                                        i_ptr->client_info[ modem_id ].client_id,
                                                                        #ifdef FEATURE_QCRIL_DSDS
                                                                        as_id,
                                                                        #endif /* FEATURE_QCRIL_DSDS */
                                                                        CM_MODE_PREF_NO_CHANGE,
                                                                        CM_PREF_TERM_PERMANENT,
                                                                        0,
                                                                        CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                                        CM_BAND_PREF_NO_CHANGE,
                                                                        CM_PRL_PREF_NO_CHANGE,
                                                                        req_info_ptr->roam_pref,
                                                                        CM_HYBR_PREF_NO_CHANGE,
                                                                        CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                                        CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                                                        NULL 
                                                                        #ifndef FEATURE_QCRIL_DSDS
                                                                        , NULL
                                                                        #endif /* !FEATURE_QCRIL_DSDS */
                                                                      ) )
      {
        /* In case of ARM9 reset, the command callback will never be executed. So, need to
           delete the entry from the ReqList, and call OnRequestComplete() */
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
    }
  }

} /* qcril_cm_phonesvc_request_cdma_set_roaming_preference() */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_cdma_query_roaming_preference

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_cdma_query_roaming_preference
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  uint32 user_data;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  boolean net_pref_restored;
  qcril_cm_net_pref_e_type net_pref;
  qcril_arb_ma_e_type ma;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_get_ph_info_api_name = "cm_ph_cmd_get_ph_info_per_subs()";
  #else
  char *cm_ph_cmd_get_ph_info_api_name = "cm_ph_cmd_get_ph_info()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_COMMON, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* allow only when the network preference is compatible */
  /* Query stored network preference */
  qcril_arb_query_net_pref( instance_id, &net_pref_restored, &net_pref, &ma );

  if( !QCRIL_CM_NET_PREF_INDICATES_1XEVDO(net_pref) )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, 0, QCRIL_REQ_FREE, QCRIL_EVT_NONE, NULL, &reqlist_entry ); 

  /* Only query one modem even in case of fusion, as both the modem are in sync */
  modem_id = modem_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  reqlist_entry.state[ modem_id ] = QCRIL_REQ_AWAITING_CALLBACK; 
  reqlist_entry.pending_event_id[ modem_id ] = QCRIL_EVT_CM_PH_INFO; 

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /* Get a snapshot of the current phone information in the CM */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

  QCRIL_LOG_RPC( modem_id, cm_ph_cmd_get_ph_info_api_name, "Token ID", qcril_log_get_token_id( params_ptr->t ));
  if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_get_ph_info_func( qcril_cm_phonesvc_command_callback, 
                                                                     (void *) user_data, 
                                                                     i_ptr->client_info[ modem_id ].client_id 
                                                                     #ifdef FEATURE_QCRIL_DSDS
                                                                     , as_id
                                                                     #endif /* FEATURE_QCRIL_DSDS */
                                                                   ) )
  {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
  }

} /* qcril_cm_phonesvc_request_cdma_query_roaming_preference() */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_cdma_set_subscription_source

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_cdma_set_subscription_source
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  uint8 i;
  uint32 user_data;
  int *in_data_ptr;
  qcril_reqlist_u_type u_info;
  qcril_cm_req_info_type *req_info_ptr = &u_info.cm.info;
  qcril_reqlist_public_type reqlist_entry;
  char *rtre_config_name = NULL;
  qcril_request_resp_params_type resp;
  boolean net_pref_restored;
  qcril_cm_net_pref_e_type net_pref;
  qcril_arb_ma_e_type ma;
  #ifdef FEATURE_QCRIL_SUBS_CTRL
  uint16 subscription_disable_mask = QCRIL_MODE_1XEVDO_CONFIG_MASK;
  #endif

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (int *)params_ptr->data;
  QCRIL_ASSERT( in_data_ptr );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Verify the parameters are valid */
  if ( params_ptr->datalen == 0 )
  {
    QCRIL_LOG_ERROR( "%s", "Invalid CDMA subscription source\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  switch ( *in_data_ptr )
  {
    case QCRIL_CM_SUBSCRIPTION_PREF_RUIM:
      req_info_ptr->rtre_config = CM_RTRE_CONFIG_RUIM_ONLY;
      rtre_config_name = "RUIM Only";
      break;

    case QCRIL_CM_SUBSCRIPTION_PREF_NV:
      req_info_ptr->rtre_config = CM_RTRE_CONFIG_NV_ONLY;
      rtre_config_name = "NV Only";
      break;

    default:
      QCRIL_LOG_ERROR( "Invalid CDMA subscription source %d\n", *in_data_ptr );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
      return;

  } /* end switch */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_COMMON, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* allow only when the nework preference is compatible */
  /* Query stored network preference */
  qcril_arb_query_net_pref( instance_id, &net_pref_restored, &net_pref, &ma );

  if( !QCRIL_CM_NET_PREF_INDICATES_1XEVDO(net_pref) )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, QCRIL_DEFAULT_MODEM_ID, QCRIL_REQ_FREE, 0, &u_info, 
                               &reqlist_entry ); 
  for ( i = 0; i < modem_ids_list.num_of_modems; i++ )
  {
    modem_id = modem_ids_list.modem_id[ i ];
    reqlist_entry.state[ modem_id ] = QCRIL_REQ_AWAITING_CALLBACK;
    reqlist_entry.pending_event_id[ modem_id ] = QCRIL_EVT_CM_PH_NVRUIM_CONFIG_CHANGED;
  }

  /* Add entry to ReqList */
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  for ( i = 0; i < modem_ids_list.num_of_modems; i++ )
  {
    modem_id = modem_ids_list.modem_id[ i ];
    QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID ); 
    if ( reqlist_entry.state[ modem_id ] == QCRIL_REQ_AWAITING_CALLBACK ) 
    {
      /* Command CM to change RTRE configuration */
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
      QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_change_rtre_config()", rtre_config_name );
      if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_change_rtre_config_func( qcril_cm_phonesvc_command_callback, 
                                                                              (void *) user_data, 
                                                                              i_ptr->client_info[ modem_id ].client_id, 
                                                                              req_info_ptr->rtre_config ) )
      {
        /* In case of ARM9 reset, the command callback will never be executed. So, need to
           delete the entry from the ReqList, and call OnRequestComplete() */
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        break;
      }

      #ifdef FEATURE_QCRIL_SUBS_CTRL
      /* If moving from RUIM to NV, disable and re-enable subscription to camp back on NV network */
      if( ( req_info_ptr->rtre_config == CM_RTRE_CONFIG_NV_ONLY ) &&
          ( i_ptr->ph_info[ i ].pri_cdma_subscription_state == QCRIL_CM_SUBSCRIPTION_ENABLED ) )
      {
        user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, subscription_disable_mask );
        QCRIL_LOG_RPC2A( modem_id, "cm_ph_subscription_not_available()", "1xEvDo" );
        if( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_subscription_not_available_func( qcril_cm_phonesvc_command_callback,
                                                                                       (void *) user_data,
                                                                                       i_ptr->client_info[ modem_id ].client_id,
                                                                                       CM_SUBSCRIPTION_STATUS_CHANGE,
                                                                                       CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                                                                       CM_SUBSCRIPTION_STATUS_NO_CHANGE ) )
        {
          qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
          break;
        }
      }
      #endif
    }
  }

} /* qcril_cm_phonesvc_request_cdma_set_subscription_source() */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_cdma_get_subscription_source

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_cdma_get_subscription_source
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  int subscription_source;
  char *rtre_config_name = NULL;
  qcril_request_resp_params_type resp;
  boolean net_pref_restored;
  qcril_cm_net_pref_e_type net_pref;
  qcril_arb_ma_e_type ma;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_COMMON, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* allow only when the nework preference is compatible */
  /* Query stored network preference */
  qcril_arb_query_net_pref( instance_id, &net_pref_restored, &net_pref, &ma );

  if( !QCRIL_CM_NET_PREF_INDICATES_1XEVDO(net_pref) )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Even for split modem, it is OEM responsibility to sync the RTE control in both modems */
  modem_id = modem_ids_list.modem_id[ 0 ];

  switch ( i_ptr->ph_info[ modem_id ].rtre_control )
  {
    case CM_RTRE_CONTROL_RUIM:
      subscription_source = 0;
      rtre_config_name = "RUIM Only";
      break;

    case CM_RTRE_CONTROL_NV:
      subscription_source = 1;
      rtre_config_name = "NV Only";
      break;

    default:
      QCRIL_LOG_ERROR( "Invalid RTRE control %d\n", i_ptr->ph_info[ modem_id ].rtre_control );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
      return;
  }

  QCRIL_LOG_DEBUG( "Reply to RIL --> subscription source (%s)\n", rtre_config_name ); 
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
  resp.resp_pkt = &subscription_source;
  resp.resp_len = sizeof( subscription_source );
  qcril_send_request_response( &resp );

} /* qcril_cm_phonesvc_request_cdma_get_subscription_source() */


/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_cdma_subscription

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_SUBSCRIPTION.

    @return
    E_SUCCESS   
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_cdma_subscription
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_modem_ids_list_type modem_ids_list;
  qcril_other_cdma_subscription_type *payload_ptr;
  qcril_request_resp_params_type resp;
  qcril_cm_struct_type *i_ptr;
  int len;
  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( ret_ptr != NULL );
  i_ptr = &qcril_cm[ instance_id ];
  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore NV read request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  #endif /* FEATURE_QCRIL_DSDS */

  if ( ( payload_ptr = ( qcril_other_cdma_subscription_type * ) qcril_malloc( sizeof( qcril_other_cdma_subscription_type ) ) ) != NULL )
  {
    payload_ptr->cdma_subscription[ 0 ] = NULL;
    payload_ptr->cdma_subscription[ 1 ] = NULL;
    payload_ptr->cdma_subscription[ 2 ] = NULL;
    payload_ptr->cdma_subscription[ 3 ] = NULL;

    if ( qcril_arb_query_nv_srv_modem_id( QCRIL_ARB_NV_SRV_CAT_3GPP2, instance_id, &modem_ids_list ) == E_SUCCESS )
    {
      /* In case of global device for split modem architecture, OEM is required to make sure the NV item values on both modems
         are in sync. So read from one modem is sufficient */
      modem_id = modem_ids_list.modem_id[ 0 ];

      /* Only read from NV when CDMA subscription is available. */
      if ( qcril_arb_cdma_subscription_is_nv( instance_id, modem_id ) ||
           (
             ( ret_ptr->next_pri_cdma_sim_state == QCRIL_SIM_STATE_READY )
             #ifdef FEATURE_QCRIL_DSDS
             || ( ret_ptr->next_sec_cdma_sim_state == QCRIL_SIM_STATE_READY )
             #endif /* FEATURE_QCRIL_DSDS */
           )
         )
      {
        /* Lookup the modem that should be requested for NV service */
        if ( qcril_other_read_mdn_from_nv( instance_id, modem_id, payload_ptr->mob_dir_number ) )
        {
          payload_ptr->cdma_subscription[ 0 ] = payload_ptr->mob_dir_number;
        }

        if ( qcril_other_read_home_sid_nid_from_nv( instance_id, modem_id, payload_ptr->home_sid, payload_ptr->home_nid ) )
        {
          payload_ptr->cdma_subscription[ 1 ] = payload_ptr->home_sid;
          payload_ptr->cdma_subscription[ 2 ] = payload_ptr->home_nid;
        }

        if ( qcril_other_read_min_from_nv( instance_id, modem_id, payload_ptr->min_s ) )
        {
          payload_ptr->cdma_subscription[ 3 ] = payload_ptr->min_s;
        }


        len = QCRIL_SNPRINTF( payload_ptr->prl_ver, QCRIL_CM_PRL_VERSION_ASCII_MAX_LEN, "%d", i_ptr->ph_info[ modem_id ].prl_id );
        QCRIL_ASSERT( len <= QCRIL_CM_PRL_VERSION_ASCII_MAX_LEN );
        payload_ptr->cdma_subscription[ 4 ] = payload_ptr->prl_ver;

        QCRIL_LOG_DEBUG( "Reply to RIL -->  MDN %s, H_SID %s, H_NID %s, MIN %s, PRL_VER %s\n", 
                         payload_ptr->cdma_subscription[ 0 ], payload_ptr->cdma_subscription[ 1 ], 
                         payload_ptr->cdma_subscription[ 2 ], payload_ptr->cdma_subscription[ 3 ],
                         payload_ptr->cdma_subscription[ 4 ]);

        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
        resp.resp_pkt = ( void * ) payload_ptr->cdma_subscription;
        resp.resp_len = sizeof( payload_ptr->cdma_subscription );
        qcril_send_request_response( &resp );
      }
      else
      {
        /* CDMA subscription is not yet available, return NULL for all items */
        QCRIL_LOG_DEBUG( "%s", "Could not read CDMA subscription -- it's not available\n" );
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUBSCRIPTION_NOT_AVAILABLE, &resp );
        qcril_send_request_response( &resp );
      }
    }
    else
    {
      /* CDMA subscription is not yet available, return NULL for all items */
      QCRIL_LOG_DEBUG( "%s", "Could not read CDMA subscription -- it's not available\n" );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUBSCRIPTION_NOT_AVAILABLE, &resp );
      qcril_send_request_response( &resp );
    }

    qcril_free( payload_ptr );
  }
  else
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_phonesvc_request_cdma_subscription() */

/*===========================================================================

  FUNCTION:  qcril_cm_phonesvc_request_exit_emergency_callback_mode

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_request_exit_emergency_callback_mode
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;   
  qcril_modem_ids_list_type modem_ids_list;
  uint32 user_data;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  char details[ 40 ];

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref_per_subs()";
  #else
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    /* AS_ID lookup failed. Use SYS_MODEM_AS_ID_1 since CDMA will be on AS_ID_1.
     * This is done to support EXIT_EMERGENCY_CALLBACK_MODE in NO SIM/PIN
     * LOCKED cases where AS_ID is not present */
    QCRIL_LOG_DEBUG( "%s\n", "as_id lookup failed, use SYS_MODEM_AS_ID_1" );
    as_id = SYS_MODEM_AS_ID_1;
  }
  #endif /* FEATURE_QCRIL_DSDS */

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].emer_cb_state_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->emer_cb_state_mutex, details );

  /* Check, firstly if we are in emergency callback mode */
  if ( i_ptr->emer_cb_state == CM_PH_STATE_NORMAL )
  {
    /* Not in emergency callback mode */
    QCRIL_LOG_DEBUG( "RID %d MID %d modem is not in Emergency callback mode", instance_id, modem_id );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
    QCRIL_MUTEX_UNLOCK( &i_ptr->emer_cb_state_mutex, details );
    return;
  }

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_3GPP2, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    QCRIL_MUTEX_UNLOCK( &i_ptr->emer_cb_state_mutex, details );
    return;
  }

  /* Only one modem is configured to support CDMA */
  modem_id = modem_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_PH_SYS_SEL_PREF, NULL, &reqlist_entry ); 
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    QCRIL_MUTEX_UNLOCK( &i_ptr->emer_cb_state_mutex, details );
    return;
  }

  /* CM just needs a trigger with XX_NO_CHANGE, to come out to the pre-emergency callback mode */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

  QCRIL_LOG_RPC2( modem_id, cm_ph_cmd_sys_sel_pref_api_name, "MODE_PREF_PERSISTENT" );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_sys_sel_pref_func( qcril_cm_phonesvc_command_callback,
                                                                    (void *) user_data,
                                                                    i_ptr->client_info[ modem_id ].client_id,
                                                                    #ifdef FEATURE_QCRIL_DSDS
                                                                    as_id,
                                                                    #endif /* FEATURE_QCRIL_DSDS */
                                                                    CM_MODE_PREF_PERSISTENT,
                                                                    CM_PREF_TERM_PERMANENT,
                                                                    0,
                                                                    CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                                    CM_BAND_PREF_NO_CHANGE,
                                                                    CM_PRL_PREF_NO_CHANGE,
                                                                    CM_ROAM_PREF_NO_CHANGE,
                                                                    CM_HYBR_PREF_NO_CHANGE,
                                                                    CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                                    CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                                                    NULL 
                                                                    #ifndef FEATURE_QCRIL_DSDS
                                                                    , NULL
                                                                    #endif /* !FEATURE_QCRIL_DSDS */
                                                                  ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    QCRIL_LOG_DEBUG( "%s", "Requested modem to exit Emergency callback mode" );
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->emer_cb_state_mutex, details );

} /* qcril_cm_phonesvc_request_exit_emergency_callback_mode */


/*=========================================================================
  FUNCTION:  qcril_cm_phonesvc_event_oprt_mode

===========================================================================*/
/*!
    @brief
    Handle CM_PH_EVENT_OPRT_MODE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_oprt_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id, match_instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr, *match_i_ptr;
  uint8 i, j;
  int slot;
  qcril_modem_ids_list_type modem_ids_done_list;
  uint32 user_data;
  qcril_slot_ids_list_type slot_ids_list;
  IxErrnoType err_no;
  const cm_ph_info_s_type *ph_info_ptr = ( cm_ph_info_s_type *) params_ptr->data;
  qcril_reqlist_public_type req_info, match_req_info;
  IxErrnoType result;
  sys_oprt_mode_e_type prev_oprt_mode;
  qcril_request_resp_params_type resp;
  char *net_pref_name[ ] = { "GSM WCDMA Preferred", "GSM", "WCDMA", "GSM WCDMA Auto", "CDMA EVDO", "CDMA", "EVDO", 
                             "GSM WCDMA CDMA EVDO", "LTE CDMA EVDO", "LTE GSM WCDMA", "LTE CDAM EVDO GSM WCDMA", "LTE" };
  char details1[ 40 ], details2[ 40 ], details3[ 40 ];

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref_per_subs()";
  #else
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  prev_oprt_mode = i_ptr->ph_info[ modem_id ].oprt_mode;

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details1, sizeof( details1 ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details1 );

  /* For DSDS, operating mode is same for both instances */
  if ( qcril_arb_ma_is_dsds() )
  {
    match_i_ptr = &qcril_cm[ QCRIL_DSDS_INSTANCE_PAIR( instance_id ) ];
    match_i_ptr->ph_info[ modem_id ].oprt_mode = ph_info_ptr->oprt_mode;
  }

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS ) 
  {
    /* Save the phone's operating mode */
    i_ptr->ph_info[ modem_id ].oprt_mode = ph_info_ptr->oprt_mode;

    switch ( req_info.request )
    {
      case RIL_REQUEST_RADIO_POWER:
        /* For DSDS, the first received RIL_REQUEST_RADIO_POWER command out of the instance pair is responsible to
           command the modem for the mode change */
        if ( !req_info.sub.cm.info.radio_mode.is_command_instance )
        {
          QCRIL_LOG_DEBUG( "%s\n", "Mode change is taken care by the peer RIL_REQUEST_RADIO_POWER" ); 
          QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details1 );
          return;
        }

        QCRIL_SNPRINTF( details2, sizeof( details2 ), "cm_info[%d].card_info_mutex\n", instance_id );
        QCRIL_MUTEX_LOCK( &i_ptr->card_info_mutex, details2 );

        if ( req_info.sub.cm.info.radio_mode.oprt_mode == ph_info_ptr->oprt_mode )
        {
          if ( ( ph_info_ptr->oprt_mode == SYS_OPRT_MODE_LPM ) || ( ph_info_ptr->oprt_mode == SYS_OPRT_MODE_PWROFF ) )
          {
            /* Check whether all AMSS events received */
            if ( qcril_reqlist_complete_all_amss_events( instance_id, modem_id, req_info.t, QCRIL_REQ_COMPLETED_SUCCESS,
                                                         &modem_ids_done_list, &result ) == E_SUCCESS )
            {                                                                        
              if ( result == E_SUCCESS )
              {
                /* If card status is UP, power down the card */
                if ( !i_ptr->apm_sim_not_pwdn && qcril_cm_card_status_is_up( instance_id, &slot_ids_list ) )
                {
                  /* Power down the SIM card */
                  err_no = qcril_reqlist_update_pending_event_id( instance_id, QCRIL_DEFAULT_MODEM_ID, req_info.t, 
                                                                  QCRIL_EVT_CM_CARD_STATUS_UPDATED );
                  QCRIL_ASSERT( err_no == E_SUCCESS );
                  err_no = qcril_reqlist_update_state( instance_id, QCRIL_DEFAULT_MODEM_ID, req_info.t, 
                                                       QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS );
                  QCRIL_ASSERT( err_no == E_SUCCESS );

                  /* Multiple cards may need to request for power up */
                  for ( i = 0; i < slot_ids_list.num_of_slots; i++ )
                  {
                    slot = (int) slot_ids_list.slot_id[ i ];
                    QCRIL_LOG_DEBUG( "Request QCRIL(UIM) to power down the card in slot %d\n", slot );
                    qcril_cm_update_card_status( instance_id, slot, TRUE, i_ptr->card_info[ slot ].status );
                    err_no = qcril_process_event( instance_id, QCRIL_DEFAULT_MODEM_ID, 
                                                  QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_DOWN, 
                                                  (void *) &slot, sizeof( slot ),
                                                  (RIL_Token) QCRIL_TOKEN_ID_INTERNAL ); 
                    QCRIL_ASSERT( err_no == E_SUCCESS );
                  }
                }
                /* Card status in DOWN */
                else
                {

                  /* in case of power-off, de-register the event callback functions from RPC and de-register the client */
                  if ( ph_info_ptr->oprt_mode == SYS_OPRT_MODE_PWROFF )
                  {
                     /* de-register the CM/SMS/PBM call backs and release the clients */
                     qcril_release();
                  }

                  /* Update Radio State */
                  ret_ptr->modem_state_changed = TRUE;
                  ret_ptr->next_modem_state = QCRIL_MODEM_STATE_OFF;                            

                  QCRIL_LOG_DEBUG( "%s\n", "Reply to RIL --> Radio off" );
                  qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
                  qcril_send_request_response( &resp );
                  // Reset sms ack pending flags.
                  qcril_sms_reset_sms_ack_pending_flags( instance_id );

                  /* Response also for RIL_REQUEST_RADIO_POWER for the other instance */
                  if ( qcril_arb_ma_is_dsds() && req_info.valid_sub_id )
                  {                                                                                   
                    if ( qcril_reqlist_query_by_req_id( req_info.sub_id, &match_instance_id, &match_req_info ) == E_SUCCESS )
                    {                                                                                   
                      QCRIL_LOG_DEBUG( "%s\n", "Reply to RIL --> Radio off" );
                      qcril_default_request_resp_params( match_instance_id, match_req_info.t, match_req_info.request, 
                                                         RIL_E_SUCCESS, &resp );
                      qcril_send_request_response( &resp );
                    }
                  }
                  qcril_send_radio_response_process_blocked_request( instance_id,
                                  modem_id, RIL_E_SUCCESS, req_info.sub.cm.info.radio_mode.oprt_mode, req_info.req_id );
                  #ifdef FEATURE_QCRIL_DSDS
                  /* See if subscription info need to be updated */
                  qcril_arb_deactivate_all_subs();

                  if ( qcril_arb_ma_is_dsds() )
                  {
                    /* reset the registration state */
                    for (  i = 0; i < QCRIL_ARB_MAX_INSTANCES; i++ )
                    {
                       for( j = 0; j < QCRIL_ARB_MAX_MODEMS; j++ )
                       {
                          qcril_cm[ i ].ss_info[ j  ].srv_status = SYS_SRV_STATUS_NO_SRV;
                       }
                    }
                  }
                  #endif /* FEATURE_QCRIL_DSDS */
                }
              }
              else
              {
                /* Send RIL_E_GENERIC_FAILURE response */
                qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
                qcril_send_request_response( &resp );

                /* Response also for RIL_REQUEST_RADIO_POWER for the other instance */
                if ( qcril_arb_ma_is_dsds() && req_info.valid_sub_id )
                {                                                                                   
                  if ( qcril_reqlist_query_by_req_id( req_info.sub_id, &match_instance_id, &match_req_info ) == E_SUCCESS )
                  {                                                                                   
                    qcril_default_request_resp_params( match_instance_id, match_req_info.t, match_req_info.request, 
                                                       RIL_E_GENERIC_FAILURE, &resp );
                    qcril_send_request_response( &resp );
                  }
                }
                qcril_send_radio_response_process_blocked_request( instance_id,
                                modem_id, RIL_E_GENERIC_FAILURE, req_info.sub.cm.info.radio_mode.oprt_mode, req_info.req_id );
              }
            }
          }
          else
          {
            /* Check whether all AMSS events received */
            if ( qcril_reqlist_complete_all_amss_events( instance_id, modem_id, req_info.t, QCRIL_REQ_COMPLETED_SUCCESS, 
                                                         &modem_ids_done_list, &result ) == E_SUCCESS )
            {
              if ( result == E_SUCCESS )
              {
                /* Update Radio State */
                ret_ptr->modem_state_changed = TRUE;
                ret_ptr->next_modem_state = QCRIL_MODEM_STATE_ON;

                /* Done with all operations for Radio Power (on) request */
                QCRIL_LOG_DEBUG( "%s\n", "Reply to RIL --> Radio On" );
                qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
                qcril_send_request_response( &resp );

                /* Response also for RIL_REQUEST_RADIO_POWER for the other instance */
                if ( qcril_arb_ma_is_dsds() && req_info.valid_sub_id )
                {                                                                                   
                  if ( qcril_reqlist_query_by_req_id( req_info.sub_id, &match_instance_id, &match_req_info ) == E_SUCCESS )
                  {                                                                                   
                    QCRIL_LOG_DEBUG( "%s\n", "Reply to RIL --> Radio On" );
                    qcril_default_request_resp_params( match_instance_id, match_req_info.t, match_req_info.request, 
                                                       RIL_E_SUCCESS, &resp );
                    qcril_send_request_response( &resp );
                  }
                }
                qcril_send_radio_response_process_blocked_request( instance_id,
                                modem_id, RIL_E_SUCCESS, req_info.sub.cm.info.radio_mode.oprt_mode, req_info.req_id );
              }
              else
              {
                /* Send RIL_E_GENERIC_FAILURE response */
                qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
                qcril_send_request_response( &resp );

                /* Response also for RIL_REQUEST_RADIO_POWER for the other instance */
                if ( qcril_arb_ma_is_dsds() && req_info.valid_sub_id )
                {                                                                                   
                  if ( qcril_reqlist_query_by_req_id( req_info.sub_id, &match_instance_id, &match_req_info ) == E_SUCCESS )
                  {                                                                                   
                    qcril_default_request_resp_params( match_instance_id, match_req_info.t, match_req_info.request, 
                                                       RIL_E_GENERIC_FAILURE, &resp );
                    qcril_send_request_response( &resp );
                  }
                }
                qcril_send_radio_response_process_blocked_request( instance_id,
                                modem_id, RIL_E_GENERIC_FAILURE, req_info.sub.cm.info.radio_mode.oprt_mode, req_info.req_id );
              }
            }
          }
        }
        else
        {
          QCRIL_LOG_ERROR( "Unexpected CM_PH_EVENT_OPRT_MODE : oprt_mode %d, expected oprt_mode %d\n", ph_info_ptr->oprt_mode,
                           req_info.sub.cm.info.radio_mode.oprt_mode );
        }

        QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details2 );
        break;

      case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
        if ( req_info.sub.cm.info.network_pref.oprt_mode[ modem_id ] == ph_info_ptr->oprt_mode )
        {
          if ( req_info.sub.cm.info.network_pref.mode_pref[ modem_id ] != CM_MODE_PREF_NONE )
          {
            err_no = qcril_reqlist_update_pending_event_id( instance_id, modem_id, req_info.t, QCRIL_EVT_CM_PH_SYS_SEL_PREF );
            QCRIL_ASSERT( err_no == E_SUCCESS );
            err_no = qcril_reqlist_update_state( instance_id, modem_id, req_info.t, QCRIL_REQ_AWAITING_CALLBACK );
            QCRIL_ASSERT( err_no == E_SUCCESS );

            #ifdef FEATURE_QCRIL_DSDS
            /* Lookup as_id */
            if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
            {
              QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
              qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
              qcril_send_request_response( &resp );
              QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details1 );
              return;
            }  
            #endif /* FEATURE_QCRIL_DSDS */

            /* Command CM to change the phone's system selection preference on network type */
            user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, req_info.req_id );
            QCRIL_SNPRINTF( details3, sizeof( details3 ), "Token ID %d, mode pref %d, acq order pref %d", 
                            qcril_log_get_token_id( params_ptr->t ), req_info.sub.cm.info.network_pref.mode_pref[ modem_id ], 
                            req_info.sub.cm.info.network_pref.acq_order_pref[ modem_id ] );

            QCRIL_LOG_RPC2( modem_id, cm_ph_cmd_sys_sel_pref_api_name, details3 );
            if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_sys_sel_pref_func( qcril_cm_phonesvc_command_callback,
                                                                              (void *) user_data,
                                                                              i_ptr->client_info[ modem_id ].client_id,
                                                                              #ifdef FEATURE_QCRIL_DSDS
                                                                              as_id,
                                                                              #endif /* FEATURE_QCRIL_DSDS */
                                                                              req_info.sub.cm.info.network_pref.mode_pref[ modem_id ],
                                                                              CM_PREF_TERM_PERMANENT,
                                                                              0,
                                                                              req_info.sub.cm.info.network_pref.acq_order_pref[ modem_id ],
                                                                              CM_BAND_PREF_NO_CHANGE,
                                                                              CM_PRL_PREF_NO_CHANGE,
                                                                              CM_ROAM_PREF_NO_CHANGE,
                                                                              CM_HYBR_PREF_NO_CHANGE,
                                                                              CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                                              CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                                                              NULL
                                                                              #ifndef FEATURE_QCRIL_DSDS
                                                                              , NULL
                                                                              #endif /* !FEATURE_QCRIL_DSDS */
                                                                            ) )
            {
              /* In case of ARM9 reset, the command callback will never be executed. So, need to
                 delete the entry from the ReqList, and call OnRequestComplete() */
              qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
              qcril_send_request_response( &resp );
            }
          }
          else if ( qcril_reqlist_complete_all_amss_events( instance_id, modem_id, req_info.t, QCRIL_REQ_COMPLETED_SUCCESS,
                                                            &modem_ids_done_list, &result ) == E_SUCCESS )
          {
            if ( result == E_SUCCESS )
            {
              /* Done with all operations for Set Preferred Network request */
              qcril_arb_store_net_pref( instance_id, req_info.sub.cm.info.network_pref.net_pref );
              QCRIL_LOG_DEBUG( "Reply to RIL --> preferred network (%s)\n", 
                               net_pref_name[ req_info.sub.cm.info.network_pref.net_pref ] );
              qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
              qcril_send_request_response( &resp );
            }
            else
            {
              /* Send RIL_E_GENERIC_FAILURE response */
              qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
              qcril_send_request_response( &resp );
            }
          }
        }
        break;

      default:
        break;
    } /* end switch */
  }

  /* Check if the oprt_mode is changed ONLINE to FTM */
  else if ( !qcril_cm_ftm_mode_is_on( instance_id ) )
  {
    /* Save the phone's operating mode */
    i_ptr->ph_info[ modem_id ].oprt_mode = ph_info_ptr->oprt_mode;

    if ( qcril_cm_ftm_mode_is_on( instance_id ) )
    {
      QCRIL_LOG_DEBUG( "%s\n", "Enter FTM mode" ); 
      ret_ptr->modem_state_changed = TRUE;
      ret_ptr->next_modem_state = QCRIL_MODEM_STATE_UNAVAILABLE;
    }
  }
  /* Check if the oprt_mode is changed FTM to ONLINE */
  else
  {
    /* Save the phone's operating mode */
    i_ptr->ph_info[ modem_id ].oprt_mode = ph_info_ptr->oprt_mode;

    if ( !qcril_cm_ftm_mode_is_on( instance_id ) )
    {
      QCRIL_LOG_DEBUG( "%s\n", "Exit FTM mode" ); 
      ret_ptr->modem_state_changed = TRUE;
      ret_ptr->next_modem_state = QCRIL_MODEM_STATE_OFF;

      /* No need to transition to LPM because Android Telephony will then issue RIL_REQUEST_RADIO_POWER(On)
         to initate the operating mode correction */
    }
  }

  QCRIL_LOG_DEBUG( "RID %d MID: %d, Prev Oprt mode: %d, Oprt mode: %d\n", instance_id, modem_id, prev_oprt_mode, 
                   i_ptr->ph_info[ modem_id ].oprt_mode );

  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details1 );
   
} /* qcril_cm_phonesvc_event_oprt_mode */


/*=========================================================================
  FUNCTION:  qcril_cm_phonesvc_event_info

===========================================================================*/
/*!
    @brief
    Handle CM_PH_EVENT_INFO.

    If this is the very first time QCRIL CM receives the CM_PH_EVENT_INFO 
    after qcril_cm_init() being called, it will trigger the following:
    (1) Read NV item RTRE_CONFIG and command CM to change RTRE config
    (2) Update QCRIL Radio State from Unavailable to Off
    (3) Update QCRIL Mode Config
    (4) Update QCRIL Subscription Config

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_info
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{  
  qcril_instance_id_e_type instance_id, route_instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_ph_info_s_type *ph_info_ptr;
  qcril_reqlist_public_type req_info;
  int network_selection_mode;
  int roaming_preference;
  sys_oprt_mode_e_type prev_oprt_mode;
  boolean net_pref_restored;
  qcril_cm_net_pref_e_type net_pref;
  qcril_arb_ma_e_type ma;
  char *net_pref_name[] = { "GSM WCDMA Preferred", "GSM", "WCDMA", "GSM WCDMA Auto", "CDMA EVDO", "CDMA", "EVDO", 
                            "GSM WCDMA CDMA EVDO", "LTE CDMA EVDO", "LTE GSM WCDMA", "LTE CDAM EVDO GSM WCDMA", "LTE" };
  int preferred_network;
  uint8 i;
  IxErrnoType result;
  qcril_modem_ids_list_type modem_ids_done_list;
  qcril_modem_id_e_type voice_modem_id;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  qcril_request_resp_params_type resp;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  prev_oprt_mode = i_ptr->ph_info[ modem_id ].oprt_mode;
  ph_info_ptr = ( cm_ph_info_s_type *) params_ptr->data;
  QCRIL_ASSERT( ph_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  if ( qcril_arb_lookup_instance_id_from_as_id( ph_info_ptr->asubs_id, &route_instance_id ) != E_SUCCESS )
  {
     if( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) != E_SUCCESS )
     {
        /* when there is no subscription and pending event, process it only during power on for default instance */
        if(  ! ( ( instance_id == QCRIL_DEFAULT_INSTANCE_ID ) && ( prev_oprt_mode == SYS_OPRT_MODE_NONE ) ) )
        {
          QCRIL_LOG_DEBUG("%s", "Ignoring the event due to unavailability of subscription");
          return;
        }
     }
  }
  #endif

  /* Save common phone settings */
  for ( i = 0; i < QCRIL_ARB_MAX_INSTANCES; i++ )
  {
    i_ptr = &qcril_cm[ i ];

    QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
    QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );

    /* Update the modem's band/mode capability info */
    i_ptr->ph_info[ modem_id ].mode_capability = ph_info_ptr->mode_capability;
    i_ptr->ph_info[ modem_id ].band_capability = ph_info_ptr->band_capability;

    /* Save the phone's operating mode */
    i_ptr->ph_info[ modem_id ].oprt_mode = ph_info_ptr->oprt_mode;

    /* Save the modem's RTRE configuration */
    i_ptr->ph_info[ modem_id ].rtre_control = ph_info_ptr->rtre_control;
    i_ptr->ph_info[ modem_id ].rtre_config = ph_info_ptr->rtre_config;

    /* Save prl info */
    i_ptr->ph_info[ modem_id ].prl_pref_only = ph_info_ptr->prl_pref_only;
    i_ptr->ph_info[ modem_id ].prl_id = ph_info_ptr->prl_id;

    QCRIL_LOG_DEBUG( "MID %d oprt_mode=%d, rtre_control=%d, rtre_config=%d, prl_pref_only=%d, prl_id=%d\n", 
                     modem_id, i_ptr->ph_info[ modem_id ].oprt_mode, i_ptr->ph_info[ modem_id ].rtre_control,
                     i_ptr->ph_info[ modem_id ].rtre_config, i_ptr->ph_info[ modem_id ].prl_pref_only, i_ptr->ph_info[ modem_id ].prl_id );

    #ifdef FEATURE_QCRIL_DSDS
    i_ptr->ph_info[ modem_id ].standby_pref = ph_info_ptr->standby_pref;
    i_ptr->ph_info[ modem_id ].active_subs = ph_info_ptr->active_subs;
    i_ptr->ph_info[ modem_id ].default_voice_subs = ph_info_ptr->default_voice_subs;
    i_ptr->ph_info[ modem_id ].default_data_subs = ph_info_ptr->default_data_subs;
    i_ptr->ph_info[ modem_id ].priority_subs = ph_info_ptr->priority_subs;
    #endif /* FEATURE_QCRIL_DSDS */

    QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );
  }

  i_ptr = &qcril_cm[ instance_id ];

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );

  /* Remember phone capability is reported */
  i_ptr->ph_info[ modem_id ].capability_reported = TRUE;

  /* For non-DSDS, there is no phone settings specific to subscription. Save the info now.
     Otherwise, update the info per subscription later */
  if ( !qcril_arb_ma_is_dsds() )
  {
    /* Save the phone preference */
    i_ptr->ph_info[ modem_id ].mode_pref = ph_info_ptr->mode_pref;
    i_ptr->ph_info[ modem_id ].gw_acq_order_pref = ph_info_ptr->acq_order_pref;
    i_ptr->ph_info[ modem_id ].band_pref = ph_info_ptr->band_pref;
    i_ptr->ph_info[ modem_id ].roam_pref = ph_info_ptr->roam_pref;
    i_ptr->ph_info[ modem_id ].network_sel_mode_pref = ph_info_ptr->network_sel_mode_pref;

    /* If current network selection preference is automatic, clear PLMN preference */
    if ( i_ptr->ph_info[ modem_id ].network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC )
    {
      i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 0 ] = 0xFF;
      i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 1 ] = 0xFF;
      i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 2 ] = 0xFF;
    }

    /* If current network selection preference is manual and PLMN preference is wildcard, it means no change in PLMN preference
       after UE powers up since it powers down. Don't override the PLMN preference info from Android UI */
    else if ( ( i_ptr->ph_info[ modem_id ].network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL ) && 
              !QCRIL_CM_PLMN_PREFERENCE_IS_WILDCARD( ph_info_ptr->plmn.identity[ 0 ], ph_info_ptr->plmn.identity[ 1 ],
                                                     ph_info_ptr->plmn.identity[ 2 ] ) )
    {
      i_ptr->ph_info[ modem_id ].plmn_pref = ph_info_ptr->plmn;
    }
  }

  #ifdef FEATURE_QCRIL_SUBS_CTRL
  /* Figure out the subscripton control info */
  ret_ptr->new_subscription_config_mask = 0;

  if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_CDMA( i_ptr->ph_info[ modem_id ].mode_capability ) || 
       QCRIL_CM_MODE_CAPABILITY_SUPPORT_HDR( i_ptr->ph_info[ modem_id ].mode_capability ) )  
  {
    switch( i_ptr->ph_info[ modem_id ].rtre_config )
    {
      case CM_RTRE_CONFIG_RUIM_ONLY:
        QCRIL_LOG_DEBUG( "RID %d MID %d CDMA subscription source: RUIM\n", instance_id, modem_id );
        ret_ptr->subscription_config_changed = TRUE;
        ret_ptr->new_subscription_config_mask = QCRIL_SUBSCRIPTION_RUIM_MASK;
        break;

      case CM_RTRE_CONFIG_NONE:
      case CM_RTRE_CONFIG_NV_ONLY:
        QCRIL_LOG_DEBUG( "RID %d MID %d CDMA subscription source: NV\n", instance_id, modem_id );
        ret_ptr->subscription_config_changed = TRUE;
        ret_ptr->new_subscription_config_mask = QCRIL_SUBSCRIPTION_NV_MASK;
        break;

      case CM_RTRE_CONFIG_RUIM_OR_DROP_BACK:
        QCRIL_LOG_DEBUG( "RID %d MID %d CDMA subscription source: NV or RUIM\n", instance_id, modem_id );
        ret_ptr->subscription_config_changed = TRUE;
        ret_ptr->new_subscription_config_mask = QCRIL_SUBSCRIPTION_NV_RUIM_MASK;
        break;

      default:
        break;
    }
  }

  if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_GSM( i_ptr->ph_info[ modem_id ].mode_capability ) || 
       QCRIL_CM_MODE_CAPABILITY_SUPPORT_WCDMA( i_ptr->ph_info[ modem_id ].mode_capability ) )
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d SIM subscription source\n", instance_id, modem_id );
    ret_ptr->subscription_config_changed = TRUE;
    ret_ptr->new_subscription_config_mask |= QCRIL_SUBSCRIPTION_SIM_MASK;
  }

  /* Sync the CDMA subscription state with phone */
  if ( ph_info_ptr->is_gw_subscription_available )
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d Pri GW subscription enabled\n", instance_id, modem_id ); 
    i_ptr->ph_info[ modem_id ].pri_gw_subscription_state = QCRIL_CM_SUBSCRIPTION_ENABLED;
  }
  else
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d Pri GW subscription disabled\n", instance_id, modem_id ); 
    i_ptr->ph_info[ modem_id ].pri_gw_subscription_state = QCRIL_CM_SUBSCRIPTION_DISABLED;
  }

  /* Sync the GW subscription state with phone */
  if ( ph_info_ptr->is_cdma_subscription_available )
  {
    QCRIL_LOG_DEBUG( "RID %d Mid %d Pri CDMA subscription enabled\n", instance_id, modem_id ); 
    i_ptr->ph_info[ modem_id ].pri_cdma_subscription_state = QCRIL_CM_SUBSCRIPTION_ENABLED;
  }
  else
  {
    QCRIL_LOG_DEBUG( "RID %d MID %d Pri CDMA subscription disabled\n", instance_id, modem_id ); 
    i_ptr->ph_info[ modem_id ].pri_cdma_subscription_state = QCRIL_CM_SUBSCRIPTION_DISABLED;
  }
  #endif /* FEATURE_QCRIL_SUBS_CTRL */

  /* First time, modem reports capability */
  QCRIL_LOG_DEBUG( "RID %d MID: %d, Prev Oprt mode: %d, Oprt mode: %d, Mode pref: %d, GW acq order: %d, Band pref: %lld, Roam pref: %d, Network sel mode: %d, plmn[0]=%d, plmn[1]=%d, plmn[2]=%d, rtre control: %d", 
                   instance_id, modem_id, prev_oprt_mode, i_ptr->ph_info[ modem_id ].oprt_mode, i_ptr->ph_info[ modem_id ].mode_pref, 
                   i_ptr->ph_info[ modem_id ].gw_acq_order_pref, 
                   i_ptr->ph_info[ modem_id ].band_pref, i_ptr->ph_info[ modem_id ].roam_pref, 
                   i_ptr->ph_info[ modem_id ].network_sel_mode_pref, i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 0 ], 
                   i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 1 ], i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 2 ], 
                   i_ptr->ph_info[ modem_id ].rtre_control );

  QCRIL_LOG_DEBUG( "RID %d MID %d Mode capability: %d \n", instance_id, modem_id, i_ptr->ph_info[ modem_id ].mode_capability ); 

  if ( prev_oprt_mode == SYS_OPRT_MODE_NONE )
  {
    if ( ph_info_ptr->is_gw_subscription_available )
    {
      i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state = SYS_SIM_STATE_AVAILABLE;
      QCRIL_LOG_DEBUG("Subscription is available even before QCRIL comes up, sim_state = %d\n",  i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state);
    }

    /* Not in FTM mode */
    if ( !qcril_cm_ftm_mode_is_on( instance_id ) && qcril_cm_phone_capability_is_reported( instance_id ) )
    {
      /* Sync the network preference for multimode non-DSDS */
      if ( !qcril_arb_ma_is_dsds() )
      {
        /* Sync the network preference */
        qcril_cm_sync_network_preference( instance_id );

        /* Sync card status if NV is the only subscription source */
        QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].card_info_mutex\n", instance_id );
        QCRIL_MUTEX_LOCK( &i_ptr->card_info_mutex, details );
        qcril_cm_sync_card_status( instance_id );
        QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details );
      }

      /* Sync the modem to start in LPM with subscription disabled */
      qcril_cm_sync_modem_state( instance_id );

      /* Now, we know the modem's band mode capability. If Card Status is already known, change Radio State to Modem Off that
         indicates ready to accept all RIL commands. Otherwise, wait for Card Status Updated event, before change Radio State
         to Modem Off. Note: RIL request RADIO POWER may come right away, so Card Status must have a good known value */  
      QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].card_info_mutex\n", instance_id );
      QCRIL_MUTEX_LOCK( &i_ptr->card_info_mutex, details );

      if ( qcril_cm_card_status_is_reported( instance_id ) )
      {
        ret_ptr->modem_state_changed = TRUE;

        /* In case of DSDS, modem is not moved to LPM during power on, hence report the current modem state */
        /* In case of non-DSDS, modem is moved to LPM during qcril_cm_sync_modem_state() */
        if( qcril_arb_ma_is_dsds() )
        {
           if ( i_ptr->ph_info[modem_id].oprt_mode != SYS_OPRT_MODE_ONLINE )
           {
             ret_ptr->next_modem_state = QCRIL_MODEM_STATE_OFF;
           }
           else
           {
             ret_ptr->next_modem_state = QCRIL_MODEM_STATE_ON;         
           }
        }
        else
        {
             ret_ptr->next_modem_state = QCRIL_MODEM_STATE_OFF;
        }

        /* Check to see whether voice radio technology is changed */
        if ( !qcril_arb_ma_is_dsds() )
        {
          qcril_arb_query_voice_srv_modem_id( instance_id, &voice_modem_id, &voice_radio_tech );
          if ( voice_modem_id != QCRIL_MAX_MODEM_ID )
          {
            ret_ptr->voice_radio_tech_changed = TRUE;
            ret_ptr->new_voice_radio_tech = voice_radio_tech;
          }
        }
      }

      QCRIL_MUTEX_UNLOCK( &i_ptr->card_info_mutex, details );
    }
  }

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS ) 
  {
    switch ( req_info.request )
    {
      case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE:
        if ( ph_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL )
        {
          network_selection_mode = QCRIL_CM_NETWORK_SEL_MODE_PREF_MANUAL;
          QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Manual network selection mode\n" );
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
          resp.resp_pkt = (void *) &network_selection_mode; 
          resp.resp_len = sizeof( network_selection_mode );
          resp.logstr = "Manual";
          qcril_send_request_response( &resp );
        }
        else
        {
          network_selection_mode = QCRIL_CM_NETWORK_SEL_MODE_PREF_AUTOMATIC;
          QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Automatic network selection mode\n" );
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
          resp.resp_pkt = (void *) &network_selection_mode; 
          resp.resp_len = sizeof( network_selection_mode );
          resp.logstr = "Automatic";
          qcril_send_request_response( &resp );
        }
        break;

      case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE:
        if ( qcril_reqlist_complete_all_amss_events( instance_id, modem_id, req_info.t, QCRIL_REQ_COMPLETED_SUCCESS, 
                                                     &modem_ids_done_list, &result ) == E_SUCCESS )
        {
          if ( result == E_SUCCESS )
          {
            /* Sync the network preference */
            qcril_cm_sync_network_preference_and_oprt_mode( instance_id );

            /* Query stored network preference */
            qcril_arb_query_net_pref( instance_id, &net_pref_restored, &net_pref, &ma );

            preferred_network = (int) net_pref;
            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
            resp.resp_pkt = (void *) &preferred_network; 
            resp.resp_len = sizeof( preferred_network );
            qcril_send_request_response( &resp );
            QCRIL_LOG_DEBUG( "Reply to RIL --> preferred network (%s)\n", net_pref_name[ net_pref ] );
          }
          else
          {
            /* Send GENERIC failure */
            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
            qcril_send_request_response( &resp );
          }
        }
        break;

      case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:
        switch ( i_ptr->ph_info[ modem_id ].roam_pref )
        {
          case CM_ROAM_PREF_HOME:
            roaming_preference = QCRIL_CM_ROAMING_PREF_HOME_NETWORK_ONLY;
            QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Home network only\n" ); 
            break; 

          case CM_ROAM_PREF_AFFIL:
            roaming_preference = QCRIL_CM_ROAMING_PREF_AFFILIATED_NETWORK_ONLY;
            QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Affiliated network only\n" ); 
            break;

          case CM_ROAM_PREF_ANY:
            roaming_preference = QCRIL_CM_ROAMING_PREF_ANY_NETWORK;
            QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Any network\n" ); 
            break;

          default:
            /* Should never happen, report default roaming preference */ 
            roaming_preference = QCRIL_CM_ROAMING_PREF_ANY_NETWORK;
            QCRIL_LOG_ERROR( "Reply to RIL --> Any network, roam pref %d\n", i_ptr->ph_info[ modem_id ].roam_pref ); 
            break;
        } /* end switch */

        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        resp.resp_pkt = (void *) &roaming_preference; 
        resp.resp_len = sizeof( roaming_preference );
        qcril_send_request_response( &resp );

        break;

      /* Not sure what the RIL command is and the pass/fail criteria, response GENERIC_FAILURE */
      default:
        QCRIL_LOG_ERROR( "Unhandled CM_PH_EVENT_INFO for %s (%d)\n", qcril_log_lookup_event_name( req_info.request ), 
                         req_info.request ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        break;

    } /* end switch */
  } /* end if */

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

} /* qcril_cm_phonesvc_event_info */


/*=========================================================================
  FUNCTION:  qcril_cm_phonesvc_event_sys_sel_pref

===========================================================================*/
/*!
    @brief
    Handle CM_PH_EVENT_SYS_SEL_PREF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_sys_sel_pref
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id, voice_modem_id, cdma_modem_id, evdo_modem_id, gwl_modem_id, pdt_modem_id, lpm_modem_id;
  qcril_arb_pref_data_tech_e_type pref_data_tech;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  uint32 user_data;
  qcril_modem_ids_list_type modem_ids_done_list;
  const cm_ph_info_s_type *ph_info_ptr;
  qcril_reqlist_public_type req_info;
  IxErrnoType err_no;
  IxErrnoType result;
  boolean exit_emerg_cb_requested = FALSE;
  qcril_unsol_resp_params_type unsol_resp;
  char *net_pref_name[] = { "GSM WCDMA Preferred", "GSM", "WCDMA", "GSM WCDMA Auto", "CDMA EVDO", "CDMA", "EVDO", 
                            "GSM WCDMA CDMA EVDO", "LTE CDMA EVDO", "LTE GSM WCDMA", "LTE CDAM EVDO GSM WCDMA", "LTE" };
  qcril_request_resp_params_type resp;
  char details[ 40 ];
  int evt = 0;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  ph_info_ptr = ( cm_ph_info_s_type *) params_ptr->data;
  QCRIL_ASSERT( ph_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );

  /* Save the current phone settings */
  i_ptr->ph_info[ modem_id ].mode_pref = ph_info_ptr->mode_pref;
  i_ptr->ph_info[ modem_id ].gw_acq_order_pref = ph_info_ptr->acq_order_pref;
  i_ptr->ph_info[ modem_id ].band_pref = ph_info_ptr->band_pref;
  i_ptr->ph_info[ modem_id ].roam_pref = ph_info_ptr->roam_pref;
  i_ptr->ph_info[ modem_id ].network_sel_mode_pref = ph_info_ptr->network_sel_mode_pref;

  /* If current network selection preference is automatic, clear PLMN preference */
  if ( i_ptr->ph_info[ modem_id ].network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC )
  {
    i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 0 ] = 0xFF;
    i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 1 ] = 0xFF;
    i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 2 ] = 0xFF;
  }
  /* If current network selection preference is manual and PLMN preference is wildcard, it means no change in PLMN preference
     after UE powers up since it powers down. Don't override the PLMN preference info from Android UI */
  else if ( ( i_ptr->ph_info[ modem_id ].network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL ) && 
            !QCRIL_CM_PLMN_PREFERENCE_IS_WILDCARD( ph_info_ptr->plmn.identity[ 0 ], ph_info_ptr->plmn.identity[ 1 ],
                                                   ph_info_ptr->plmn.identity[ 2 ] ) )
  {
    i_ptr->ph_info[ modem_id ].plmn_pref = ph_info_ptr->plmn;
  }
 
  QCRIL_LOG_DEBUG( "RID %d MID %d, Mode: %d, GW acq order: %d, Band pref: %lld, Roam pref: %d, Network sel mode: %d, plmn[0]=%d, plmn[1]=%d, plmn[2]=%d", 
                   instance_id, modem_id, i_ptr->ph_info[ modem_id ].mode_pref, i_ptr->ph_info[ modem_id ].gw_acq_order_pref, 
                   i_ptr->ph_info[ modem_id ].band_pref, i_ptr->ph_info[ modem_id ].roam_pref, 
                   i_ptr->ph_info[ modem_id ].network_sel_mode_pref, i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 0 ], 
                   i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 1 ], i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 2 ] );

  QCRIL_LOG_DEBUG( "RID %d MID %d Ph_state: %d", instance_id, modem_id, ph_info_ptr->ph_state );

  QCRIL_LOG_DEBUG( "RID %d MID %d Mode capability: %d \n", instance_id, modem_id, i_ptr->ph_info[ modem_id ].mode_capability ); 

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS ) 
  {
    switch ( req_info.request )
    {
      case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE:
        if ( ph_info_ptr->mode_pref == req_info.sub.cm.info.network_pref.mode_pref[ modem_id ] ) 
        {
          if ( qcril_reqlist_complete_all_amss_events( instance_id, modem_id, req_info.t, QCRIL_REQ_COMPLETED_SUCCESS, 
                                                       &modem_ids_done_list, &result ) == E_SUCCESS )
          {                                                   
            if ( result == E_SUCCESS )
            {
              /* Done with all operations for Set Preferred Network request */
              qcril_arb_store_net_pref( instance_id, req_info.sub.cm.info.network_pref.net_pref );
              qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
              qcril_send_request_response( &resp );
              QCRIL_LOG_DEBUG( "Reply to RIL --> preferred network (%s)\n", 
                               net_pref_name[ req_info.sub.cm.info.network_pref.net_pref ] );

              /* Check to see whether voice radio technology is changed */
              qcril_arb_query_voice_srv_modem_id( instance_id, &voice_modem_id, &voice_radio_tech );
              if ( voice_modem_id != QCRIL_MAX_MODEM_ID )
              {
                ret_ptr->voice_radio_tech_changed = TRUE;
                ret_ptr->new_voice_radio_tech = voice_radio_tech;
              }
            }
            else
            {
              /* Send RIL_E_GENERIC_FAILURE response */
              qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
              qcril_send_request_response( &resp );
            }
          }
        }
        break;

      case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:
        if ( ( ph_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL ) &&
             qcril_cm_ons_match_plmn( ph_info_ptr->plmn, req_info.sub.cm.info.manual_network_sel.plmn ) )
        {
          /* Manual network selection on the same PLMN */
          if ( req_info.sub.cm.info.manual_network_sel.same_plmn )
          {
            /* Full service */
            if ( QCRIL_CM_SRV_STATUS_INDICATES_GW_FULL_SRV( i_ptr->ss_info[ modem_id ].srv_status, 
                                                            i_ptr->ss_info[ modem_id ].sys_mode ) )
            {
              qcril_cancel_timed_callback( (void *) req_info.sub_id );
              qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
              qcril_send_request_response( &resp );
              QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Registered on system (Manual network selection mode)\n" );
            }
            else
            {
              err_no = qcril_reqlist_update_pending_event_id( instance_id, modem_id, req_info.t, QCRIL_EVT_CM_SS_SRV_CHANGED );
              QCRIL_ASSERT( err_no == E_SUCCESS );
              QCRIL_LOG_DEBUG( "%s", "Waiting for SS_EVENT_SRV_CHANGED event\n" );
              QCRIL_LOG_DEBUG( "%s", "Pending Reply to RIL --> Manual network selection mode\n" );
              QCRIL_LOG_DEBUG( "Pending Reply to RIL --> pref PLMN[0]=%d, PLMN[1]=%d, PLMN[2]=%d\n", 
                               i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 0 ], 
                               i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 1 ], 
                               i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 2 ] );
            }
          }
          /* Not manual network selection on the same PLMN */
          else
          {
            /* Change in network selection mode preference, await for the next AMSS event */
            err_no = qcril_reqlist_update_pending_event_id( instance_id, modem_id, req_info.t, QCRIL_EVT_CM_SS_SRV_CHANGED );
            QCRIL_ASSERT( err_no == E_SUCCESS );
            QCRIL_LOG_DEBUG( "%s", "Waiting for SS_EVENT_SRV_CHANGED event\n" );
            QCRIL_LOG_DEBUG( "%s", "Pending Reply to RIL --> Manual network selection mode\n" );
            QCRIL_LOG_DEBUG( "Pending Reply to RIL --> pref PLMN[0]=%d, PLMN[1]=%d, PLMN[2]=%d\n", 
                             i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 0 ], 
                             i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 1 ], 
                             i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 2 ] );
          }
        }
        else
        {
          QCRIL_LOG_ERROR( "Unexpected CM_PH_EVENT_INFO : net sel mode pref %d, plmn[0] %d, plmn[1] %d, plmn[2] %d for %s (%d)\n", 
                           ph_info_ptr->network_sel_mode_pref, ph_info_ptr->plmn.identity[ 0 ], ph_info_ptr->plmn.identity[ 1 ],
                           ph_info_ptr->plmn.identity[ 2 ], qcril_log_lookup_event_name( req_info.request ), req_info.request ); 
        }
        break;

      case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
        if ( ( ph_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC ) || 
             ( ph_info_ptr->network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_LIMITED_SRV ) )
        { 
          /* Change in network selection mode preference, await for the next AMSS event */
          err_no = qcril_reqlist_update_pending_event_id( instance_id, modem_id, req_info.t, QCRIL_EVT_CM_SS_SRV_CHANGED );
          QCRIL_ASSERT( err_no == E_SUCCESS );
        }
        else
        {
          QCRIL_LOG_DEBUG( "Unexpected CM_PH_EVENT_INFO : net sel mode pref %d for %s (%d)\n", 
                           ph_info_ptr->network_sel_mode_pref, qcril_log_lookup_event_name( req_info.request ), req_info.request ); 
        }
        break;

      case RIL_REQUEST_SET_BAND_MODE:
        if ( ph_info_ptr->band_pref == req_info.sub.cm.info.band_pref )
        {
          if ( qcril_reqlist_complete_all_amss_events( instance_id, modem_id, req_info.t, QCRIL_REQ_COMPLETED_SUCCESS, 
                                                       &modem_ids_done_list, &result ) == E_SUCCESS )
          {
            if ( result == E_SUCCESS )
            {
              qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
              qcril_send_request_response( &resp );

              switch ( ph_info_ptr->band_pref )
              {
                case QCRIL_CM_BAND_PREF_ANY:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Unspecified band\n" ); 
                  break; 

                case QCRIL_CM_BAND_PREF_EURO:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> EURO band\n" ); 
                  break;

                case QCRIL_CM_BAND_PREF_US:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> US band\n" ); 
                  break;

                case QCRIL_CM_BAND_PREF_JPN:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> JPN band\n" ); 
                  break;

                case QCRIL_CM_BAND_PREF_AUS:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> AUS band\n" ); 
                  break;

                case QCRIL_CM_BAND_PREF_AUS2:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> AUS2 band\n" ); 
                  break;

                case CM_BAND_PREF_BC0:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Cellular band\n" ); 
                  break;

                case CM_BAND_PREF_BC1:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> PCS band\n" ); 
                  break;

                case CM_BAND_PREF_BC3:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Band class 3\n" ); 
                  break;

                case CM_BAND_PREF_BC4:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Band class 4\n" ); 
                  break;

                case CM_BAND_PREF_BC5:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Band class 5\n" ); 
                  break;

                case CM_BAND_PREF_BC6:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Band class 6\n" ); 
                  break;

                case CM_BAND_PREF_BC7:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Band class 7\n" ); 
                  break;

                case CM_BAND_PREF_BC8:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Band class 8\n" ); 
                  break;

                case CM_BAND_PREF_BC9:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Band class 9\n" ); 
                  break;

                case CM_BAND_PREF_BC10:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Band class 10\n" ); 
                  break;

                case CM_BAND_PREF_BC11:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Band class 11\n" ); 
                  break;

                case CM_BAND_PREF_BC15:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Band class 15\n" ); 
                  break;

                case CM_BAND_PREF_BC16:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Band class 16\n" ); 
                  break;

                default:
                  QCRIL_LOG_ERROR( "Reply to RIL --> band pref %lld\n", ph_info_ptr->band_pref );
                  break;
              } /* end switch */
            }
            else
            {
              /* Send RIL_E_GENERIC_FAILURE response */
              qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
              qcril_send_request_response( &resp );
            }
          }
        }
        else
        {
          QCRIL_LOG_ERROR( "Unexpected CM_PH_EVENT_INFO : band pref %lld\n", ph_info_ptr->band_pref );
        }
        break;

      case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:
        if ( ph_info_ptr->roam_pref == req_info.sub.cm.info.roam_pref )
        {
          if ( qcril_reqlist_complete_all_amss_events( instance_id, modem_id, req_info.t, QCRIL_REQ_COMPLETED_SUCCESS,
                                                       &modem_ids_done_list, &result ) == E_SUCCESS )
          {
            if ( result == E_SUCCESS )
            {
              qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
              qcril_send_request_response( &resp );

              switch ( ph_info_ptr->roam_pref )
              {
                case CM_ROAM_PREF_HOME:
                  QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Home network only\n" ); 
                  break; 

               case CM_ROAM_PREF_AFFIL:
                 QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Affiliated network only\n" ); 
                 break;

               case CM_ROAM_PREF_ANY:
                 QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Any network\n" ); 
                 break;

               default:
                 /* Should never happen */
                 QCRIL_LOG_ERROR( "Reply to RIL --> roam pref %d\n", ph_info_ptr->roam_pref ); 
                 break;
              } /* end switch */
            }
            else
            {
              /* Send RIL_E_GENERIC_FAILURE response */
              qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
              qcril_send_request_response( &resp );
            }
          }
        }
        break;

      case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE:
        exit_emerg_cb_requested = TRUE;
        if ( ph_info_ptr->ph_state == CM_PH_STATE_NORMAL )
        {
          /* Modem successfully returned to normal (non-emergency callback) mode */
          QCRIL_LOG_DEBUG( "RID %d MID %d Exited from emergency callback mode\n", instance_id, modem_id ); 
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
          qcril_send_request_response( &resp );

          evt = RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE;

          /* For QC solution split modem (SVDO or SVLTE), put MDM to Online mode when exit emergency callback */
          lpm_modem_id = QCRIL_MAX_MODEM_ID;

          /* Lookup modem id for configured to serve data service */
          qcril_arb_query_data_tech_modem_id( instance_id, &cdma_modem_id, &evdo_modem_id, &gwl_modem_id, &pdt_modem_id, 
                                              &pref_data_tech );

          if ( ( evdo_modem_id != modem_id ) && ( evdo_modem_id != QCRIL_MAX_MODEM_ID ) )
          {
            lpm_modem_id = evdo_modem_id;
          }
          else if ( ( gwl_modem_id != modem_id ) && ( gwl_modem_id != QCRIL_MAX_MODEM_ID ) )
          {
            lpm_modem_id = gwl_modem_id;
          }

          if ( ( lpm_modem_id != QCRIL_MAX_MODEM_ID ) && ( i_ptr->ph_info[ lpm_modem_id ].oprt_mode == SYS_OPRT_MODE_LPM ) )
          {
            /* Command CM to change the data modem's operating mode */
            QCRIL_LOG_DEBUG( "Command MID %d to LPM\n", lpm_modem_id );
            user_data = QCRIL_COMPOSE_USER_DATA( instance_id, lpm_modem_id, QCRIL_REQ_ID_INTERNAL );
            QCRIL_LOG_RPC2A( lpm_modem_id, "cm_ph_cmd_oprt_mode()", "Online" );
            (void) qcril_cm_api_funcs[ lpm_modem_id ].cm_ph_cmd_oprt_mode_func( qcril_cm_phonesvc_command_callback,
                                                                                (void *) user_data,
                                                                                i_ptr->client_info[ lpm_modem_id ].client_id,
                                                                                SYS_OPRT_MODE_ONLINE );
          }
        }
        else
        {
          /* Exit Emergency_callback_mode failed */
          QCRIL_LOG_DEBUG( "RID %d MID %d Failed to exit emergency callback mode, ph_state = %d\n", instance_id, modem_id, 
                          ph_info_ptr->ph_state); 
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
        }
        break;

      default:
        QCRIL_LOG_ERROR( "Unhandled CM_PH_EVENT_INFO for %s (%d)\n", 
                         qcril_log_lookup_event_name( req_info.request ), req_info.request ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        break;

    } /* end switch */
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

  /* Save current phone state */
  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].emer_cb_state_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->emer_cb_state_mutex, details );
  if ( !exit_emerg_cb_requested && ( i_ptr->emer_cb_state == CM_PH_STATE_EMERG_CB ) && 
       ( ph_info_ptr->ph_state == CM_PH_STATE_NORMAL ) )
  {
    evt = RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE;
    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE, &unsol_resp );
    qcril_send_unsol_response( &unsol_resp );
  }
  i_ptr->emer_cb_state = ph_info_ptr->ph_state;
  QCRIL_MUTEX_UNLOCK( &i_ptr->emer_cb_state_mutex, details );

  if( RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE == evt )
  {
    qcril_sms_clearing_cdma_ack( instance_id, modem_id );
  }

} /* qcril_cm_phonesvc_event_sys_sel_pref */


#ifdef FEATURE_QCRIL_DSDS
/*========================================================================= 
  FUNCTION:  qcril_cm_phonesvc_event_subscription_pref_info
 
===========================================================================*/
/*! 
    @brief
    Handle CM_PH_EVENT_SUBSCRIPTION_PREF_INFO.
 
    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_subscription_pref_info
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id, voice_modem_id;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  qcril_cm_struct_type *i_ptr;
  cm_subs_info_s_type *subs_info_ptr;
  qcril_arb_subs_prov_status_e_type subs_state;
  RIL_SelectUiccSub uicc_sub;
  sys_modem_as_id_e_type as_id, paging_priority;
  qmi_uim_session_type session_type;
  boolean new_subs_activated = FALSE;
  qcril_sub_ids_list_type sub_ids_list;
  qcril_modem_ids_list_type modem_ids_list;
  uint32 user_data;
  char details[ 80 ];
  sys_modem_dual_standby_pref_e_type standby_pref, standby_pref_with_tuneaway;   
  IxErrnoType err_no;
  qcril_unsol_resp_params_type unsol_resp;
  int subs_status;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  subs_info_ptr = ( cm_subs_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( subs_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/
                                                                                          
  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );

  /* Update subscription preference */
  i_ptr->ph_info[ modem_id ].mode_pref = subs_info_ptr->pref_info.mode_pref;
  i_ptr->ph_info[ modem_id ].gw_acq_order_pref = subs_info_ptr->pref_info.acq_order_pref;
  i_ptr->ph_info[ modem_id ].band_pref = subs_info_ptr->pref_info.band_pref;
  i_ptr->ph_info[ modem_id ].roam_pref = subs_info_ptr->pref_info.roam_pref;
  i_ptr->ph_info[ modem_id ].network_sel_mode_pref = subs_info_ptr->pref_info.network_sel_mode_pref;

  /* Sync the network preference */
  qcril_cm_sync_network_preference( instance_id );

  /* If current network selection preference is automatic, clear PLMN preference */
  if ( i_ptr->ph_info[ modem_id ].network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_AUTOMATIC )
  {
    i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 0 ] = 0xFF;
    i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 1 ] = 0xFF;
    i_ptr->ph_info[ modem_id ].plmn_pref.identity[ 2 ] = 0xFF;
  }

  /* If current network selection preference is manual and PLMN preference is wildcard, it means no change in PLMN preference
     after UE powers up since it powers down. Don't override the PLMN preference info from Android UI */
  else if ( ( i_ptr->ph_info[ modem_id ].network_sel_mode_pref == CM_NETWORK_SEL_MODE_PREF_MANUAL ) && 
            !QCRIL_CM_PLMN_PREFERENCE_IS_WILDCARD( subs_info_ptr->pref_info.plmn.identity[ 0 ], 
                                                   subs_info_ptr->pref_info.plmn.identity[ 1 ],
                                                   subs_info_ptr->pref_info.plmn.identity[ 2 ] ) )
  {
    i_ptr->ph_info[ modem_id ].plmn_pref = subs_info_ptr->pref_info.plmn;
  }

  standby_pref = i_ptr->ph_info[ modem_id ].standby_pref;

  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

  /* Lookup subs apps info */
  qcril_arb_query_subs( instance_id, &subs_state,  &uicc_sub, &as_id, &session_type );

  /* Subscription activation */
  if ( ( subs_state == QCRIL_ARB_SUBS_APPS_SELECTED ) && ( uicc_sub.act_status == RIL_UICC_SUBSCRIPTION_ACTIVATE ) )
  {
    new_subs_activated = TRUE;

    /* Marks subs as activated */
    qcril_arb_activate_subs( instance_id, subs_info_ptr->subscription_id );

    /* send unsolicited event to telephony indicating subscription is ready at modem */
    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, &unsol_resp );
    subs_status = QCRIL_CM_SUBSCRIPTION_ACTIVATED;
    unsol_resp.resp_pkt = (void *)&subs_status;
    unsol_resp.resp_len = sizeof(subs_status);

    qcril_send_unsol_response( &unsol_resp );

    /* Check whether standby preference need to be changed */
    qcril_arb_query_active_subs_list( &sub_ids_list );

    /* Two active subscriptions, need to change to Dual Standby */
    if ( sub_ids_list.num_of_subs > 1 )
    {
      standby_pref_with_tuneaway = QCRIL_CM_DUAL_STANDBY_PREF(i_ptr->ph_info[modem_id].tune_away);

      /* in case of single standby, or dual standby preference does not match with tuneaway preference, change the standby preference */
      if ( ( standby_pref == SYS_MODEM_DS_PREF_SINGLE_STANDBY ) || ( standby_pref != standby_pref_with_tuneaway ) )
      {
         paging_priority = ( i_ptr->ph_info[modem_id].paging_priority ) ? SYS_MODEM_AS_ID_2: SYS_MODEM_AS_ID_1;
   
         /* Command CM to change to dual standby mode */
         QCRIL_LOG_DEBUG( "RID %d MID %d Change to Dual Standby, pref = %d\n", instance_id, modem_id, standby_pref );
         user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_REQ_ID_INTERNAL );
         QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_dual_standby_pref()", "Dual Standby" );
         if(! qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_dual_standby_pref_func( qcril_cm_phonesvc_command_callback,
                                                                                 (void *) user_data,
                                                                                 i_ptr->client_info[ modem_id ].client_id,
                                                                                 standby_pref_with_tuneaway,
                                                                                 SYS_MODEM_AS_ID_NO_CHANGE,
                                                                                 SYS_MODEM_AS_ID_NO_CHANGE,
                                                                                 SYS_MODEM_AS_ID_NO_CHANGE,
                                                                                 paging_priority ) )
         {
           QCRIL_LOG_DEBUG( "%s \n","Change to Dual Standby, pref has failed");
         }
      }
    }
    /* First subscription being activated, make it as the default voice subscription and MT priority subscription */
    else if ( sub_ids_list.num_of_subs == 1 )
    {
      /* Command CM to change to default voice subscription and MT priority subscription */
      QCRIL_SNPRINTF( details, sizeof( details ), "Default voice / MT priority subscription, as_id %d", 
                      subs_info_ptr->subscription_id );
      QCRIL_LOG_DEBUG( "RID %d MID %d %s\n", instance_id, modem_id, details );

      QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_dual_standby_pref()", details );
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_REQ_ID_INTERNAL );
      (void) qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_dual_standby_pref_func( qcril_cm_phonesvc_command_callback,
                                                                              (void *) user_data,
                                                                              i_ptr->client_info[ modem_id ].client_id,
                                                                              SYS_MODEM_DS_PREF_NO_CHANGE,
                                                                              sub_ids_list.sub_id[ 0 ],
                                                                              sub_ids_list.sub_id[ 0 ],
                                                                              SYS_MODEM_AS_ID_NO_CHANGE,
                                                                              SYS_MODEM_AS_ID_NO_CHANGE );
    }
  }

  /* New subscription activated, trigger SMS and PBM necessary operation */
  if ( new_subs_activated )
  {
    /* Check to see whether voice radio technology is changed */
    qcril_arb_query_voice_srv_modem_id( instance_id, &voice_modem_id, &voice_radio_tech );
    if ( voice_modem_id != QCRIL_MAX_MODEM_ID )
    {
      QCRIL_LOG_DEBUG( "RID %d MID %d Update voice radio tech %d\n", instance_id, modem_id, voice_radio_tech );
      ret_ptr->voice_radio_tech_changed = TRUE;
      ret_ptr->new_voice_radio_tech = voice_radio_tech;
    }

    /* Safe to update the ECC property */
    QCRIL_LOG_DEBUG( "RID %d MID %d Update ECC property %d\n", instance_id, modem_id, voice_radio_tech );
    qcril_pbm_update_ecc_property( instance_id, voice_modem_id, TRUE );

    /* Notify SMS pref subscription info available */
    QCRIL_LOG_DEBUG( "RID %d MID %d Notify QCRIL(SMS) subscription available\n", instance_id, modem_id );
    err_no = qcril_process_event( instance_id, modem_id, QCRIL_EVT_SMS_SUBSCRIPTION_PREF_INFO, NULL, 0, 
                                  (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    QCRIL_ASSERT( err_no == E_SUCCESS );

    /* Request update of serving system information */
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_REQ_ID_INTERNAL );
    QCRIL_LOG_RPC( modem_id, "cm_ss_cmd_get_ss_info()", "client_id", i_ptr->client_info[ modem_id ].client_id );
    (void) qcril_cm_api_funcs[ modem_id ].cm_ss_cmd_get_ss_info_func( qcril_cm_srvsys_command_callback, 
                                                               (void *) user_data, 
                                                               i_ptr->client_info[ modem_id ].client_id );
  }

} /* qcril_cm_phonesvc_event_subscription_pref_info_ */


/*========================================================================= 
  FUNCTION:  qcril_cm_phonesvc_event_dual_standby_pref
 
===========================================================================*/
/*! 
    @brief
    Handle CM_PH_EVENT_DUAL_STANDBY_PREF.
 
    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_dual_standby_pref
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  cm_ph_info_s_type *ph_info_ptr;
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;
  char details[ 80 ];
  char property_name[ 40 ];
  char args[ PROPERTY_VALUE_MAX ];
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  ph_info_ptr = ( cm_ph_info_s_type *) params_ptr->data;
  QCRIL_ASSERT( ph_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );

  /* Update standby and subscription preference */
  i_ptr->ph_info[ modem_id ].standby_pref = ph_info_ptr->standby_pref;
  i_ptr->ph_info[ modem_id ].active_subs = ph_info_ptr->active_subs;
  i_ptr->ph_info[ modem_id ].default_voice_subs = ph_info_ptr->default_voice_subs;
  i_ptr->ph_info[ modem_id ].default_data_subs = ph_info_ptr->default_data_subs;
  i_ptr->ph_info[ modem_id ].priority_subs = ph_info_ptr->priority_subs;

  QCRIL_LOG_DEBUG( "DV pref == %d, DD pref = %d, Standby Pref  =%d\n",
                   ph_info_ptr->default_voice_subs, ph_info_ptr->default_data_subs, ph_info_ptr->standby_pref );
  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS ) 
  {
    if (  ( req_info.request == RIL_REQUEST_SET_SUBSCRIPTION_MODE ) ||
          ( req_info.request == RIL_REQUEST_SET_DATA_SUBSCRIPTION ) ||
          ( req_info.request == QCRIL_EVT_HOOK_SET_TUNE_AWAY )      ||
          ( req_info.request == QCRIL_EVT_HOOK_SET_PAGING_PRIORITY ) ) 
    {

      if( req_info.request == QCRIL_EVT_HOOK_SET_TUNE_AWAY )
      {

         /* update the other instance and store the changed preference to system property */
         i_ptr->ph_info[ modem_id ].tune_away = !(i_ptr->ph_info[ modem_id ].tune_away);
         qcril_cm[QCRIL_DSDS_INSTANCE_PAIR(instance_id)].ph_info[modem_id].tune_away = i_ptr->ph_info[ modem_id ].tune_away;

        QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_TUNE_AWAY);
        /* Save TUNE AWAY setting to system property */
        QCRIL_SNPRINTF( args, sizeof( args ), "%d", i_ptr->ph_info[ modem_id ].tune_away);
        if ( property_set( property_name, args ) != E_SUCCESS )
        {
          QCRIL_LOG_ERROR( "RID %d Fail to save %s to system property\n", instance_id, QCRIL_TUNE_AWAY );
        }
      }

      if( req_info.request == QCRIL_EVT_HOOK_SET_PAGING_PRIORITY )
      {
         /* update the other instance and store the changed preference to system property */
         i_ptr->ph_info[ modem_id ].paging_priority = !(i_ptr->ph_info[ modem_id ].paging_priority);
         qcril_cm[QCRIL_DSDS_INSTANCE_PAIR(instance_id)].ph_info[modem_id].paging_priority = i_ptr->ph_info[ modem_id ].paging_priority;

        QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_PAGING_PRIORITY );
        /* Save PAGING PRIORITY setting to system property */
        QCRIL_SNPRINTF( args, sizeof( args ), "%d", i_ptr->ph_info[ modem_id ].paging_priority );
        if ( property_set( property_name, args ) != E_SUCCESS )
        {
          QCRIL_LOG_ERROR( "RID %d Fail to save %s to system property\n", instance_id, QCRIL_PAGING_PRIORITY );
        }
      }

      qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
      qcril_send_request_response( &resp );
    }
  }

} /* qcril_cm_phonesvc_event_dual_standby_pref */
#endif /* FEATURE_QCRIL_DSDS */


/*========================================================================= 
  FUNCTION:  qcril_cm_phonesvc_event_prl_init
 
===========================================================================*/
/*! 
    @brief
    Handle CM_PH_EVENT_PRL_INIT.
 
    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_prl_init
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  const cm_ph_info_s_type *ph_info_ptr;
  cm_prl_pref_e_type prl_pref = CM_PRL_PREF_ANY;
  nv_item_type nv_item;
  int prl_payload, len;
  qcril_unsol_resp_params_type unsol_resp;
  char details[ 40 ], args[ PROPERTY_VALUE_MAX ];

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref_per_subs()";
  char *nv_cmd_api_name = "nv_cmd_ext_remote()";
  #else
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref()";
  char *nv_cmd_api_name = "nv_cmd_remote()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  ph_info_ptr = ( cm_ph_info_s_type *) params_ptr->data;
  QCRIL_ASSERT( ph_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore prl init event" );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );

  /* Save current prl_pref settings */
  i_ptr->ph_info[ modem_id ].prl_pref_only = ph_info_ptr->prl_pref_only;

  if ( i_ptr->ph_info[ modem_id ].prl_id != ph_info_ptr->prl_id )
  {
    i_ptr->ph_info[ modem_id ].prl_id = ph_info_ptr->prl_id;

    prl_payload = (int) ph_info_ptr->prl_id;

    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_CDMA_PRL_CHANGED, &unsol_resp );
    unsol_resp.resp_pkt = (void *) &prl_payload;
    unsol_resp.resp_len = sizeof( prl_payload );
    qcril_send_unsol_response( &unsol_resp );
  }

  QCRIL_LOG_DEBUG( "MID %d prl_pref_only=%d, prl_id=%d\n", 
                   modem_id, i_ptr->ph_info[ modem_id ].prl_pref_only, i_ptr->ph_info[ modem_id ].prl_id );

  /* Do not set prl_pref if persist.radio.set_prl_pref property is set to "false". */
  /* The property is considered to be "true" by default. */
  property_get( QCRIL_ARB_SET_PRL_PREF, args, "" );
  len = strnlen( args , 5 );
  if ( ( len > 0 ) && ( strncmp( args, "false", 5 ) == 0 ) )
  {
    QCRIL_LOG_DEBUG( "%s set to false. Return!", QCRIL_ARB_SET_PRL_PREF );
    QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );
    return;
  }
  /* Determine what prl_pref should be set to */
  if(  !i_ptr->ph_info[ modem_id ].prl_pref_only )
  {
    QCRIL_LOG_DEBUG( "%s", "prl_pref_only is FALSE - Checking HOME_SID_NID" );

    QCRIL_LOG_RPC2A( modem_id, nv_cmd_api_name, "Read NV_HOME_SID_NID_I" );
    if ( qcril_other_api_funcs[ modem_id ].nv_cmd_remote_func( NV_READ_F, NV_HOME_SID_NID_I, 
                                                               (nv_item_type *) &nv_item
                                                               #ifdef FEATURE_QCRIL_DSDS
                                                               , as_id
                                                               #endif /* FEATURE_QCRIL_DSDS */
                                                             ) == NV_DONE_S )
    {
      if ( nv_item.home_sid_nid.pair[ 0 ].sid % 2 )
      {
        QCRIL_LOG_DEBUG( "%s, Read SID Value=%d","SID is Odd - Automatic A mode selected", nv_item.home_sid_nid.pair[ 0 ].sid );
        prl_pref = CM_PRL_PREF_AVAIL_BC0_A;
      }
      else
      {
        QCRIL_LOG_DEBUG( "%s, Read SID Value=%d","SID is Even - Automatic B mode selected", nv_item.home_sid_nid.pair[ 0 ].sid );
        prl_pref = CM_PRL_PREF_AVAIL_BC0_B;
      }
    }
  }
  else
  {
    QCRIL_LOG_DEBUG("%s", "Prl_pref_only is TRUE - Automatic mode selected" );
    prl_pref = CM_PRL_PREF_ANY;
  }
  
  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

  /* Command CM to change to Auto/AutoAB System select update per SID and prl_pref_only */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_REQ_ID_INTERNAL );

  QCRIL_LOG_RPC2( modem_id, cm_ph_cmd_sys_sel_pref_api_name, details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_sys_sel_pref_func( qcril_cm_phonesvc_command_callback,
                                                                    (void *) user_data,
                                                                    i_ptr->client_info[ modem_id ].client_id,
                                                                    #ifdef FEATURE_QCRIL_DSDS
                                                                    as_id,
                                                                    #endif /* FEATURE_QCRIL_DSDS */
                                                                    CM_MODE_PREF_NO_CHANGE,
                                                                    CM_PREF_TERM_PERMANENT,
                                                                    0,
                                                                    CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                                    CM_BAND_PREF_NO_CHANGE,
                                                                    prl_pref,
                                                                    CM_ROAM_PREF_NO_CHANGE,
                                                                    CM_HYBR_PREF_NO_CHANGE,
                                                                    CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                                    CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                                                    NULL
                                                                    #ifndef FEATURE_QCRIL_DSDS
                                                                    , NULL
                                                                    #endif /* !FEATURE_QCRIL_DSDS */
                                                                  ) )
  {
    QCRIL_LOG_ERROR( "%s", "Failed to change Preference mode settings" );
  }

} /* qcril_cm_phonesvc_event_prl_init */


/*=========================================================================
  FUNCTION:  qcril_cm_phonesvc_event_subscription_available

===========================================================================*/
/*!
    @brief
    Handle CM_PH_EVENT_SUBSCRIPTION_AVAILABLE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_subscription_available
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{  
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_ph_info_s_type *ph_info_ptr;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  ph_info_ptr = ( cm_ph_info_s_type *) params_ptr->data;
  QCRIL_ASSERT( ph_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  #ifdef FEATURE_QCRIL_SUBS_CTRL
  /* Update GW subscription state */
  if ( ph_info_ptr->is_gw_subscription_available )
  {
    QCRIL_LOG_DEBUG( "%s", "Pri GW subscription enabled\n" ); 
    i_ptr->ph_info[ modem_id ].pri_gw_subscription_state = QCRIL_CM_SUBSCRIPTION_ENABLED;
  }

  /* Update CDMA subscription state */
  if ( ph_info_ptr->is_cdma_subscription_available )
  {
    QCRIL_LOG_DEBUG( "%s", "Pri CDMA subscription enabled\n" ); 
    i_ptr->ph_info[ modem_id ].pri_cdma_subscription_state = QCRIL_CM_SUBSCRIPTION_ENABLED;
  }
  #endif /* FEATURE_QCRIL_SUBS_CTRL */

  if ( ph_info_ptr->is_gw_subscription_available )
  {
    i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state = SYS_SIM_STATE_AVAILABLE;
    QCRIL_LOG_DEBUG("gw_subscription_available is available,  sim_state = %d\n",  i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state);
  }

}; /* qcril_cm_phonesvc_event_subscription_available */

#ifdef FEATURE_QCRIL_SUBS_CTRL
/*=========================================================================
  FUNCTION:  qcril_cm_phonesvc_event_subscription_not_available

===========================================================================*/
/*!
    @brief
    Handle CM_PH_EVENT_SUBSCRIPTION_NOT_AVAILABLE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_subscription_not_available
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{  
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_ph_info_s_type *ph_info_ptr;
  qcril_reqlist_public_type req_info;
  qcril_modem_ids_list_type modem_ids_done_list;
  IxErrnoType result;
  qcril_request_resp_params_type resp;
  uint32 user_data;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  ph_info_ptr = ( cm_ph_info_s_type *) params_ptr->data;
  QCRIL_ASSERT( ph_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Update GW subscription state */
  if ( !ph_info_ptr->is_gw_subscription_available )
  {
    QCRIL_LOG_DEBUG( "%s", "Pri GW subscription disabled\n" ); 
    i_ptr->ph_info[ modem_id ].pri_gw_subscription_state = QCRIL_CM_SUBSCRIPTION_DISABLED;
  }

  /* Update CDMA subscription state */
  if ( !ph_info_ptr->is_cdma_subscription_available )
  {
    QCRIL_LOG_DEBUG( "%s", "Pri CDMA subscription disabled\n" ); 
    i_ptr->ph_info[ modem_id ].pri_cdma_subscription_state = QCRIL_CM_SUBSCRIPTION_DISABLED;
  }

  /* Respond to RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE if CDMA was disabled */
  if( ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS ) &&
      ( !ph_info_ptr->is_cdma_subscription_available ) )
  {
    if ( req_info.request == RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE ) 
    {
      if ( qcril_reqlist_complete_all_amss_events( instance_id, modem_id, req_info.t, QCRIL_REQ_COMPLETED_SUCCESS,
                                                   &modem_ids_done_list, &result ) == E_SUCCESS )
      {
        if ( result == E_SUCCESS )
        {
          if ( i_ptr->ph_info[ modem_id ].rtre_control == CM_RTRE_CONTROL_NV )
          {
            QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> NV subscription\n" ); 
          }
          else 
          {
            QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> RUIM subscription\n" ); 
          }

          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp ); 
          qcril_send_request_response( &resp );
        }
        else
        {
          /* Send RIL_E_GENERIC_FAILURE response */
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
        }
      }
      
      QCRIL_LOG_RPC2A( modem_id, "cm_ph_cmd_subscription_available()", "1xEvDo" );
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_MODE_1XEVDO_CONFIG_MASK );
      (void) qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_subscription_available_func( qcril_cm_phonesvc_command_callback, 
                                                                                   (void *) user_data,
                                                                                   i_ptr->client_info[ modem_id ].client_id,
                                                                                   CM_SUBSCRIPTION_STATUS_CHANGE,
                                                                                   CM_SUBSCRIPTION_STATUS_NO_CHANGE,
                                                                                   CM_SUBSCRIPTION_STATUS_NO_CHANGE );
    }
  }

}; /* qcril_cm_phonesvc_event_subscription_not_available */
#endif /* FEATURE_QCRIL_SUBS_CTRL */


/*=========================================================================
  FUNCTION:  qcril_cm_phonesvc_event_available_networks_conf

===========================================================================*/
/*!
    @brief
    Handle CM_PH_EVENT_AVAILABLE_NETWORKS_CONF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_available_networks_conf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 i;
  const cm_ph_info_s_type *ph_info_ptr;
  qcril_reqlist_public_type req_info;
  boolean available_operator_is_current = FALSE;
  qcril_cm_available_network_type *payload_ptr;
  qcril_request_resp_params_type resp;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  ph_info_ptr = ( cm_ph_info_s_type *) params_ptr->data;
  QCRIL_ASSERT( ph_info_ptr );

  /*-----------------------------------------------------------------------*/

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS ) 
  {
    switch ( req_info.request )
    {
      case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:

        /* when network list search is aborted in access stratum, return faliure */
        if ( ph_info_ptr->available_networks_list_cnf == SYS_PLMN_LIST_AS_ABORT )
        {
          QCRIL_LOG_DEBUG("modem aborted the network list search, list_cnf = %d \n", ph_info_ptr->available_networks_list_cnf);
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
          return;
        }

        QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ss_mutex\n", instance_id );
        QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

        if ( ( payload_ptr = ( qcril_cm_available_network_type * ) qcril_malloc( sizeof( qcril_cm_available_network_type ) ) ) != NULL )
        {
          for ( i = 0; i < ph_info_ptr->available_networks.length; i++ )
          {                                                              
            /* Lookup available operator info */
            payload_ptr->available_network[ i ][ 0 ] = payload_ptr->long_eons;
            payload_ptr->available_network[ i ][ 1 ] = payload_ptr->short_eons;
            payload_ptr->available_network[ i ][ 2 ] = payload_ptr->mcc_mnc_ascii[ i ];
            available_operator_is_current = qcril_cm_ons_lookup_available_operator( instance_id,
                                                                                    ( const qcril_cm_ss_info_type *) &i_ptr->ss_info[ modem_id ], 
                                                                                    ph_info_ptr->available_networks.info[ i ].plmn,
                                                                                    &payload_ptr->available_network[ i ][ 0 ],
                                                                                    &payload_ptr->available_network[ i ][ 1 ],
                                                                                    &payload_ptr->available_network[ i ][ 2 ] );

            /* Current operator */
            if ( available_operator_is_current )
            {
              payload_ptr->available_network[ i ][ 3 ] = "current"; 
            }
            /* System is forbidden */
            else if ( ph_info_ptr->available_networks.info[ i ].plmn_forbidden )
            {
              payload_ptr->available_network[ i ][ 3 ] = "forbidden"; 
            }
            /* System is available */
            else
            {
              payload_ptr->available_network[ i ][ 3 ] = "available";
            }
          } /* end for */

          if ( ph_info_ptr->available_networks.length == 0 )
          {
            QCRIL_LOG_DEBUG( "Reply to RIL --> Number of available networks : %ld\n", 
                             ph_info_ptr->available_networks.length ); 
            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp ); 
            qcril_send_request_response( &resp );
          }
          else
          {
            QCRIL_LOG_DEBUG( "Reply to RIL --> Number of available networks : %ld\n", 
                             ph_info_ptr->available_networks.length ); 
            for ( i = 0; i < ph_info_ptr->available_networks.length; i++ )
            {
              QCRIL_LOG_DEBUG( "Reply to RIL --> Network[%ld] long EONS : %s\n", i, 
                               payload_ptr->available_network[ i ][ 0 ] ); 
              QCRIL_LOG_DEBUG( "Reply to RIL --> Network[%ld] short EONS : %s\n", i, 
                               payload_ptr->available_network[ i ][ 1 ] ); 
              QCRIL_LOG_DEBUG( "Reply to RIL --> Network[%ld] MCCMNC : %s\n", i, 
                               payload_ptr->available_network[ i ][ 2 ] ); 
              QCRIL_LOG_DEBUG( "Reply to RIL --> Network[%ld] status : %s\n", i, 
                               payload_ptr->available_network[ i ][ 3 ] ); 
            }

            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp ); 
            resp.resp_pkt = (void *) payload_ptr->available_network; 
            resp.resp_len = sizeof( char * ) * 4 * ph_info_ptr->available_networks.length;
            qcril_send_request_response( &resp );
          }

          qcril_free( payload_ptr );
        }
        else
        {
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp ); 
          qcril_send_request_response( &resp );
        }

        QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );
        break;

      /* Not sure what the RIL command is and the pass/fail criteria, response GENERIC_FAILURE */
      default:
        QCRIL_LOG_ERROR( "Unhandled CM_PH_EVENT_AVAILABLE_NETWORKS_CONF for %s (%d)\n", 
                         qcril_log_lookup_event_name( req_info.request ), req_info.request ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp ); 
        qcril_send_request_response( &resp );
        break;

    } /* end switch */
  }

}; /* qcril_cm_phonesvc_event_available_networks_conf */


/*=========================================================================
  FUNCTION:  qcril_cm_phonesvc_event_terminate_get_networks

===========================================================================*/
/*!
    @brief
    Handle CM_PH_EVENT_TERMINATE_GET_NETWORKS.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_terminate_get_networks
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  const cm_ph_info_s_type *ph_info_ptr;
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  ph_info_ptr = ( cm_ph_info_s_type *) params_ptr->data;
  QCRIL_ASSERT( ph_info_ptr );

  /*-----------------------------------------------------------------------*/

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_PH_AVAILABLE_NETWORKS_CONF, &req_info ) == E_SUCCESS ) 
  {
    switch ( req_info.request )
    {
      case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS:
        QCRIL_LOG_DEBUG( "%s", "Query available network request is terminated\n" ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp ); 
        qcril_send_request_response( &resp );
        break;

      /* Not sure what the RIL command is and the pass/fail criteria, response GENERIC_FAILURE */
      default:
        QCRIL_LOG_ERROR( "Unhandled CM_PH_EVENT_TERMINATE_GET_NETWORKS for %s (%d)\n", 
                         qcril_log_lookup_event_name( req_info.request ), req_info.request ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp ); 
        qcril_send_request_response( &resp );
        break;

    } /* end switch */
  }

}; /* qcril_cm_phonesvc_event_terminate_get_networks */


/*=========================================================================
  FUNCTION:  qcril_cm_phonesvc_event_nvruim_config_changed

===========================================================================*/
/*!
    @brief
    Handle CM_PH_EVENT_NVRUIM_CONFIG_CHANGED.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_phonesvc_event_nvruim_config_changed
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{                                                 
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_done_list;
  const cm_ph_info_s_type *ph_info_ptr;
  qcril_reqlist_public_type req_info;
  IxErrnoType result;
  qcril_request_resp_params_type resp;
  RIL_CdmaSubscriptionSource subscription_payload;
  qcril_unsol_resp_params_type unsol_resp;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  ph_info_ptr = ( cm_ph_info_s_type *) params_ptr->data;
  QCRIL_ASSERT( ph_info_ptr );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ph_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ph_mutex, details );

  i_ptr->ph_info[ modem_id ].rtre_config = ph_info_ptr->rtre_config;

  if ( ph_info_ptr->rtre_control != i_ptr->ph_info[ modem_id ].rtre_control )
  {
    i_ptr->ph_info[ modem_id ].rtre_control = ph_info_ptr->rtre_control;

    #ifdef FEATURE_QCRIL_SUBS_CTRL
    /* Detect any change in subscription control */
    if ( QCRIL_CM_MODE_CAPABILITY_SUPPORT_CDMA( i_ptr->ph_info[ modem_id ].mode_capability ) ||
         QCRIL_CM_MODE_CAPABILITY_SUPPORT_HDR( i_ptr->ph_info[ modem_id ].mode_capability ) )
    {
      ret_ptr->subscription_config_changed = TRUE;

      /* Make sure not override any GW subscription info */
      if ( ret_ptr->new_subscription_config_mask & QCRIL_SUBSCRIPTION_SIM_MASK )
      {
        ret_ptr->new_subscription_config_mask = QCRIL_SUBSCRIPTION_SIM_MASK;
      }
      else
      {
        ret_ptr->new_subscription_config_mask = 0;
      }

      switch( i_ptr->ph_info[ modem_id ].rtre_control )
      {
        case CM_RTRE_CONTROL_NONE:
        case CM_RTRE_CONTROL_NV:
          ret_ptr->new_subscription_config_mask |= QCRIL_SUBSCRIPTION_NV_MASK;
          subscription_payload = CDMA_SUBSCRIPTION_SOURCE_NV;
          break;
        case CM_RTRE_CONTROL_RUIM:
          ret_ptr->new_subscription_config_mask |= QCRIL_SUBSCRIPTION_RUIM_MASK;
          subscription_payload = CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM;
          break;
        case CM_RTRE_CONTROL_SIM:
          ret_ptr->new_subscription_config_mask |= QCRIL_SUBSCRIPTION_SIM_MASK;
          subscription_payload = CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM;
          break;
        default:
          QCRIL_LOG_ERROR( "RID %d MID %d Unexpected rtre_control %d\n", instance_id, modem_id, 
                           i_ptr->ph_info[ modem_id ].rtre_control ); 
          break;
      } /* end switch */
    }

    QCRIL_LOG_DEBUG( "RID %d MID %d Subscription mask x%x\n", instance_id, modem_id, ret_ptr->new_subscription_config_mask );
    #else
    switch( i_ptr->ph_info[ modem_id ].rtre_control )
    {
      case CM_RTRE_CONTROL_NONE:
      case CM_RTRE_CONTROL_NV:
        subscription_payload = CDMA_SUBSCRIPTION_SOURCE_NV;
        break;
      case CM_RTRE_CONTROL_RUIM:
        subscription_payload = CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM;
        break;
      case CM_RTRE_CONTROL_SIM:
        subscription_payload = CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM;
        break;
      default:
        QCRIL_LOG_ERROR( "RID %d MID %d Unexpected rtre_control %d\n", instance_id, modem_id, 
                         i_ptr->ph_info[ modem_id ].rtre_control ); 
        break;
    } /* end switch */
    #endif /* FEATURE_QCRIL_SUBS_CTRL */

    #ifdef FEATURE_QCRIL_DSDS
    if ( !qcril_arb_ma_is_dsds() )
    {
      /* Subscription source changed, need to update ECC list */
     (void) qcril_pbm_get_ecc( instance_id, modem_id, PBM_FIELD_NONE, FALSE );
    }
    #endif /* FEATURE_QCRIL_DSDS */

    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED, &unsol_resp );
    unsol_resp.resp_pkt = (void *) &subscription_payload;
    unsol_resp.resp_len = sizeof( subscription_payload );
    qcril_send_unsol_response( &unsol_resp );
  }

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS ) 
  {
    if ( req_info.request == RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE ) 
    {
      if ( req_info.sub.cm.info.rtre_config == i_ptr->ph_info[ modem_id ].rtre_config ) 
      {
        #ifdef FEATURE_QCRIL_SUBS_CTRL
        /* Update SET_SUBSCRIPTION_SOURCE to wait for subscription_not_available, if moving to NV */
        if( ( req_info.sub.cm.info.rtre_config == CM_RTRE_CONFIG_NV_ONLY ) && 
            ( i_ptr->ph_info[ modem_id ].pri_cdma_subscription_state == QCRIL_CM_SUBSCRIPTION_ENABLED ) )
        {
          if( qcril_reqlist_update_pending_event_id( instance_id, modem_id, req_info.t, 
                                                     QCRIL_EVT_CM_PH_SUBSCRIPTION_NOT_AVAILABLE ) != E_SUCCESS )
          {
            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
            qcril_send_request_response( &resp );
          }
        }
        else
        #endif
        if ( qcril_reqlist_complete_all_amss_events( instance_id, modem_id, req_info.t, QCRIL_REQ_COMPLETED_SUCCESS,
                                                     &modem_ids_done_list, &result ) == E_SUCCESS )
        {
          if ( result == E_SUCCESS )
          {
            if ( i_ptr->ph_info[ modem_id ].rtre_control == CM_RTRE_CONTROL_NV )
            {
              QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> NV subscription\n" ); 
            }
            else 
            {
              QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> RUIM subscription\n" ); 
            }

            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp ); 
            qcril_send_request_response( &resp );
          }
          else
          {
            /* Send RIL_E_GENERIC_FAILURE response */
            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
            qcril_send_request_response( &resp );
          }
        }
      }
    }
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->ph_mutex, details );

} /* qcril_cm_phonesvc_event_nvruim_config_changed*/


/*=========================================================================
  FUNCTION:  qcril_cm_prep_signal_strength_report

===========================================================================*/
/*!
    @brief
    Prepare signal strength report.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_prep_signal_strength_report
(
  RIL_SignalStrength *rpt_ptr,
  qcril_instance_id_e_type instance_id
)
{
  qcril_cm_struct_type *i_ptr;
  qcril_cm_ss_info_type *ssi_ptr;
  int gw_rssi, gw_bit_error, cdma_rssi, cdma_ecio, hdr_rssi, hdr_ecio, hdr_sinr, lte_rssi, lte_rsrp, lte_rsrq, lte_rssnr, lte_cqi;
  qcril_modem_id_e_type cdma_modem_id, evdo_modem_id, gwl_modem_id;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( rpt_ptr != NULL );
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  gw_rssi = QCRIL_CM_GW_SIGNAL_STRENGTH_UNKNOWN; 
  gw_bit_error = QCRIL_CM_GW_SIGNAL_STRENGTH_UNKNOWN;
  cdma_rssi = QCRIL_CM_SIGNAL_STRENGTH_UNKNOWN;
  cdma_ecio = QCRIL_CM_SIGNAL_STRENGTH_UNKNOWN;
  hdr_rssi = QCRIL_CM_SIGNAL_STRENGTH_UNKNOWN;
  hdr_ecio = QCRIL_CM_SIGNAL_STRENGTH_UNKNOWN;
  hdr_sinr = QCRIL_CM_SIGNAL_STRENGTH_UNKNOWN;
  lte_rssi = QCRIL_CM_GW_SIGNAL_STRENGTH_UNKNOWN; 
  lte_rsrp = QCRIL_CM_LTE_SIGNAL_STRENGTH_UNKNOWN;
  lte_rsrq = QCRIL_CM_LTE_SIGNAL_STRENGTH_UNKNOWN;
  lte_rssnr = QCRIL_CM_LTE_SIGNAL_STRENGTH_UNKNOWN;
  lte_cqi = QCRIL_CM_LTE_SIGNAL_STRENGTH_UNKNOWN;

  /* Lookup tech modem ids based on the underlying architecture */
  qcril_arb_query_arch_modem_id( &cdma_modem_id, &evdo_modem_id, &gwl_modem_id );

  /* Service is available, pack info for the signal strength */

  if ( gwl_modem_id != QCRIL_MAX_MODEM_ID )
  {
    ssi_ptr = &i_ptr->ss_info[ gwl_modem_id ];

    #ifdef FEATURE_QCRIL_LTE
    /* LTE Signal Strength */
    if ( QCRIL_CM_SRV_STATUS_INDICATES_LTE_SRV_AVAILABLE( ssi_ptr->srv_status, ssi_ptr->sys_mode ) )
    {
      QCRIL_LOG_DEBUG( "%s", "LTE signal is available.\n" );
      qcril_cm_util_rssi_to_gw_signal_strength( ssi_ptr->rssi, &lte_rssi );
      lte_rsrp = -1 * ssi_ptr->rsrp;
      lte_rsrq = -1 * ssi_ptr->rsrq;
      lte_rssnr = ssi_ptr->sinr * 2 - 200;
    }
    #endif /* FEATURE_QCRIL_LTE */

    /* GW Signal Strength */
    if ( QCRIL_CM_SRV_STATUS_INDICATES_GW_SRV_AVAILABLE( ssi_ptr->srv_status, ssi_ptr->sys_mode ) )
    {
      QCRIL_LOG_DEBUG( "%s", "GW signal is available.\n" );
      qcril_cm_util_rssi_to_gw_signal_strength( ssi_ptr->rssi, &gw_rssi );
      /* Bit error is only applicable for GSM/WCDMA */
      gw_bit_error = ssi_ptr->mode_info.gw_info.bit_err_rate;
    }
  }

  /* 1X Signal Strength */
  ssi_ptr = &i_ptr->ss_info[ cdma_modem_id ];
  if ( QCRIL_CM_SRV_STATUS_INDICATES_CDMA_SRV_AVAILABLE( ssi_ptr->srv_status, ssi_ptr->sys_mode ) )
  {
    cdma_rssi = ssi_ptr->rssi;
    cdma_ecio = ( ssi_ptr->ecio / 2 ) * 10;
  }

  /* HDR Signal Strength */
  ssi_ptr = &i_ptr->ss_info[ evdo_modem_id ];
  if ( QCRIL_CM_SRV_STATUS_INDICATES_HDR_SRV_AVAILABLE( ssi_ptr->srv_status, ssi_ptr->sys_mode ) )
  {
     hdr_rssi = ssi_ptr->rssi;
     hdr_ecio = ( ssi_ptr->ecio / 2 ) * 10;
     hdr_sinr = ssi_ptr->sinr;
  }
  else if ( QCRIL_CM_SRV_STATUS_INDICATES_HYBRID_HDR_SRV_AVAILABLE( ssi_ptr->hdr_hybrid, ssi_ptr->hdr_srv_status, 
                                                                    ssi_ptr->sys_mode ) )
  {
    hdr_rssi = ssi_ptr->hdr_rssi;
    hdr_ecio = ( ssi_ptr->hdr_ecio / 2 ) * 10;
    hdr_sinr = ssi_ptr->hdr_sinr;
  }

  rpt_ptr->GW_SignalStrength.signalStrength = gw_rssi;
  rpt_ptr->GW_SignalStrength.bitErrorRate = gw_bit_error;
  rpt_ptr->CDMA_SignalStrength.dbm = cdma_rssi;
  rpt_ptr->CDMA_SignalStrength.ecio = cdma_ecio;
  rpt_ptr->EVDO_SignalStrength.dbm = hdr_rssi;
  rpt_ptr->EVDO_SignalStrength.ecio = hdr_ecio;
  rpt_ptr->EVDO_SignalStrength.signalNoiseRatio = hdr_sinr;
  rpt_ptr->LTE_SignalStrength.signalStrength = lte_rssi;
  rpt_ptr->LTE_SignalStrength.rsrp = lte_rsrp;
  rpt_ptr->LTE_SignalStrength.rsrq = lte_rsrq;
  rpt_ptr->LTE_SignalStrength.rssnr = lte_rssnr;
  rpt_ptr->LTE_SignalStrength.cqi = lte_cqi;

  QCRIL_LOG_DEBUG( "Signal strength: gwl_rssi: %d, gw_bit_error: %d, cdma_dbm: %d, cdma_ecio: %d, hdr_dbm: %d, hdr_ecio: %d, hdr_sinr: %d, lte_rsrp %d, lte_rsrq %d\n ", 
                   rpt_ptr->GW_SignalStrength.signalStrength, rpt_ptr->GW_SignalStrength.bitErrorRate,
                   rpt_ptr->CDMA_SignalStrength.dbm, rpt_ptr->CDMA_SignalStrength.ecio,
                   rpt_ptr->EVDO_SignalStrength.dbm, rpt_ptr->EVDO_SignalStrength.ecio,
                   rpt_ptr->EVDO_SignalStrength.signalNoiseRatio, rpt_ptr->LTE_SignalStrength.rsrp, rpt_ptr->LTE_SignalStrength.rsrq ); 

} /* qcril_cm_prep_signal_strength_report */


/*=========================================================================
  FUNCTION:  qcril_cm_prep_registration_state_report

===========================================================================*/
/*!
    @brief
    Prepare registration state report.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_prep_registration_state_report
(
  boolean reporting_data_reg_state,
  qcril_arb_pref_data_tech_e_type pref_data_tech,
  qcril_cm_registration_state_type *payload_ptr,
  const qcril_cm_ss_info_type *ssi_ptr,
  cm_mode_pref_e_type mode_pref,
  qcril_cm_reg_reject_info_type *reg_reject_info_ptr
)
{
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( payload_ptr != NULL );
  if ( ( pref_data_tech != QCRIL_ARB_PREF_DATA_TECH_UNKNOWN ) &&
        ( pref_data_tech != QCRIL_ARB_PREF_DATA_TECH_INVALID ) )
  {
    QCRIL_ASSERT( ssi_ptr != NULL );
  }
  QCRIL_ASSERT( reg_reject_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  qcril_cm_util_srv_sys_info_to_reg_state( reporting_data_reg_state, pref_data_tech,
                                           &payload_ptr->registration_state[ 0 ], ssi_ptr, mode_pref, 
                                           reg_reject_info_ptr );

  qcril_cm_util_srv_sys_info_to_gw_sys_info( &payload_ptr->registration_state[ 0 ], &payload_ptr->registration_state[ 1 ], 
                                             &payload_ptr->registration_state[ 2 ], &payload_ptr->registration_state[ 14 ],
                                             payload_ptr->lac, payload_ptr->cid, payload_ptr->psc, ssi_ptr );

  qcril_cm_util_srv_sys_info_to_rej_cause( &payload_ptr->registration_state[ 0 ], &payload_ptr->registration_state[ 13 ], 
                                           reg_reject_info_ptr, ssi_ptr, reporting_data_reg_state );

  qcril_cm_util_srv_sys_info_to_avail_radio_tech ( reporting_data_reg_state, mode_pref,
                                                   &payload_ptr->registration_state[ 0 ], 
                                                   &payload_ptr->registration_state[ 3 ], ssi_ptr );

  qcril_cm_util_srv_sys_info_to_1xevdo_sys_info( payload_ptr, ssi_ptr, mode_pref );

  QCRIL_LOG_DEBUG( "Registration State: %s, RadioTech: %s, LAC: %s, CID: %s, BSID: %s, BSLat: %s, BSLong: %s\n",
                   qcril_cm_util_lookup_reg_status( payload_ptr->registration_state[ 0 ] ), 
                   qcril_cm_util_lookup_radio_tech( payload_ptr->registration_state[ 3 ] ),
                   payload_ptr->registration_state[ 1 ], payload_ptr->registration_state[ 2 ], payload_ptr->registration_state[ 4 ], 
                   payload_ptr->registration_state[ 5 ], payload_ptr->registration_state[ 6 ] ); 
  QCRIL_LOG_DEBUG( "                    CCS: %s, SID: %s, NID: %s, RoamStatus: %s, PRL: %s, DefRoamStatus: %s, RejReason: %s\n", 
                   payload_ptr->registration_state[ 7 ], payload_ptr->registration_state[ 8 ], payload_ptr->registration_state[ 9 ], 
                   payload_ptr->registration_state[ 10 ], payload_ptr->registration_state[ 11 ], payload_ptr->registration_state[ 12 ],
                   payload_ptr->registration_state[ 13 ] );

} /* qcril_cm_prep_registration_state_report */


/*=========================================================================
  FUNCTION:  qcril_cm_prep_nitz_time_received_report

===========================================================================*/
/*!
    @brief
    Prepare NITZ time received report.

    @return
    E_SUCCESS or E_FAILURE.
*/
/*=========================================================================*/
errno_enum_type qcril_cm_prep_nitz_time_received_report
(
  char *rpt_ptr,
  const qcril_cm_ss_info_type *ssi_ptr
)
{
  int len;
  uint16 year, month, day, hour, min, sec;
  int time_zone=0, daylight_saving_adj=0;
  struct timeval tv;
  struct tm *local_time=NULL;
  uint64 qw_secs =0;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( rpt_ptr != NULL );
  QCRIL_ASSERT( ssi_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  rpt_ptr[ 0 ] = '\0';

  if ( ssi_ptr->mode_info.gw_info.mm_information.univ_time_and_time_zone_avail )
  {
    year = ssi_ptr->mode_info.gw_info.mm_information.univ_time_and_time_zone.year % 100; 
    month = ssi_ptr->mode_info.gw_info.mm_information.univ_time_and_time_zone.month % 100; 
    day = ssi_ptr->mode_info.gw_info.mm_information.univ_time_and_time_zone.day % 100; 
    hour = ssi_ptr->mode_info.gw_info.mm_information.univ_time_and_time_zone.hour % 100; 
    min = ssi_ptr->mode_info.gw_info.mm_information.univ_time_and_time_zone.minute % 100; 
    sec = ssi_ptr->mode_info.gw_info.mm_information.univ_time_and_time_zone.second % 100; 
    time_zone = ssi_ptr->mode_info.gw_info.mm_information.univ_time_and_time_zone.time_zone % 100; 

    if ( ssi_ptr->mode_info.gw_info.mm_information.daylight_saving_adj_avail )
    {
      daylight_saving_adj = ssi_ptr->mode_info.gw_info.mm_information.daylight_saving_adj % 100;
    }

    QCRIL_LOG_DEBUG( "Date = %2d : %2d : %2d \n Time =%d:%d:%d \n Univ_time_zone = %d \n Dst = %d\n",
                     day,month,year,hour,min,sec,time_zone,daylight_saving_adj);
  }
  else
  {
    if (qcril_get_time(QCRIL_TIME_BASE_GSM, &tv) != 0 )
    {
      QCRIL_LOG_ERROR( "%s\n", "NITZ Get TOD Failed..." );
      return E_FAILURE;
    }
    qw_secs = (uint64)tv.tv_sec;

    if( ssi_ptr->mode_info.gw_info.mm_information.time_zone_avail)
    {
      time_zone = ssi_ptr->mode_info.gw_info.mm_information.time_zone % 100;
    }
    if ( ssi_ptr->mode_info.gw_info.mm_information.daylight_saving_adj_avail)
    {
      daylight_saving_adj = ssi_ptr->mode_info.gw_info.mm_information.daylight_saving_adj % 100;
    }
    /* In this case we are reading the current clock time using gettimeofday() which is not the actual GMT time, so we need to i
       retrieve the GMT time from the current clock time using gmtime().
       If we use localtime() in this case we again get the same clock time instead of GMT time.*/
    if( (local_time = gmtime((time_t *)&qw_secs)) == NULL ) /*Get the GMT time from time in seconds from EPOCH*/
    {
      QCRIL_LOG_ERROR("%s\n", "NITZ Get GMT Time Failed..." );
      return E_FAILURE;
    }
    year = (1900 + (local_time->tm_year))%100; /*As we get the Number of years since 1900, we have to add 1900*/
    month = local_time->tm_mon+1; /*As we get the Months from 0 to 11*/
    day = local_time->tm_mday;
    hour = local_time->tm_hour;
    min = local_time->tm_min;
    sec = local_time->tm_sec;
    QCRIL_LOG_DEBUG( "Date after reading system time = %2d : %2d : %2d \n Time =%d:%d:%d \n Univ_time_zone = %d \n Dst = %d\n",
                      day,month,year,hour,min,sec,time_zone,daylight_saving_adj);
  }

  if ( time_zone >= 0 )
  {
    len = QCRIL_SNPRINTF( rpt_ptr, QCRIL_CM_RESPONSE_NITZ_TIME_RXED_MAX_SIZE, "%02d/%02d/%02d,%02d:%02d:%02d+%02d,%02d", 
                             year, month, day, hour, min, sec, time_zone, daylight_saving_adj );
  }
  else
  {
    time_zone *= -1;
    len = QCRIL_SNPRINTF( rpt_ptr, QCRIL_CM_RESPONSE_NITZ_TIME_RXED_MAX_SIZE, "%02d/%02d/%02d,%02d:%02d:%02d-%02d,%02d", 
                             year, month, day, hour, min, sec, time_zone, daylight_saving_adj );
  }
  QCRIL_ASSERT( len <= QCRIL_CM_RESPONSE_NITZ_TIME_RXED_MAX_SIZE );

  QCRIL_LOG_DEBUG( "NITZ time received : %s\n", rpt_ptr );

  return E_SUCCESS;

} /* qcril_cm_prep_nitz_time_received_report */


/*=========================================================================
  FUNCTION:  qcril_cm_prep_1xevdo_time_received_report

===========================================================================*/
/*!
    @brief
    Prepare 1XEVDO time received report.

    @return
    E_SUCCESS or E_FAILURE.
*/
/*=========================================================================*/
errno_enum_type qcril_cm_prep_1xevdo_time_received_report
(
  char *rpt_ptr,
  const qcril_cm_ss_info_type *ssi_ptr
)
{
  int len;
  uint16 year, month, day, hour, min, sec;
  int time_zone = 0, daylight_saving_adj = 0,lp_sec = 0;
  struct timeval tv;
  struct tm *local_time = NULL;
  uint64 qw_secs = 0;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( rpt_ptr != NULL );
  QCRIL_ASSERT( ssi_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  rpt_ptr[ 0 ] = '\0';

  if (ssi_ptr->mode_info.cdma_info.time_info.sys_mode == SYS_SYS_MODE_NO_SRV)
  {
    QCRIL_LOG_ERROR("%s\n", "Invalid time info..." );
    return E_FAILURE;
  }

  if (qcril_get_time(QCRIL_TIME_BASE_CDMA, &tv) != 0 )
  {
    QCRIL_LOG_ERROR( "%s\n", "Get TOD Failed..." );
    return E_FAILURE;
  }
  qw_secs = (uint64)tv.tv_sec;

  if ( QCRIL_CM_SYS_MODE_IS_CDMA( ssi_ptr->mode_info.cdma_info.time_info.sys_mode ) )
  {
    time_zone = qcril_cm_util_convert_2s_complement_to_int( ssi_ptr->mode_info.cdma_info.time_info.time.cdma_time.ltm_offset );
    daylight_saving_adj = ssi_ptr->mode_info.cdma_info.time_info.time.cdma_time.daylt_savings;
    lp_sec = ssi_ptr->mode_info.cdma_info.time_info.time.cdma_time.lp_sec;
  }
  if ( QCRIL_CM_SYS_MODE_IS_HDR( ssi_ptr->mode_info.cdma_info.time_info.sys_mode ) )
  {
    /* modem is sending time zone in units of 1min in case of EVDO, hence converting it into units of 30min to match with that have CDMA */
    time_zone = (ssi_ptr->mode_info.cdma_info.time_info.time.hdr_time.ltm_offset) / 30;
    lp_sec = ssi_ptr->mode_info.cdma_info.time_info.time.hdr_time.lp_sec;
  }

  /* Converting the TZ into 15min offset from 30min offset(which CM sends to QCRIL) as Android understands the TZ in 15min Offset*/
  time_zone = time_zone * 2;
  qw_secs = qw_secs + (lp_sec);

  if ( ( local_time = gmtime( (time_t *) &qw_secs)) == NULL ) /*Get the GMT time from time in seconds from EPOCH*/
  {
    QCRIL_LOG_ERROR("%s\n", "TOD Get GMT Time Failed..." );
    return E_FAILURE;
  }

  year = (1900 + (local_time->tm_year))%100; /*As we get the Number of years since 1900, we have to add 1900*/
  month = local_time->tm_mon+1; /*As we get the Months from 0 to 11*/
  day = local_time->tm_mday;
  hour = local_time->tm_hour;
  min = local_time->tm_min;
  sec = local_time->tm_sec;

  if ( time_zone >= 0 )
  {
    len = QCRIL_SNPRINTF( rpt_ptr, QCRIL_CM_RESPONSE_NITZ_TIME_RXED_MAX_SIZE, "%02d/%02d/%02d,%02d:%02d:%02d+%02d,%02d",
                          year, month, day, hour, min, sec, time_zone, daylight_saving_adj );
  }
  else
  {
    time_zone *= -1;
    len = QCRIL_SNPRINTF( rpt_ptr, QCRIL_CM_RESPONSE_NITZ_TIME_RXED_MAX_SIZE, "%02d/%02d/%02d,%02d:%02d:%02d-%02d,%02d",
                          year, month, day, hour, min, sec, time_zone, daylight_saving_adj );
  }
  QCRIL_ASSERT( len <= QCRIL_CM_RESPONSE_NITZ_TIME_RXED_MAX_SIZE );

  QCRIL_LOG_DEBUG( "1XEVDO time received : %s\n", rpt_ptr );

  return E_SUCCESS;

} /* qcril_cm_prep_1xevdo_time_received_report */


/*===========================================================================

  FUNCTION:  qcril_cm_srvsys_request_voice_radio_tech

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_VOICE_RADIO_TECH

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_request_voice_radio_tech
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  char *voice_radio_tech_name[] = { "unknown", "3GPP", "3GPP2", "Global" };
  #else
  qcril_radio_tech_e_type voice_radio_tech;
  char *voice_radio_tech_name[] = { "Unknown", "GPRS", "EDGE", "UMTS", "IS95A", "IS95B", "1xRTT", "EVDO_0", "EVDO_A", "HSDPA", "HSUPA", "HSPA", "EVDO_B", "EHRPD", "LTE", "GLOBAL" };
  #endif

  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  #endif /* FEATURE_QCRIL_DSDS */

  qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech );

  if ( modem_id == QCRIL_MAX_MODEM_ID )
  {
    QCRIL_LOG_DEBUG( "%s\n", "Reply to RIL --> voice service not available" ); 
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    /* Global mode and No service */
    if ( voice_radio_tech == QCRIL_RADIO_TECH_GLOBAL )
    {
      /* Not camp on any system before */
      if ( ret_ptr->new_voice_radio_tech == QCRIL_RADIO_TECH_GLOBAL )
      {
        #ifndef FEATURE_ICS
        voice_radio_tech = QCRIL_RADIO_TECH_3GPP2;
        #else
        voice_radio_tech = QCRIL_RADIO_TECH_1xRTT;
        #endif
      }
      /* Report previous service */
      else
      {
        voice_radio_tech = ret_ptr->new_voice_radio_tech;
      }
    }

    QCRIL_LOG_DEBUG( "Reply to RIL --> voice tech %s\n", voice_radio_tech_name[ voice_radio_tech ] ); 
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    resp.resp_pkt = (void *) &voice_radio_tech;
    resp.resp_len = sizeof( voice_radio_tech );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_srvsys_request_voice_radio_tech */


/*===========================================================================

  FUNCTION:  qcril_cm_srvsys_request_operator

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_OPERATOR.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_request_operator
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{ 
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  qcril_cm_ss_info_type *ssi_ptr;
  qcril_cm_operator_type *payload_ptr;
  qcril_request_resp_params_type resp;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Lookup the modem that should provide the voice service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ss_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

  ssi_ptr = &i_ptr->ss_info[ modem_id ];

  if ( ( payload_ptr = ( qcril_cm_operator_type * ) qcril_malloc( sizeof( qcril_cm_operator_type ) ) ) != NULL )
  {
    /* Fill in info for the current operator */
    payload_ptr->operator[ 0 ] = payload_ptr->long_eons;
    payload_ptr->operator[ 1 ] = payload_ptr->short_eons;
    payload_ptr->operator[ 2 ] = payload_ptr->mcc_mnc_ascii;
    qcril_cm_ons_lookup_current_operator( instance_id, ssi_ptr, 
                                          &payload_ptr->operator[ 0 ], &payload_ptr->operator[ 1 ], &payload_ptr->operator[ 2 ] );

    QCRIL_LOG_DEBUG( "Reply to RIL --> Current operator full name : %s\n", payload_ptr->operator[ 0 ] ); 
    QCRIL_LOG_DEBUG( "Reply to RIL --> Current operator short name : %s\n", payload_ptr->operator[ 1 ] ); 
    QCRIL_LOG_DEBUG( "Reply to RIL --> Current operator MCCMNC : %s\n", payload_ptr->operator[ 2 ] ); 
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    resp.resp_pkt = (void *) payload_ptr->operator;
    resp.resp_len = sizeof( payload_ptr->operator );
    qcril_send_request_response( &resp );
    qcril_free( payload_ptr );
  }
  else
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );

} /* qcril_cm_srvsys_request_operator */


/*===========================================================================

  FUNCTION:  qcril_cm_srvsys_request_signal_strength

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SIGNAL_STRENGTH.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_request_signal_strength
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_cm_struct_type *i_ptr;
  qcril_cm_signal_strength_type *payload_ptr;
  qcril_request_resp_params_type resp;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ss_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

  if ( ( payload_ptr = ( qcril_cm_signal_strength_type * ) qcril_malloc( sizeof( qcril_cm_signal_strength_type ) ) ) != NULL )
  {
    /* Report signal strength */
    qcril_cm_prep_signal_strength_report( &payload_ptr->signal_strength, instance_id );

    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    resp.resp_pkt = (void *) &payload_ptr->signal_strength;
    resp.resp_len = sizeof( payload_ptr->signal_strength );
    qcril_send_request_response( &resp );

    qcril_free( payload_ptr );
  }
  else
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );

} /* qcril_cm_srvsys_request_signal_strength */


/*===========================================================================

  FUNCTION:  qcril_cm_srvsys_request_registration_state

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_REGISTRATION_STATE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_request_registration_state
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type cdma_modem_id, gw_modem_id, modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_cm_registration_state_type *payload1_ptr, *payload2_ptr;
  char *reg1_state_ptr, *reg2_state_ptr; 
  qcril_request_resp_params_type resp;
  char details[ 40 ], logstr[ 80 ];
  uint8 i, num_reg_state_records = 0;
  char **response;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Lookup modem id for configured to serve voice service */
  qcril_arb_query_voice_tech_modem_id( instance_id, &cdma_modem_id, &gw_modem_id );
  QCRIL_ASSERT( cdma_modem_id <= QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( gw_modem_id <= QCRIL_MAX_MODEM_ID );

  if ( ( cdma_modem_id == gw_modem_id ) && ( cdma_modem_id == QCRIL_MAX_MODEM_ID ) )
  {
    /* Should never happen */
    QCRIL_LOG_ERROR( "%s\n", "modem id not found for voice serv sys" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ss_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

  if ( ( payload1_ptr = ( qcril_cm_registration_state_type * ) qcril_malloc( sizeof( qcril_cm_registration_state_type ) ) ) == NULL )
  {
    QCRIL_LOG_ERROR( "%s\n", "Fail to allocate memory to report registration state" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );

    QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );
    return;
  }

  if ( ( payload2_ptr = ( qcril_cm_registration_state_type * ) qcril_malloc( sizeof( qcril_cm_registration_state_type ) ) ) == NULL )
  {
    QCRIL_LOG_ERROR( "%s\n", "Fail to allocate memory to report registration state" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );

    qcril_free( payload1_ptr );
    QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );
    return;
  }

  /* Report registration state */
  if ( cdma_modem_id != QCRIL_MAX_MODEM_ID ) 
  {
    modem_id = cdma_modem_id;
    qcril_cm_prep_registration_state_report( FALSE, QCRIL_ARB_PREF_DATA_TECH_UNKNOWN, payload1_ptr, &i_ptr->ss_info[ modem_id ], 
                                             i_ptr->ph_info[ modem_id ].mode_pref, &i_ptr->reg_reject_info);
    num_reg_state_records = num_reg_state_records + 1;
    response =  payload1_ptr->registration_state;
  }

  if ( ( gw_modem_id != QCRIL_MAX_MODEM_ID ) && ( gw_modem_id != cdma_modem_id ) )
  {
    modem_id = gw_modem_id;
    qcril_cm_prep_registration_state_report( FALSE, QCRIL_ARB_PREF_DATA_TECH_UNKNOWN, payload2_ptr, &i_ptr->ss_info[ modem_id ], 
                                             i_ptr->ph_info[ modem_id ].mode_pref, &i_ptr->reg_reject_info);
    num_reg_state_records = num_reg_state_records + 1;
    response =  payload2_ptr->registration_state;
  }

  /* Global device, split modem */
  if ( num_reg_state_records == 2 )
  {
    reg1_state_ptr = payload1_ptr->registration_state[ 0 ];
    reg2_state_ptr = payload2_ptr->registration_state[ 0 ];

   /*  for the following scenarios report MSM service state,
       Both MSM and MDM has no service,
       CDMA has full service, GW has no service,
       Both CDMA and GW has full service */
    response =  payload1_ptr->registration_state;

    /* GW has full service, CDMA has no service */
    if ( ( ( strcmp( reg2_state_ptr, "0" ) == 1 ) ||  ( strcmp( reg2_state_ptr, "5" ) == 0 ) ) &&
           ( ( strcmp( reg1_state_ptr, "0" ) == 0 ) ||  ( strcmp( reg1_state_ptr, "2" ) == 0 ) || 
           ( strcmp( reg1_state_ptr, REG_STATE_DENIED_EMERGENCY ) == 0 ) ) )
    {
      response =  payload2_ptr->registration_state;
    }

    QCRIL_SNPRINTF( logstr, sizeof( logstr ), "%s - %s", 
                    qcril_cm_util_lookup_reg_status( response[ 0 ] ), 
                    qcril_cm_util_lookup_radio_tech( response[ 3 ] ) );
  }
  else 
  {
    if ( cdma_modem_id != QCRIL_MAX_MODEM_ID ) 
    {
      reg1_state_ptr = payload1_ptr->registration_state[ 0 ];
    }
    else
    {
      reg1_state_ptr = payload2_ptr->registration_state[ 0 ];
    }

    if ( ( strcmp( reg1_state_ptr, "0" ) == 0 ) || ( strcmp( reg1_state_ptr, "2" ) == 0 )
          || ( strcmp( reg1_state_ptr, REG_STATE_DENIED_EMERGENCY ) == 0 ) )
    {
      QCRIL_SNPRINTF( logstr, sizeof( logstr ), "%s", qcril_cm_util_lookup_reg_status(response[0]) );
    }
    else
    {
      QCRIL_SNPRINTF( logstr, sizeof( logstr ), "%s - %s", 
                      qcril_cm_util_lookup_reg_status( response[ 0 ] ), 
                      qcril_cm_util_lookup_radio_tech( response[ 3 ] ) );
    }
  }

  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
  resp.resp_pkt = (void *) response;
  resp.resp_len = sizeof( payload1_ptr->registration_state);  
  resp.logstr = logstr;
  qcril_send_request_response( &resp );

  qcril_free( payload2_ptr );
  qcril_free( payload1_ptr );

  QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );

} /* qcril_cm_srvsys_request_registration_state */


/*===========================================================================

  FUNCTION:  qcril_cm_srvsys_request_data_registration_state

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_DATA_REGISTRATION_STATE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_request_data_registration_state
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type cdma_modem_id, evdo_modem_id, gwl_modem_id, pdt_modem_id;
  qcril_arb_pref_data_tech_e_type pref_data_tech;
  qcril_cm_struct_type *i_ptr;
  uint8 i;
  qcril_cm_registration_state_type *payload1_ptr;
  char *reg_state_ptr; 
  qcril_request_resp_params_type resp;
  char details[ 40 ], logstr[ 80 ];
  boolean found_data_tech_camped = FALSE;
  char * response[QCRIL_CM_RESPONSE_DATA_REGISTRATION_STATE_MAX_SIZE];
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Lookup modem id for configured to serve data service */
  qcril_arb_query_data_tech_modem_id( instance_id, &cdma_modem_id, &evdo_modem_id, &gwl_modem_id, &pdt_modem_id, &pref_data_tech );

  if ( ( cdma_modem_id == evdo_modem_id ) && ( evdo_modem_id == gwl_modem_id ) && ( cdma_modem_id == QCRIL_MAX_MODEM_ID ) )
  {
    /* Should never happen */
    QCRIL_LOG_ERROR( "%s\n", "modem id not found for data serv sys" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ss_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

  if ( ( payload1_ptr = ( qcril_cm_registration_state_type * ) qcril_malloc( sizeof( qcril_cm_registration_state_type ) ) ) == NULL )
  {
    QCRIL_LOG_ERROR( "%s\n", "Fail to allocate memory to report data registration state" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );
    return;
  }

  if ( !qcril_arb_ma_is_fusion() )
  {
    if ( gwl_modem_id != QCRIL_MAX_MODEM_ID )
    {
      qcril_cm_prep_registration_state_report( TRUE, pref_data_tech, payload1_ptr, &i_ptr->ss_info[ gwl_modem_id ], 
                                               i_ptr->ph_info[ gwl_modem_id ].mode_pref, &i_ptr->reg_reject_info );
      reg_state_ptr = payload1_ptr->registration_state[ 0 ];
      if ( ( strcmp( reg_state_ptr, "1" ) == 0 ) || ( strcmp( reg_state_ptr, "5" ) == 0 ) )
      {
        found_data_tech_camped = TRUE;
      }
    }

    if ( ( evdo_modem_id != QCRIL_MAX_MODEM_ID ) && !found_data_tech_camped )
    {
      qcril_cm_prep_registration_state_report( TRUE, pref_data_tech, payload1_ptr, &i_ptr->ss_info[ evdo_modem_id ], 
                                               i_ptr->ph_info[ evdo_modem_id ].mode_pref, &i_ptr->reg_reject_info );
      reg_state_ptr = payload1_ptr->registration_state[ 0 ];
      if ( ( strcmp( reg_state_ptr, "1" ) == 0 ) || ( strcmp( reg_state_ptr, "5" ) == 0 ) )
      {
        found_data_tech_camped = TRUE;
      }
    }

    if ( ( cdma_modem_id != QCRIL_MAX_MODEM_ID ) && !found_data_tech_camped )
    {
      qcril_cm_prep_registration_state_report( TRUE, pref_data_tech, payload1_ptr, &i_ptr->ss_info[ cdma_modem_id ], 
                                               i_ptr->ph_info[ cdma_modem_id ].mode_pref, &i_ptr->reg_reject_info );
    }
  }
  else
  {
    /* Preferred data tech not known */
    if ( pdt_modem_id == QCRIL_MAX_MODEM_ID )
    {
      QCRIL_LOG_DEBUG( "Preferred data tech unknown, PDT MID %d\n", pdt_modem_id );
      qcril_cm_prep_registration_state_report( TRUE, pref_data_tech, payload1_ptr, NULL, CM_MODE_PREF_NONE, &i_ptr->reg_reject_info);
    }
    /* Preferred data tech known */
    else
    {
      QCRIL_LOG_DEBUG( "Preferred data tech known, PDT MID %d\n", pdt_modem_id );
      qcril_cm_prep_registration_state_report( TRUE, pref_data_tech, payload1_ptr, &i_ptr->ss_info[ pdt_modem_id ], 
                                               i_ptr->ph_info[ pdt_modem_id ].mode_pref, &i_ptr->reg_reject_info );
    }
  }

  reg_state_ptr = payload1_ptr->registration_state[ 0 ];

  if ( ( strcmp( reg_state_ptr, "0" ) == 0 ) || ( strcmp( reg_state_ptr, "2" ) == 0 )
        || ( strcmp( reg_state_ptr, REG_STATE_DENIED_EMERGENCY ) == 0 ) )
  {
    QCRIL_SNPRINTF( logstr, sizeof( logstr ), "%s", qcril_cm_util_lookup_reg_status( payload1_ptr->registration_state[ 0 ] ) );
  }
  else
  {
    QCRIL_SNPRINTF( logstr, sizeof( logstr ), "%s - %s", 
                    qcril_cm_util_lookup_reg_status( payload1_ptr->registration_state[ 0 ] ), 
                    qcril_cm_util_lookup_radio_tech( payload1_ptr->registration_state[ 3 ]) );
  }

  /* formatting the response to match with the GB interface,
      as the response for registration/data_registration are different */
  response[0] = payload1_ptr->registration_state[0];
  response[1] = payload1_ptr->registration_state[1];
  response[2] = payload1_ptr->registration_state[2];
  response[3] = payload1_ptr->registration_state[3];
  response[4] = payload1_ptr->registration_state[13];
  /* as per DSI_MAX_DATA_CALLS defined in dsi_netctrl.h */
  response[5] = "20";

  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
  resp.resp_pkt = (void *) response;
  resp.resp_len = sizeof( response );
  resp.logstr = logstr;
  qcril_send_request_response( &resp );

  qcril_free( payload1_ptr );

  QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );

} /* qcril_cm_srvsys_request_data_registration_state */


/*===========================================================================

  FUNCTION:  qcril_cm_srvsys_request_screen_state

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SCREEN_STATE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_request_screen_state
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_cm_struct_type *i_ptr;
  int *in_data_ptr;
  uint8 i, j;
  uint32 user_data;
  qcril_request_resp_params_type resp;
  char details[ 40 ];

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_ph_cmd_wakeup_from_standby_api_name = "cm_ph_cmd_wakeup_from_standby_per_subs()";
  #else
  char *cm_ph_cmd_wakeup_from_standby_api_name = "cm_ph_cmd_wakeup_from_standby()";
  #endif /* FEATURE_QCRIL_DSDS */

  cm_ss_event_e_type ss_event_list[] = { 
    CM_SS_EVENT_RSSI,
    CM_SS_EVENT_HDR_RSSI,
  };
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (int *)params_ptr->data;
  QCRIL_ASSERT( in_data_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Invalid parameters, send RIL_E_GENERIC_FAILURE response */
  if ( params_ptr->datalen == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  switch ( *in_data_ptr )
  {
    case QCRIL_CM_SCREEN_STATE_OFF:
      QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ss_mutex\n", instance_id );
      QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

      if ( i_ptr->screen_state != QCRIL_CM_SCREEN_STATE_OFF )
      {
        i_ptr->screen_state = QCRIL_CM_SCREEN_STATE_OFF;

        if( qcril_arb_ma_is_dsds() )
        {
          /* update the other instance also so that QCRIL does not act on it when other instance receives the request */
          qcril_cm[QCRIL_DSDS_INSTANCE_PAIR(instance_id)].screen_state = QCRIL_CM_SCREEN_STATE_OFF;
        }

        /* De-register noisy CM events whenever screen changes from on to off for power optimization */
        QCRIL_LOG_DEBUG( "%s", "De-registering the RSSI, HDR RSSI events on screen-off request\n" );

        for ( i = 0; i < QCRIL_ARB_MAX_MODEMS; i++ )
        {
          QCRIL_ASSERT( i < QCRIL_MAX_MODEM_ID );
          user_data = QCRIL_COMPOSE_USER_DATA( instance_id, i, QCRIL_REQ_ID_INTERNAL );
          QCRIL_LOG_RPC( i, "cm_mm_client_ss_reg()", "client_id", i_ptr->client_info_id );

          for ( j = 0; j < QCRIL_ARR_SIZE( ss_event_list ); j++ )
          {
            if ( qcril_cm_api_funcs[ i ].cm_mm_client_ss_reg_func( i_ptr->client_info[ i ].client_id,
                                                                   qcril_cm_api_callbacks[ i ].ss_event_callback_func,
                                                                   CM_CLIENT_EVENT_DEREG,
                                                                   ss_event_list[ j ], 
                                                                   ss_event_list[ j ],
                                                                   NULL
                                                                 ) != CM_CLIENT_OK )
            {
              QCRIL_LOG_ERROR( "MID %d Fail to De-register CM SS event %d\n", i, ss_event_list[ j ] );
            }
          }
          /* Deregister CM_SS_EVENT_SRV_CHANGED only when property is enabled */
          if ( i_ptr->power_save_enabled )
          {
            QCRIL_LOG_DEBUG( "%s", "De-registering the SRV_CHANGED event on screen-off request\n" );
            if ( qcril_cm_api_funcs[ i ].cm_mm_client_ss_reg_func( i_ptr->client_info[ i ].client_id,
                                                                   qcril_cm_api_callbacks[ i ].ss_event_callback_func,
                                                                   CM_CLIENT_EVENT_DEREG,
                                                                   CM_SS_EVENT_SRV_CHANGED, 
                                                                   CM_SS_EVENT_SRV_CHANGED,
                                                                   NULL
                                                                 ) != CM_CLIENT_OK )
            {
              QCRIL_LOG_ERROR( "MID %d Fail to De-register CM SS event %d\n", i, CM_SS_EVENT_SRV_CHANGED );
            }
          }

          #ifdef FEATURE_QCRIL_NCELL
          /* Unset MODEM_INFO_MASK for power optimization */
          QCRIL_LOG_RPC( i, "cm_stats_set_modem_info_mask()", "client_id", i_ptr->client_info_id );
          if ( !qcril_cm_api_funcs[ i ].cm_stats_set_modem_info_mask_func( NULL, NULL,
                                                                           i_ptr->client_info[ i ].client_id, 
                                                                           SYS_MODEM_MODULE_GSM, 
                                                                           CM_GERAN_ENG_MODE_NONE ) )
          {
            QCRIL_LOG_ERROR( "MID %d Fail to un-set CM Stats modem GSM info mask %d\n", i, CM_GERAN_ENG_MODE_NMR_INFO );
          }
          if ( !qcril_cm_api_funcs[ i ].cm_stats_set_modem_info_mask_func( NULL, NULL,
                                                                           i_ptr->client_info[ i ].client_id,
                                                                           SYS_MODEM_MODULE_WCDMA, CM_WCDMA_INFO_MASK_NONE ) )
          {
            QCRIL_LOG_ERROR( "MID %d Fail to un-set CM Stats modem WCDMA info mask %d\n", i, CM_WCDMA_MONITORED_SET_BIT_MASK );
          }
          #endif /* FEATURE_QCRIL_NCELL */
        }

        /* Diasable dormancy indications */
        if ( qcril_data_toggle_dormancy_indications( DORMANCY_INDICATIONS_OFF ) ==  QCRIL_DS_ERROR )
        {
          QCRIL_LOG_ERROR( "%s", "Error de registering dormancy indications\n" );
        }
      }

      QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Screen off\n" ); 
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
      resp.logstr = "Off";
      qcril_send_request_response( &resp );

      QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );
      break;

    case QCRIL_CM_SCREEN_STATE_ON:

      if ( i_ptr->screen_state != QCRIL_CM_SCREEN_STATE_ON )
      {
        i_ptr->screen_state = QCRIL_CM_SCREEN_STATE_ON;

        if( qcril_arb_ma_is_dsds() )
        {
          /* update the other instance also so that QCRIL does not act on it when other instance receives the request */
          qcril_cm[QCRIL_DSDS_INSTANCE_PAIR(instance_id)].screen_state = QCRIL_CM_SCREEN_STATE_ON;
        }

        /* Register noisy CM events that was de-registered for power optimization whenever screen changes from off to on */
        QCRIL_LOG_DEBUG( "%s", "Registering the RSSI, HDR RSSI events on screen-on request\n" );

        for ( i = 0; i < QCRIL_ARB_MAX_MODEMS; i++ )
        {
          QCRIL_ASSERT( i < QCRIL_MAX_MODEM_ID );
          user_data = QCRIL_COMPOSE_USER_DATA( instance_id, i, QCRIL_REQ_ID_INTERNAL );
          QCRIL_LOG_RPC( i, "cm_mm_client_ss_reg()", "client_id", i_ptr->client_info_id );

          for ( j = 0; j < QCRIL_ARR_SIZE( ss_event_list ); j++ )
          {
            if ( qcril_cm_api_funcs[ i ].cm_mm_client_ss_reg_func( i_ptr->client_info[ i ].client_id,
                                                                   qcril_cm_api_callbacks[ i ].ss_event_callback_func,
                                                                   CM_CLIENT_EVENT_REG,
                                                                   ss_event_list[ j ], 
                                                                   ss_event_list[ j ],
                                                                   NULL
                                                                 ) != CM_CLIENT_OK )
            {
              QCRIL_LOG_ERROR( "MID %d Fail to De-register CM SS event %d\n", i, ss_event_list[ j ] );
            }
          }
          /* Register CM_SS_EVENT_SRV_CHANGED only when property is enabled */
          if ( i_ptr->power_save_enabled )
          {
            QCRIL_LOG_DEBUG( "%s", "Registering the SRV_CHANGED events on screen-on request\n" );
            if ( qcril_cm_api_funcs[ i ].cm_mm_client_ss_reg_func( i_ptr->client_info[ i ].client_id,
                                                                   qcril_cm_api_callbacks[ i ].ss_event_callback_func,
                                                                   CM_CLIENT_EVENT_REG,
                                                                   CM_SS_EVENT_SRV_CHANGED, 
                                                                   CM_SS_EVENT_SRV_CHANGED,
                                                                   NULL
                                                                 ) != CM_CLIENT_OK )
            {
              QCRIL_LOG_ERROR( "MID %d Fail to De-register CM SS event %d\n", i, CM_SS_EVENT_SRV_CHANGED );
            }
          }

          /* As we de-registered RSSI iand HDR RSSI event during screen-off we might loose some system events,
             hence trying to get the latest system information from CM */
          QCRIL_LOG_DEBUG( "%s", "requesting CM for the latest system information\n" );

          /* Request update on network information */
          user_data = QCRIL_COMPOSE_USER_DATA( instance_id, i, QCRIL_REQ_ID_INTERNAL );
          QCRIL_LOG_RPC( i, "cm_ss_cmd_get_ss_info()", "client_id", i_ptr->iclient[ i ].client_id );
          (void) qcril_cm_api_funcs[ i ].cm_ss_cmd_get_ss_info_func( qcril_cm_srvsys_command_callback, 
                                                                     (void * ) user_data, 
                                                                     i_ptr->client_info[ i ].client_id );

          #ifdef FEATURE_QCRIL_NCELL
          /* Unset MODEM_INFO_MASK for power optimization */
          QCRIL_LOG_RPC( i, "cm_stats_set_modem_info_mask()", "client_id", i_ptr->client_info_id );
          if ( !qcril_cm_api_funcs[ i ].cm_stats_set_modem_info_mask_func( NULL, NULL,
                                                                           i_ptr->client_info[ i ].client_id, 
                                                                           SYS_MODEM_MODULE_GSM, 
                                                                           CM_GERAN_ENG_MODE_NMR_INFO ) )
          {
            QCRIL_LOG_ERROR( "MID %d Fail to set CM Stats modem GSM info mask %d\n", i, CM_GERAN_ENG_MODE_NMR_INFO );
          }
          if ( !qcril_cm_api_funcs[ i ].cm_stats_set_modem_info_mask_func( NULL, NULL,
                                                                           i_ptr->client_info[ i ].client_id,
                                                                           SYS_MODEM_MODULE_WCDMA, CM_WCDMA_MONITORED_SET_BIT_MASK ) )
          {
            QCRIL_LOG_ERROR( "MID %d Fail to set CM Stats modem WCDMA info mask %d\n", i, CM_WCDMA_MONITORED_SET_BIT_MASK );
          }
          #endif /* FEATURE_QCRIL_NCELL */
        }

        /* Enable dormancy indications */
        if ( qcril_data_toggle_dormancy_indications( DORMANCY_INDICATIONS_ON ) ==  QCRIL_DS_ERROR )
        {
          QCRIL_LOG_ERROR( "%s", "Error registering dormancy indications\n" );
        }

        for ( i = 0 ; i < QCRIL_ARB_MAX_INSTANCES; i++ )
        {
          i_ptr = &qcril_cm[ i ];
          for ( j = 0; j < QCRIL_ARB_MAX_MODEMS; j++ )
          {
            QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ss_mutex\n", i );
            QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

            if ( i_ptr->ss_info[ j ].srv_status == SYS_SRV_STATUS_PWR_SAVE )
            {
              /* Modem is in powersave mode. Request it to wakeup on any keypress */
              user_data = QCRIL_COMPOSE_USER_DATA( i, j, QCRIL_REQ_ID_INTERNAL );
       
              #ifdef FEATURE_QCRIL_DSDS
              /* Lookup as_id */
              if ( qcril_arb_lookup_as_id_from_instance_id( i, &as_id ) != E_SUCCESS )
              {
                QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );
                continue;
              }
              #endif /* FEATURE_QCRIL_DSDS */

              QCRIL_LOG_RPC( j, cm_ph_cmd_wakeup_from_standby_api_name, "client_id", i_ptr->client_info[ j ].client_id );
              if ( !qcril_cm_api_funcs[ j ].cm_ph_cmd_wakeup_from_standby_func( qcril_cm_phonesvc_command_callback,
                                                                                (void * ) user_data,
                                                                                i_ptr->client_info[ j ].client_id 
                                                                                #ifdef FEATURE_QCRIL_DSDS
                                                                                , as_id
                                                                                #endif /* FEATURE_QCRIL_DSDS */
                                                                                ) )
              {
                QCRIL_LOG_ERROR( "%s", "Failed to wakeup CM from Standby/Power-Save\n" );
              }
            }
            QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );
          } /* QCRIL_ARB_MAX_MODEMS */
        } /* QCRIL_MAX_INSTANCE_ID */
      } 

      QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Screen on\n" ); 
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
      resp.logstr = "On";
      qcril_send_request_response( &resp );
      break;

    default:
      QCRIL_LOG_ERROR( "Unexpected screen state %d : Token ID %d\n", *in_data_ptr, 
                       qcril_log_get_token_id( params_ptr->t ) ); 
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
      break;

  } /* end switch */

} /* qcril_cm_srvsys_request_screen_state */


/*===========================================================================

  FUNCTION:  qcril_cm_srvsys_request_get_neighboring_cell_ids

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_GET_NEIGHBORING_CELL_IDS.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_request_get_neighboring_cell_ids
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id, cdma_modem_id, evdo_modem_id, gwl_modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 i;
  int len;
  #ifdef FEATURE_QCRIL_NCELL
  qcril_cm_neigh_cells_type *payload_ptr;
  #endif /* FEATURE_QCRIL_NCELL */
  qcril_request_resp_params_type resp;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/
 
  /* Lookup tech modem ids based on the underlying architecture */
  qcril_arb_query_arch_modem_id( &cdma_modem_id, &evdo_modem_id, &gwl_modem_id );

  /* Neigbor cell ID reporting only applies to GWL */
  if ( gwl_modem_id == QCRIL_MAX_MODEM_ID )
  {
    QCRIL_LOG_DEBUG( "%s", "neighbor cell info unavailable\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  modem_id = gwl_modem_id;

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ss_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

  #ifdef FEATURE_QCRIL_NCELL
  QCRIL_LOG_DEBUG( "srv_status %d, sys_mode %d, nmr_num_of_items %d, monitored_num_of_items %d\n", 
                   i_ptr->ss_info[ modem_id ].srv_status, i_ptr->ss_info[ modem_id ].sys_mode, i_ptr->nmr_info.num_of_items, i_ptr->monitored_set_info.num_of_items );

  if ( QCRIL_CM_SRV_STATUS_INDICATES_SRV_AVAILABLE( i_ptr->ss_info[ modem_id ].srv_status ) && 
       QCRIL_CM_SYS_MODE_IS_GSM( i_ptr->ss_info[ modem_id ].sys_mode ) && ( i_ptr->nmr_info.num_of_items > 0 ) )
  {
    if ( ( payload_ptr = ( qcril_cm_neigh_cells_type * ) qcril_malloc( sizeof( qcril_cm_neigh_cells_type ) ) ) != NULL )
    {
      for ( i = 0; i < i_ptr->nmr_info.num_of_items; i++ )
      {
        /* Android only takes CID from 0x00000000 - 0x7fffffff*/
        if ( i_ptr->nmr_info.nmr[ i ].ncell_id.cell_id > 0x7FFFFFFF )
        {
          len = QCRIL_SNPRINTF( payload_ptr->cid[ i ], QCRIL_CM_CID_ASCII_MAX_LEN, "%08x", 0xFFFFFFFF );
        }
        else
        {
          len = QCRIL_SNPRINTF( payload_ptr->cid[ i ], QCRIL_CM_CID_ASCII_MAX_LEN, "%04lx%04lx", i_ptr->nmr_info.nmr[ i ].ncell_id.lac,  i_ptr->nmr_info.nmr[ i ].ncell_id.cell_id);
        }
        payload_ptr->neighbor_cell[ i ].cid = payload_ptr->cid[ i ];
        payload_ptr->neighbor_cell[ i ].rssi = i_ptr->nmr_info.nmr[ i ].rxlev;
        payload_ptr->neighbor_cell_list[ i ] = &payload_ptr->neighbor_cell[ i ];

        QCRIL_LOG_DEBUG( "Reply to RIL --> Neighbor cell %d: cid=%s, rssi=%d\n", i, payload_ptr->neighbor_cell_list[ i ]->cid,
                         payload_ptr->neighbor_cell_list[ i ]->rssi );
      } /* end for */

      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
      resp.resp_pkt = payload_ptr->neighbor_cell_list; 
      resp.resp_len = sizeof( RIL_NeighboringCell * ) * i_ptr->nmr_info.num_of_items; 
      qcril_send_request_response( &resp );

      qcril_free( payload_ptr );

      /* Already reported, flush GSM neighbor cell info */
      memset( &i_ptr->nmr_info, 0, sizeof( i_ptr->nmr_info ) );
    }
    else
    {
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  }
  else if ( QCRIL_CM_SRV_STATUS_INDICATES_SRV_AVAILABLE( i_ptr->ss_info[ modem_id ].srv_status ) && 
       QCRIL_CM_SYS_MODE_IS_WCDMA( i_ptr->ss_info[ modem_id ].sys_mode ) && ( i_ptr->monitored_set_info.num_of_items > 0 ) )
  {
    if ( ( payload_ptr = ( qcril_cm_neigh_cells_type * ) qcril_malloc( sizeof( qcril_cm_neigh_cells_type ) ) ) != NULL )
    {
      for ( i = 0; i < i_ptr->monitored_set_info.num_of_items; i++ )
      {
        len = QCRIL_SNPRINTF( payload_ptr->cid[ i ], QCRIL_CM_CID_ASCII_MAX_LEN, "%08x", i_ptr->monitored_set_info.strongest[ i ].psc );
        payload_ptr->neighbor_cell[ i ].cid = payload_ptr->cid[ i ];
        payload_ptr->neighbor_cell[ i ].rssi = i_ptr->monitored_set_info.strongest[ i ].rscp;
        payload_ptr->neighbor_cell_list[ i ] = &payload_ptr->neighbor_cell[ i ];

        QCRIL_LOG_DEBUG( "Reply to RIL --> Neighbor cell %d: cid=%s, rssi=%d\n", i, payload_ptr->neighbor_cell_list[ i ]->cid,
                         payload_ptr->neighbor_cell_list[ i ]->rssi );
      } /* end for */

      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
      resp.resp_pkt = payload_ptr->neighbor_cell_list; 
      resp.resp_len = sizeof( RIL_NeighboringCell * ) * i_ptr->monitored_set_info.num_of_items; 
      qcril_send_request_response( &resp );

      qcril_free( payload_ptr );

      /* Already reported, flush GSM neighbor cell info */
      memset( &i_ptr->monitored_set_info, 0, sizeof( i_ptr->monitored_set_info ) );
    }
    else
    {
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  }
  else
  #endif /* FEATURE_QCRIL_NCELL */
  {
    QCRIL_LOG_DEBUG( "%s", "neighbor cell info unavailable\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );

} /* qcril_cm_srvsys_request_get_neighboring_cell_ids */


/*===========================================================================

  FUNCTION:  qcril_cm_srvsys_request_set_location_updates

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_LOCATION_UPDATES.

    Sets i_ptr->report_location_updates as per the received input(n value).  

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_request_set_location_updates
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_cm_struct_type *i_ptr;
  int *in_data_ptr;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (int *)params_ptr->data;
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "RIL_REQUEST_SET_LOCATION_UPDATES input = %d\n", in_data_ptr[0]);

  if( ( in_data_ptr[ 0 ] == 0 ) || ( in_data_ptr[ 0 ] == 1 ) )
  {
    i_ptr->report_location_updates = in_data_ptr[ 0 ];
    /* sending confirmation as we just need to store the request,
       and use it before the unsol_network_state_change response. */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    QCRIL_LOG_ERROR( "%s", "received invalid params in RIL_REQUEST_SET_LOCATION_UPDATES\n");
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_srvsys_request_set_location_updates */


/*=========================================================================
  FUNCTION:  qcril_cm_srvsys_event_emerg_num_list

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_CM_SS_EMERG_NUM_LIST.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_event_emerg_num_list
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  const cm_mm_ss_info_s_type *ss_info_ptr;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  #endif /* FEATURE_QCRIL_DSDS */
  
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  ss_info_ptr = ( cm_mm_ss_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( ss_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) == E_SUCCESS )
  {
    if ( ( as_id == SYS_MODEM_AS_ID_2 ) && ss_info_ptr->is_hybr_gw_operational ) 
    {
      /*store the network emergency numbers in qcril ecc cache*/
      if ( qcril_process_event( instance_id, modem_id, QCRIL_EVT_PBM_UPDATE_OTA_ECC_LIST, (void *) &ss_info_ptr->gw_emerg_num_list,
                                sizeof( ss_info_ptr->gw_emerg_num_list ), params_ptr->t ) != E_SUCCESS )
      {
        QCRIL_LOG_ERROR( "%s\n", "Emergency List Event QCRILPBM processing Failed!" );
      }
    }
    else if  ( as_id == SYS_MODEM_AS_ID_1 )   
    {
  #endif /* FEATURE_QCRIL_DSDS */
      /*store the network emergency numbers in qcril ecc cache*/
      if ( qcril_process_event( instance_id, modem_id, QCRIL_EVT_PBM_UPDATE_OTA_ECC_LIST, (void *)&ss_info_ptr->emerg_num_list,
                                sizeof( ss_info_ptr->emerg_num_list ), params_ptr->t ) != E_SUCCESS )
      {
        QCRIL_LOG_ERROR( "%s\n", "Emergency List Event QCRILPBM processing Failed!" );
      }
  #ifdef FEATURE_QCRIL_DSDS
    }
  }
  #endif /* FEATURE_QCRIL_DSDS */

} /* qcril_cm_srvsys_event_emerg_num_list */


#ifdef FEATURE_QCRIL_DSAC
/*=========================================================================
  FUNCTION:  qcril_cm_srvsys_event_cell_access_ind

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_CM_SS_CELL_ACCESS_IND.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_event_cell_access_ind
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  const cm_mm_ss_info_s_type *ss_info_ptr;
  int restriction_mask = 0;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  ss_info_ptr = ( cm_mm_ss_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( ss_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG("%s: Received Cell Access Indication event",__FUNCTION__);

  /* CS Domain restriction */
  switch ( ss_info_ptr->cell_access_info.cs_bar_status )
  {
    case SYS_CELL_ACCESS_NORMAL_ONLY:
      /* Allow only Normal CS calls and Block Emergency calls */
      restriction_mask = RIL_RESTRICTED_STATE_CS_EMERGENCY;
      break;

    case SYS_CELL_ACCESS_EMERGENCY_ONLY:
      /* Allow only Emergency calls and Block all Normal CS calls */
      restriction_mask = RIL_RESTRICTED_STATE_CS_NORMAL;
      break;

    case SYS_CELL_ACCESS_NO_CALLS:
      /* Block all CS calls (both normal, emergency) */
      restriction_mask = RIL_RESTRICTED_STATE_CS_ALL;
      break;

    case SYS_CELL_ACCESS_ALL_CALLS:
      /* Allow all CS calls (no restriction) */
      restriction_mask = RIL_RESTRICTED_STATE_NONE;
      break;

    default:
      QCRIL_LOG_ERROR( "Unknown CS Restriction state %d\n", ss_info_ptr->cell_access_info.cs_bar_status ); 
      return;
  }

  /* Apply PS Domain bar status to the restriction mask */
  switch ( ss_info_ptr->cell_access_info.ps_bar_status )
  {
    case SYS_CELL_ACCESS_NORMAL_ONLY:
    case SYS_CELL_ACCESS_EMERGENCY_ONLY:
    case SYS_CELL_ACCESS_NO_CALLS:
      /* Treat any restriction as full PS Domain restriction */
      restriction_mask |= RIL_RESTRICTED_STATE_PS_ALL;
      break;

    case SYS_CELL_ACCESS_ALL_CALLS:
      /* Allow all PS calls (no restriction) */
      restriction_mask |= RIL_RESTRICTED_STATE_NONE;
      break;

    default:
      QCRIL_LOG_ERROR( "Unknown PS Restriction state %d\n", ss_info_ptr->cell_access_info.ps_bar_status ); 
      return;
  }

  QCRIL_LOG_DEBUG( "Restriction mask sent from RIL to UI is (0X%x)\n", restriction_mask );

  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_RESTRICTED_STATE_CHANGED, &unsol_resp );
  unsol_resp.resp_pkt = ( void * ) &restriction_mask;
  unsol_resp.resp_len = sizeof( int );
  qcril_send_unsol_response( &unsol_resp );

} /* qcril_cm_srvsys_event_cell_access_ind */
#endif /* FEATURE_QCRIL_DSAC */


/*=========================================================================
  FUNCTION:  qcril_cm_srvsys_event_info

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_CM_SS_INFO.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_event_info
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_ss_info_s_type *ss_info_ptr;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  ss_info_ptr = ( cm_mm_ss_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( ss_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Store Serving System Info and set indicators to report network info changed */
  qcril_cm_store_srv_sys_info( instance_id, modem_id, ss_info_ptr, QCRIL_SSIC_NOTIFICATION_STATUS_INFO, 
                               &ret_ptr->voice_radio_tech_changed, &ret_ptr->new_voice_radio_tech, 
                               &ret_ptr->ssic_notification_status );

} /* qcril_cm_srvsys_event_info */


/*=========================================================================
  FUNCTION:  qcril_cm_srvsys_event_rssi

===========================================================================*/
/*!
    @brief
    Handle CM_SS_EVENT_RSSI.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_event_rssi
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_ss_info_s_type *ss_info_ptr;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  ss_info_ptr = ( cm_mm_ss_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( ss_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "Process event rssi, rild %d, mid %d\n", instance_id, modem_id );
  /* Store Serving System Info and set indicators to report network info changed */
  qcril_cm_store_srv_sys_info( instance_id, modem_id, ss_info_ptr, QCRIL_SSIC_NOTIFICATION_STATUS_RSSI, 
                               &ret_ptr->voice_radio_tech_changed, &ret_ptr->new_voice_radio_tech, 
                               &ret_ptr->ssic_notification_status );

} /* qcril_cm_srvsys_event_rssi */


/*=========================================================================
  FUNCTION:  qcril_cm_srvsys_event_srv_changed

===========================================================================*/
/*!
    @brief
    Handle CM_SS_EVENT_SRV_CHANGED.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_event_srv_changed
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_ss_info_s_type *ss_info_ptr;
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;
  boolean gw_hybrid = FALSE;
  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  #endif /* FEATURE_QCRIL_DSDS */
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  ss_info_ptr = ( cm_mm_ss_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( ss_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Store Serving System Info and set indicators to report network info changed */
  qcril_cm_store_srv_sys_info( instance_id, modem_id, ss_info_ptr, QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED, 
                               &ret_ptr->voice_radio_tech_changed, &ret_ptr->new_voice_radio_tech, 
                               &ret_ptr->ssic_notification_status );

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS ) 
  {
    switch ( req_info.request )
    {
      case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL:

        #ifdef FEATURE_QCRIL_DSDS
        /* Lookup as_id */
        if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) == E_SUCCESS )
        {
          if( as_id == SYS_MODEM_AS_ID_2 )
          {
            gw_hybrid = TRUE;
          }
        }
        #endif

        /* Full service */
        if ( QCRIL_CM_SRV_STATUS_INDICATES_GW_FULL_SRV( i_ptr->ss_info[ modem_id ].srv_status, 
                                                          i_ptr->ss_info[ modem_id ].sys_mode ) && 
              ( i_ptr->ss_info[ modem_id ].changed_fields & QCRIL_CM_SS_SRV_STATUS_MASK(gw_hybrid) ) )
        {
          QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Registered on system (Manual network selection mode)\n" );
          qcril_cancel_timed_callback( (void *) req_info.sub_id );
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
          qcril_send_request_response( &resp );
        }
        /* SIM error */
        else if( ( QCRIL_CM_SYS_MODE_IS_GW( i_ptr->ss_info[ modem_id ].sys_mode ) ) &&
                 ( ( i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state == SYS_SIM_STATE_NOT_AVAILABLE ) ||
                   ( i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state == SYS_SIM_STATE_CS_PS_INVALID ) ) )
        {
          QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Failed to register on system due to SIM error (Manual network selection mode)\n" );
          qcril_cancel_timed_callback( (void*) req_info.sub_id );
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_ILLEGAL_SIM_OR_ME, &resp );
          qcril_send_request_response( &resp ); 
        }
        break;

      case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC:
        /* SIM error */
        if( ( QCRIL_CM_SYS_MODE_IS_GW( i_ptr->ss_info[ modem_id ].sys_mode ) ) &&
            ( ( i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state == SYS_SIM_STATE_NOT_AVAILABLE ) ||
              ( i_ptr->ss_info[ modem_id ].mode_info.gw_info.sim_state == SYS_SIM_STATE_CS_PS_INVALID ) ) &&
            ( !QCRIL_CM_SRV_STATUS_INDICATES_FULL_SRV( i_ptr->ss_info[ modem_id ].srv_status ) ) )
        {
          QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Failed to register on system due to SIM error (Automatic network selection mode)\n" );
          qcril_cancel_timed_callback( (void*) req_info.sub_id );
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_ILLEGAL_SIM_OR_ME, &resp );
          qcril_send_request_response( &resp ); 
        }
        else
        {
          QCRIL_LOG_DEBUG( "%s", "Reply to RIL --> Registered on system (Automatic network selection mode)\n" ); 
          qcril_cancel_timed_callback( (void *) req_info.sub_id );
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
          qcril_send_request_response( &resp );
        }
        break;

      default:
        QCRIL_LOG_ERROR( "Unhandled CM_SS_EVENT_SRV_CHANGED for %s (%d)\n", 
                         qcril_log_lookup_event_name( req_info.request ), req_info.request ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        break;

    } /* end switch */
  }

} /* qcril_cm_srvsys_event_srv_changed */


/*=========================================================================
  FUNCTION:  qcril_cm_srvsys_event_reg_reject

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_CM_SS_REG_REJECT.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_srvsys_event_reg_reject
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_ss_info_s_type *ss_info_ptr;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID  );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID  );
  i_ptr = &qcril_cm[ instance_id ];
  ss_info_ptr = ( cm_mm_ss_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( ss_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Store Serving System Info and set indicators to report network info changed */
  qcril_cm_store_srv_sys_info( instance_id, modem_id, ss_info_ptr, QCRIL_SSIC_NOTIFICATION_STATUS_REG_REJECT, 
                               NULL, NULL, NULL );

} /* qcril_cm_srvsys_event_reg_reject */


/*=========================================================================
  FUNCTION:  qcril_cm_process_network_info

===========================================================================*/
/*!
    @brief
    Handle unsol responses related to serving system info changes.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_process_network_info
(
  qcril_instance_id_e_type instance_id,
  qcril_modem_id_e_type modem_id,
  qcril_ssic_notification_status_e_type ssic_notification_status 
)
{
  qcril_cm_struct_type *i_ptr;
  char details[ 40 ], system_details[ 80 ];
  char *srv_status_name[] = { "No service", "limited service", "acquired", "limited regional", "power save" };
  char *sys_mode_name[] = { "No service", "AMPS", "CDMA", "GSM", "HDR", "UMTS", "GPS", "GW", "WLAN", "LTE", "GWL" };
  qcril_cm_signal_strength_type *signal_ptr;
  qcril_cm_network_time_type *time_ptr;
  qcril_modem_id_e_type voice_cdma_modem_id, voice_gw_modem_id, data_cdma_modem_id, data_evdo_modem_id, data_gwl_modem_id, pdt_modem_id;
  qcril_arb_pref_data_tech_e_type pref_data_tech;
  boolean voice_network_info_updated = FALSE, data_network_info_updated = FALSE;
  boolean unsol_network_changed = FALSE;
  qcril_unsol_resp_params_type unsol_resp;
  boolean gw_hybrid = FALSE;
  uint32 changed_fields_high, changed_fields_low;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  gw_hybrid = i_ptr->ss_info[ modem_id ].gw_hybrid;

  /* Lookup modem id for voice tech */
  qcril_arb_query_voice_tech_modem_id( instance_id, &voice_cdma_modem_id, &voice_gw_modem_id );

  if ( ( modem_id == voice_cdma_modem_id ) || ( modem_id == voice_gw_modem_id ) )
  {
    voice_network_info_updated = TRUE;
  }

  /* Lookup modem id for data tech */
  qcril_arb_query_data_tech_modem_id( instance_id, &data_cdma_modem_id, &data_evdo_modem_id, &data_gwl_modem_id, 
                                      &pdt_modem_id, &pref_data_tech );

  //if ( ( pdt_modem_id == data_cdma_modem_id ) || ( pdt_modem_id == data_evdo_modem_id ) || ( pdt_modem_id == data_gwl_modem_id ) )
  if ( ( modem_id == data_cdma_modem_id ) || ( modem_id == data_evdo_modem_id ) || ( modem_id == data_gwl_modem_id ) )
  {
    data_network_info_updated = TRUE;
  }

  QCRIL_SNPRINTF( details, sizeof( details ), "qcril_cm.info[%d].ss_mutex", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

  if ( ( i_ptr->ss_info[ modem_id ].srv_status >= SYS_SRV_STATUS_NO_SRV ) && 
       ( i_ptr->ss_info[ modem_id ].srv_status <= SYS_SRV_STATUS_PWR_SAVE ) &&
       ( i_ptr->ss_info[ modem_id ].sys_mode >= SYS_SYS_MODE_NO_SRV ) && 
       ( i_ptr->ss_info[ modem_id ].sys_mode < SYS_SYS_MODE_MAX ) )
  {
    QCRIL_SNPRINTF( system_details, sizeof( system_details ), "%s on %s", 
                    srv_status_name[i_ptr->ss_info[ modem_id ].srv_status], 
                    sys_mode_name[i_ptr->ss_info[ modem_id ].sys_mode] ); 
  } 
  else 
  { 
    system_details[ 0 ] = '\0'; 
  }

  /* Modem provides no voice and data service */
  if ( !voice_network_info_updated && !data_network_info_updated )
  {
    QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );
    return;
  }

  /* See if any unsolicited response need to be sent */

  if ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_HDR_ACTIVE_PROT_MASK )
  {
    QCRIL_LOG_DEBUG( "HDR active protocol changed. New HDR active protocol %d\n", i_ptr->ss_info[ modem_id ].hdr_active_prot );
  }

  /* Always need to sync wth latest network info upon screen on */
  if ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_INFO )
  {
    unsol_network_changed = TRUE;
  }
  /* Report network state changed if the serving system info change is for the change in 
     system mode, service status, service domain, NITZ's ONS, roam status, service indicator, BS P_REV, or CS supported */
  else if ( i_ptr->ss_info[ modem_id ].changed_fields & 
            ( QCRIL_CM_SS_SYS_MODE_MASK( gw_hybrid ) | QCRIL_CM_SS_SRV_STATUS_MASK( gw_hybrid ) | QCRIL_CM_SS_TRUE_SRV_STATUS_MASK( gw_hybrid ) |
              QCRIL_CM_SS_SYS_ID_MASK( gw_hybrid ) | QCRIL_CM_SS_SRV_DOMAIN_MASK( gw_hybrid ) | QCRIL_CM_SS_SRV_CAPABILITY_MASK( gw_hybrid ) |
              QCRIL_CM_SS_MOBILITY_MGMT_MASK( gw_hybrid ) | QCRIL_CM_SS_SRV_CAPABILITY_MASK( gw_hybrid ) | QCRIL_CM_SS_ROAM_STATUS_MASK( gw_hybrid ) |
              QCRIL_CM_SS_SRV_IND_MASK( gw_hybrid ) | CM_SS_BS_P_REV_MASK | CM_SS_CCS_SUPPORTED_MASK | 
              CM_SS_HDR_SRV_STATUS_MASK | CM_SS_HDR_ROAM_STATUS_MASK | CM_SS_HDR_ACTIVE_PROT_MASK | CM_SS_HDR_SYS_ID_MASK | CM_SS_IDLE_DIGITAL_MODE_MASK ) )
  {
    unsol_network_changed = TRUE;
  }
  /* The serving system info change is for the change in CID, BSID, BS Latitude, and BS Longuitude */
  else if ( i_ptr->report_location_updates && 
            ( i_ptr->ss_info[ modem_id ].changed_fields & ( QCRIL_CM_SS_GW_CELL_INFO_MASK(gw_hybrid)| CM_SS_BASE_STATION_PARMS_CHGD_MASK ) ) )
  {
    /* Report network state changed if the screen is on */
    if ( i_ptr->screen_state == QCRIL_CM_SCREEN_STATE_ON ) 
    {
      unsol_network_changed = TRUE;
    }
  }
  else if ( voice_network_info_updated &&
            ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_REG_REJECT ) &&
            ( ( i_ptr->reg_reject_info.cm_reg_reject_info.reject_srv_domain == SYS_SRV_DOMAIN_CS_ONLY ) ||
              ( i_ptr->reg_reject_info.cm_reg_reject_info.reject_srv_domain == SYS_SRV_DOMAIN_CS_PS ) ||
              ( i_ptr->reg_reject_info.cm_reg_reject_info.reject_srv_domain == SYS_SRV_DOMAIN_PS_ONLY ) ) )
  {
    if ( ( i_ptr->ss_info[ modem_id ].srv_status == SYS_SRV_STATUS_LIMITED ) ||
         ( i_ptr->ss_info[ modem_id ].srv_status == SYS_SRV_STATUS_LIMITED_REGIONAL ) )
    {
      unsol_network_changed = TRUE;
    }
  }

  /* Network information updated, send unsolicited network state changed indication */
  /* Dont send indications during RSSI events as we dont update serving system info during RSSI events */
  if ( unsol_network_changed  && ( ssic_notification_status != QCRIL_SSIC_NOTIFICATION_STATUS_RSSI ) )
  {
    if ( voice_network_info_updated || data_network_info_updated )
    {
      qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED, &unsol_resp );
      unsol_resp.logstr = (void *) &system_details;
      qcril_send_unsol_response( &unsol_resp );
    }
  }

  /* Report signal strength */
  if ( ( i_ptr->screen_state == QCRIL_CM_SCREEN_STATE_ON ) &&
  	( ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_RSSI ) ||
  	  ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED ) ) )
  {
    if ( ( signal_ptr = ( qcril_cm_signal_strength_type * ) qcril_malloc( sizeof ( qcril_cm_signal_strength_type ) ) ) != NULL )
    {
      /* Report signal strength */
      qcril_cm_prep_signal_strength_report( &signal_ptr->signal_strength, instance_id );
      qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SIGNAL_STRENGTH, &unsol_resp );
      unsol_resp.resp_pkt = ( void * ) &signal_ptr->signal_strength;
      unsol_resp.resp_len = sizeof( signal_ptr->signal_strength );
      qcril_send_unsol_response( &unsol_resp );

      qcril_free( signal_ptr );
    }
  }

  /* Only if UE not wake up from suspend, we report the fresh network time */
  if ( ssic_notification_status == QCRIL_SSIC_NOTIFICATION_STATUS_SRV_CHANGED )
  {
    changed_fields_high = (uint32) ( i_ptr->ss_info[ modem_id ].changed_fields >> 32 );
    changed_fields_low = (uint32) ( i_ptr->ss_info[ modem_id ].changed_fields & (uint64) 0xFFFFFFFF );

    QCRIL_LOG_DEBUG( "changed_fields high(0x%x) low(0x%x), ut & tz avail = %d, tz avail =%d, dst avail =%d\n",
                      changed_fields_high,
                      changed_fields_low,
                      i_ptr->ss_info[ modem_id ].mode_info.gw_info.mm_information.univ_time_and_time_zone_avail,
                      i_ptr->ss_info[ modem_id ].mode_info.gw_info.mm_information.time_zone_avail,
                      i_ptr->ss_info[ modem_id ].mode_info.gw_info.mm_information.daylight_saving_adj_avail );

    /* Report available NITZ time message if current operator is GSM/WCDMA/LTE */
    if ( QCRIL_CM_SRV_STATUS_INDICATES_GWL_SRV_AVAILABLE( i_ptr->ss_info[ modem_id ].srv_status, 
                                                         i_ptr->ss_info[ modem_id ].sys_mode ) &&
         ( i_ptr->ss_info[ modem_id ].changed_fields & QCRIL_CM_SS_MOBILITY_MGMT_MASK(gw_hybrid)) && 
         ( ( i_ptr->ss_info[ modem_id ].mode_info.gw_info.mm_information.univ_time_and_time_zone_avail ) ||
           ( i_ptr->ss_info[ modem_id ].mode_info.gw_info.mm_information.time_zone_avail ) ||
           ( i_ptr->ss_info[ modem_id ].mode_info.gw_info.mm_information.daylight_saving_adj_avail ) ) )
    {
      if ( ( time_ptr = ( qcril_cm_network_time_type * ) qcril_malloc( sizeof ( qcril_cm_network_time_type ) ) ) != NULL )
      {
        if ( qcril_cm_prep_nitz_time_received_report( time_ptr->network_time, 
                                                      &i_ptr->ss_info[ modem_id ]) == E_SUCCESS )
        {
          qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_NITZ_TIME_RECEIVED, &unsol_resp );
          unsol_resp.resp_pkt = ( void * ) time_ptr->network_time;
          unsol_resp.resp_len = sizeof( time_ptr->network_time );
          qcril_send_unsol_response( &unsol_resp );
        }

        qcril_free( time_ptr );
      }
    }

    /* Report available CDMA Time of Day message if current operator is 1XEVDO */
    if ( QCRIL_CM_SRV_STATUS_INDICATES_1XEVDO_SRV_AVAILABLE( i_ptr->ss_info[ modem_id ].srv_status, 
                                                             i_ptr->ss_info[ modem_id ].sys_mode, 
                                                             i_ptr->ss_info[ modem_id ].hdr_hybrid, 
                                                             i_ptr->ss_info[ modem_id ].hdr_srv_status ) &&
         ( i_ptr->ss_info[ modem_id ].changed_fields & CM_SS_CDMA_TIME_CHGD_MASK ) )
    {
      if ( ( time_ptr = ( qcril_cm_network_time_type * ) qcril_malloc( sizeof ( qcril_cm_network_time_type ) ) ) != NULL )
      {
        if ( qcril_cm_prep_1xevdo_time_received_report( time_ptr->network_time, 
                                                        &i_ptr->ss_info[ modem_id ] ) == E_SUCCESS )
        {
          qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_NITZ_TIME_RECEIVED, &unsol_resp );
          unsol_resp.resp_pkt = ( void * ) time_ptr->network_time;
          unsol_resp.resp_len = sizeof( time_ptr->network_time );
          qcril_send_unsol_response( &unsol_resp );
        }

        qcril_free( time_ptr );
      }
    }
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );

} /* qcril_cm_process_network_info() */


/*===========================================================================

  FUNCTION:  qcril_cm_send_unsol_call_state_changed

===========================================================================*/
/*!
    @brief
    Send RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED.
 
    @return
    none
*/
/*=========================================================================*/
void qcril_cm_send_unsol_call_state_changed
(
  qcril_instance_id_e_type instance_id
)
{
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );

  /*-----------------------------------------------------------------------*/

  /* Report the call state change for voice or CS data calls */

  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED, &unsol_resp );
  qcril_send_unsol_response( &unsol_resp );

} /* qcril_cm_send_unsol_call_state_changed */


/*===========================================================================

  FUNCTION:  qcril_cm_callsvc_request_dial

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_DIAL.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_request_dial
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  uint32 user_data;
  RIL_Dial *in_data_ptr;
  cm_call_id_type call_id;
  cm_srv_type_e_type srv_type;
  cm_digit_mode_e_type digit_mode;
  cm_call_type_e_type call_type;
  cm_num_s_type calling_number, called_number;
  cm_orig_alpha_s_type alpha_buf;
  cm_gw_cs_orig_params_s_type gw_cs_orig_params;
  cm_gw_cs_orig_params_s_type *gw_cs_orig_params_ptr = &gw_cs_orig_params;
  cm_bearer_capability_s_type *bearer_capability_ptr = &gw_cs_orig_params.bearer_capability_1;
  cm_cdma_orig_params_s_type cdma_orig_params;
  cm_cdma_orig_params_s_type *cdma_orig_params_ptr = &cdma_orig_params;
  char details[ 80 ];
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  #ifdef FEATURE_QCRIL_CALL_ORIG_EXTEN
  cm_cc_generic_params_s_type cc_params;
  #endif /* FEATURE_QCRIL_CALL_ORIG_EXTEN */

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_1; /* In case of emergency call, AS_ID_1 be acquired limited service */
  char *cm_mm_call_cmd_orig_api_name = "cm_mm_call_cmd_orig_per_subs()";
  #else
  char *cm_mm_call_cmd_orig_api_name = "cm_mm_call_cmd_orig()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (RIL_Dial *)params_ptr->data;
  QCRIL_ASSERT( in_data_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  if ( params_ptr->datalen == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  if ( strlen( in_data_ptr->address ) > CM_MAX_NUMBER_CHARS ) 
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if(qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS)
  {
     /* this should happen only in case of emergency calls without SIM card present,
        since subscription is not available(mapping), hardcoding it*/
     as_id = (instance_id == QCRIL_DEFAULT_INSTANCE_ID)? SYS_MODEM_AS_ID_1: SYS_MODEM_AS_ID_2;
     QCRIL_LOG_DEBUG( "AS_ID assigned for emergency call = %d\n", as_id);
  }
  #endif /* FEATURE_QCRIL_DSDS */

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ss_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

  if ( ( QCRIL_RADIO_TECH_IS_3GPP2(voice_radio_tech) ) || ( voice_radio_tech == QCRIL_RADIO_TECH_GLOBAL ) )
  {
    srv_type = CM_SRV_TYPE_CDMA_AUTOMATIC;
    /* For 1XEVDO mode, use 4-bit DTMF encoding to make sure optimal digits can be packed in origination message */
    digit_mode = CM_DIGIT_MODE_4BIT_DTMF;
  }
  else
  {
    srv_type = CM_SRV_TYPE_GSM_WCDMA;
    /* For GW mode, use 8-bit ASCII encoding */
    digit_mode = CM_DIGIT_MODE_8BIT_ASCII;
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_CALL_ORIG, NULL, &reqlist_entry ); 
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /* Initialize origination number */
  QCRIL_LOG_RPC2A( modem_id, "cm_num_init()", "" );
  qcril_cm_api_funcs[ modem_id ].cm_num_init_func( &calling_number );
  calling_number.number_plan = CM_NPI_ISDN;

  /* Initialize dialed number */
  QCRIL_LOG_RPC2A( modem_id, "cm_num_fill()", "" );
  qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &called_number, ( uint8 * )in_data_ptr->address, 
                                                   strlen( in_data_ptr->address ), digit_mode );

  called_number.buf[ strlen( in_data_ptr->address ) ] = '\0';
  called_number.number_plan = CM_NPI_ISDN;

  /* Initialize call type */
  call_type = CM_CALL_TYPE_VOICE;

  alpha_buf.buf[ 0 ] = '\0';
  alpha_buf.len = 0;

  #ifdef FEATURE_QCRIL_CALL_ORIG_EXTEN
  memset( &cc_params, 0, sizeof(cc_params) );
  cc_params.is_fdn_to_check = TRUE;
  #elif !defined( FEATURE_QCRIL_CALL_ORIG_EXTEN3 )
  /* Below FDN check code leg can be removed once the modem call control feature is turned on */
  /* Check if the number is emergency. FDN check should not be performed on emergency numbers */
  if ( qcril_cm_util_is_emer_number( (char*) called_number.buf ) != E_SUCCESS )
  {
    /* Number is not emergency. Now perform FDN check if enabled */
    if ( !qcril_cm_fdn_check_is_passed( instance_id, modem_id, (const char*) called_number.buf, called_number.len ) )
    {
      QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].call_fail_cause_mutex\n", instance_id );
      QCRIL_MUTEX_LOCK( &i_ptr->call_fail_cause_mutex, details );
      /* Record that the last call failed because of FDN check failure */
      i_ptr->call_fail_cause = CALL_FAIL_FDN_BLOCKED;
      QCRIL_MUTEX_UNLOCK( &i_ptr->call_fail_cause_mutex, details );

      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_FDN_CHECK_FAILURE, &resp );
      qcril_send_request_response( &resp );
      return;
    }
  }
  #endif /* FEATURE_QCRIL_CALL_ORIG_EXTEN */

  if ( srv_type == CM_SRV_TYPE_GSM_WCDMA )
  {
    /* Setup GSM/WCDMA origination paramaters */
    memset( &gw_cs_orig_params, 0, sizeof( gw_cs_orig_params ) );

    QCRIL_LOG_RPC2( modem_id, "cm_util_default_gw_orig_params", "" );
    qcril_cm_api_funcs[ modem_id ].cm_util_default_gw_orig_params_func( gw_cs_orig_params_ptr ); 

    QCRIL_LOG_RPC2( modem_id, "cm_util_set_default_voice_bearer_cap", "" );
    qcril_cm_api_funcs[ modem_id ].cm_util_set_default_voice_bearer_cap_func( bearer_capability_ptr );    

    /* Below parameters are not initialized by cm_util_default_gw_orig_params(), need to do explicit initialization to
       enforce retaining good values after above RPC calls */
    gw_cs_orig_params.call_control_completed = FALSE;

    #ifdef FEATURE_QCRIL_UUS
    /* Set UUS paramater */
    if ( in_data_ptr->uusInfo != NULL )
    {
      gw_cs_orig_params.mo_user_data.present = TRUE;
      gw_cs_orig_params.mo_user_data.user_user_type = UUS1_IMPLICIT;
      gw_cs_orig_params.mo_user_data.user_user_data_length = in_data_ptr->uusInfo->uusLength;
      gw_cs_orig_params.mo_user_data.user_user_protocol_disc = in_data_ptr->uusInfo->uusDcs;
      gw_cs_orig_params.mo_user_data.more_data_indicator= FALSE ;
      if ( gw_cs_orig_params.mo_user_data.user_user_data_length > MAX_USER_USER_DATA_LENGTH )
      {
        QCRIL_LOG_DEBUG( "Invalid UUS data Length = %s\n", "Setting to Max length" );
        gw_cs_orig_params.mo_user_data.user_user_data_length = MAX_USER_USER_DATA_LENGTH;
      }

      if ( in_data_ptr->uusInfo->uusData != NULL )
      {
        memcpy( gw_cs_orig_params.mo_user_data.user_user_data,
                in_data_ptr->uusInfo->uusData,gw_cs_orig_params.mo_user_data.user_user_data_length );
      }
    }
    else
    #endif /* FEATURE_QCRIL_UUS */
    {
      gw_cs_orig_params.mo_user_data.present = FALSE;
    }

    /* Use CLIR setting specified in DIAL request */
    if ( in_data_ptr->clir == QCRIL_CM_SS_CLIR_INVOCATION_OPTION )
    {
      gw_cs_orig_params.cm_clir = 11;
    }
    /* Use CLIR setting specified in DIAL request */
    else if ( in_data_ptr->clir == QCRIL_CM_SS_CLIR_SUPPRESSION_OPTION )
    {
      gw_cs_orig_params.cm_clir = 12;   
    }
    /* Use the default CLIR setting */
    else
    {
      if ( i_ptr->clir == QCRIL_CM_SS_CLIR_INVOCATION_OPTION )
      {
        gw_cs_orig_params.cm_clir = 11;
      }
      else if ( i_ptr->clir == QCRIL_CM_SS_CLIR_SUPPRESSION_OPTION )
      {
        gw_cs_orig_params.cm_clir = 12;   
      }
      else
      {
        gw_cs_orig_params.cm_clir = 0;   
      }
    }

    if ( i_ptr->tty_mode != QCRIL_CM_TTY_MODE_OFF ) 
    {
      gw_cs_orig_params.bearer_capability_1.ctm = 1;
    }
    else
    {
      gw_cs_orig_params.bearer_capability_1.ctm = 0;
    }

    QCRIL_LOG_DEBUG( "gw_cs_orig_params: clir=%d, call_control_completed=%d\n",
                     gw_cs_orig_params.cm_clir, gw_cs_orig_params.call_control_completed );

    QCRIL_LOG_DEBUG( "gw_cs_orig_params: (bearer_capability_1) present=%d, radio_channel_requirement=%d, coding_standard=%d\n",
                     gw_cs_orig_params.bearer_capability_1.present, gw_cs_orig_params.bearer_capability_1.radio_channel_requirement,
                     gw_cs_orig_params.bearer_capability_1.coding_standard );

    QCRIL_LOG_DEBUG( "gw_cs_orig_params: (bearer_capability_1) transfer_mode=%d, info_transfer_capability=%d, ctm=%d\n",
                     gw_cs_orig_params.bearer_capability_1.transfer_mode, 
                     gw_cs_orig_params.bearer_capability_1.information_transfer_capability, gw_cs_orig_params.bearer_capability_1.ctm );

    QCRIL_LOG_DEBUG( "gw_cs_orig_params: (bearer_capability_1.gsm_speech_ver): pref0=%d, pref1=%d, pref2=%d, pref3=%d, pref4=%d, pref5=%d\n", 
                     gw_cs_orig_params.bearer_capability_1.gsm_speech_ver_pref_0,
                     gw_cs_orig_params.bearer_capability_1.gsm_speech_ver_pref_1,
                     gw_cs_orig_params.bearer_capability_1.gsm_speech_ver_pref_2,
                     gw_cs_orig_params.bearer_capability_1.gsm_speech_ver_pref_3,
                     gw_cs_orig_params.bearer_capability_1.gsm_speech_ver_pref_4,
                     gw_cs_orig_params.bearer_capability_1.gsm_speech_ver_pref_5 );

    QCRIL_LOG_DEBUG( "gw_cs_orig_paramss: (bearer_capability_1) compression = %d, structure=%d, duplex_mode=%d\n", 
                     gw_cs_orig_params.bearer_capability_1.compression, gw_cs_orig_params.bearer_capability_1.structure,
                     gw_cs_orig_params.bearer_capability_1.duplex_mode );

    QCRIL_LOG_DEBUG( "gw_cs_orig_params: (mo_user_data) present=%d, type=%d, data_length=%d, protocol_disc=%d, more_data_indicator=%d\n",
                     gw_cs_orig_params.mo_user_data.present, gw_cs_orig_params.mo_user_data.user_user_type, 
                     gw_cs_orig_params.mo_user_data.user_user_data_length, gw_cs_orig_params.mo_user_data.user_user_protocol_disc, 
                     gw_cs_orig_params.mo_user_data.more_data_indicator );

    cdma_orig_params_ptr = NULL;
  }
  else
  {
    /* Setup CDMA origination parameters */
    memset( &cdma_orig_params, 0, sizeof( cdma_orig_params ) );
    QCRIL_LOG_RPC2( modem_id, "cm_util_default_cdma_orig_params", "" );
    qcril_cm_api_funcs[ modem_id ].cm_util_default_cdma_orig_params_func( &cdma_orig_params );

    gw_cs_orig_params_ptr = NULL;
  }

  /* Command CM to originate MO call */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, srv type %d, called number %s", 
                  qcril_log_get_token_id( params_ptr->t ), srv_type, called_number.buf);
  QCRIL_LOG_RPC2( modem_id, cm_mm_call_cmd_orig_api_name, details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_orig_func( 
                                                                 #ifdef FEATURE_QCRIL_CALL_ORIG_EXTEN3
                                                                 qcril_cm_callsvc_command_callback_exten,
                                                                 #else
                                                                 qcril_cm_callsvc_command_callback,
                                                                 #endif
                                                                 (void *) user_data,
                                                                 i_ptr->client_info[ modem_id ].client_id,
                                                                 call_type,
                                                                 srv_type,
                                                                 #ifdef FEATURE_QCRIL_DSDS
                                                                 as_id,
                                                                 #endif /* FEATURE_QCRIL_DSDS */
                                                                 &calling_number,
                                                                 &called_number,
                                                                 &alpha_buf,
                                                                 cdma_orig_params_ptr,
                                                                 gw_cs_orig_params_ptr,
                                                                 NULL,
                                                                 #ifdef FEATURE_QCRIL_CALL_ORIG_EXTEN
                                                                 NULL,
                                                                 &cc_params,
                                                                 #elif defined( FEATURE_QCRIL_CALL_ORIG_EXTEN3 )
                                                                 NULL,
                                                                 CM_ORIG_CLIENT_CATEG_USER,
                                                                 #endif /* FEATURE_QCRIL_CALL_ORIG_EXTEN */
                                                                 &call_id ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    QCRIL_LOG_DEBUG( "Dial request, assigned call id = %d\n", call_id );
  }

} /* qcril_cm_callsvc_request_dial() */


/*===========================================================================

  FUNCTION:  qcril_cm_callsvc_request_answer

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_ANSWER.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_request_answer
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{ 
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  qcril_cm_clist_call_ids_list_type call_ids_list;
  cm_ans_params_s_type ans_params;
  char details[ 80 ];
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Lookup Call ID */
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, QCRIL_CM_CLIST_STATE_INCOMING, &call_ids_list );

  /* No Call ID is found */
  if ( call_ids_list.num_of_call_ids == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  
  /* Request service on the same modem as the MT call is received */
  modem_id = call_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_CALL_ANSWER, NULL, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = call_ids_list.call_id[ 0 ];
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /* Command CM to answer incoming voice call */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  if ( call_ids_list.call_mode[ 0 ] == CM_CALL_MODE_INFO_CDMA )
  {
    ans_params.info_type = CM_CALL_MODE_INFO_CDMA;
    ans_params.ans_params.cdma_ans.call_type = CM_CALL_TYPE_VOICE;
    QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, call id %d, info type %d, call type %d", 
                    qcril_log_get_token_id( params_ptr->t ), call_ids_list.call_id[ 0 ], ans_params.info_type,
                    ans_params.ans_params.cdma_ans.call_type );
    QCRIL_LOG_RPC2( modem_id, "cm_mm_call_cmd_answer()", details );
  }
  else 
  {
    ans_params.info_type = CM_CALL_MODE_INFO_GW_CS;
    ans_params.ans_params.gw_cs_ans.accept = TRUE;
    ans_params.ans_params.gw_cs_ans.call_type = CM_CALL_TYPE_VOICE;

    QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, call id %d, info type %d, accept %d, call type %d", 
                    qcril_log_get_token_id( params_ptr->t ), call_ids_list.call_id[ 0 ], ans_params.info_type,
                    ans_params.ans_params.gw_cs_ans.accept, ans_params.ans_params.gw_cs_ans.call_type );
  }

  QCRIL_LOG_RPC2( modem_id, "cm_mm_call_cmd_answer()", details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_answer_func( qcril_cm_callsvc_command_callback, 
                                                                   (void *) user_data, 
                                                                   i_ptr->client_info[ modem_id ].client_id,
                                                                   call_ids_list.call_id[ 0 ],
                                                                   &ans_params ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_callsvc_request_answer() */


/*===========================================================================

  FUNCTION:  qcril_cm_callsvc_request_hangup

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_HANGUP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_request_hangup
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  int *conn_index_ptr;
  qcril_cm_clist_public_type call_info;
  cm_end_params_s_type end_params;
  char details[ 80 ];
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  conn_index_ptr = ( int *) params_ptr->data; 
  QCRIL_ASSERT( conn_index_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  if ( params_ptr->datalen == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Lookup Call ID based on specified Connection Index */
  if ( qcril_cm_clist_query_by_conn_index( instance_id, *conn_index_ptr, &call_info ) != E_SUCCESS ) 
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Request service on the same modem as the voice call is active */
  modem_id = call_info.modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* A call Id associated with the specified Connectin Index is found, add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_CALL_END, NULL, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = call_info.call_id;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /* Command CM to end the call */
  memset( &end_params, 0, sizeof( end_params ) );
  end_params.call_id = call_info.call_id;
  end_params.info_type = call_info.call_mode;

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, call id %d, mode info %d", 
                  qcril_log_get_token_id( params_ptr->t ), end_params.call_id, end_params.info_type );
  QCRIL_LOG_RPC2( modem_id, "cm_mm_call_cmd_end()", details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_end_func( qcril_cm_callsvc_command_callback, 
                                                                (void *) user_data, 
                                                                i_ptr->client_info[ modem_id ].client_id,
                                                                1,
                                                                &end_params ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_callsvc_request_hangup() */


/*===========================================================================

  FUNCTION:  qcril_cm_callsvc_request_get_current_calls

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_GET_CURRENT_CALLS.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_request_get_current_calls 
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_cm_clist_call_info_list_type *call_info_ptr;
  uint32 i;
  char *call_state[ 6 ] = { "Active", "Holding", "Dialing", "Alerting", "Incoming", "Waiting" };
  qcril_cm_current_calls_type *payload_ptr;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  if ( ( payload_ptr = ( qcril_cm_current_calls_type * ) qcril_malloc( sizeof ( qcril_cm_current_calls_type ) ) ) == NULL )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* We should be able to derive the response through stored call list info. */
  call_info_ptr = ( qcril_cm_clist_call_info_list_type * ) qcril_malloc( sizeof( qcril_cm_clist_call_info_list_type ) );
  if ( call_info_ptr == NULL )
  {
    QCRIL_LOG_ERROR( " %s", "Fail to qcril_malloc for call_info_list\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );

    qcril_free( payload_ptr );
    return;
  }

  qcril_cm_clist_query_call_info_list( instance_id, call_info_ptr );

  for ( i = 0; i < call_info_ptr->num_of_calls; i++ )
  {
    switch ( call_info_ptr->info[ i ].state )       
    {
      case QCRIL_CM_CLIST_STATE_ACTIVE:
        payload_ptr->info[ i ].state = RIL_CALL_ACTIVE;
        break;

      case QCRIL_CM_CLIST_STATE_HOLDING:
        payload_ptr->info[ i ].state = RIL_CALL_HOLDING;
        break;

      case QCRIL_CM_CLIST_STATE_DIALING:
        payload_ptr->info[ i ].state = RIL_CALL_DIALING;
        break;

      case QCRIL_CM_CLIST_STATE_ALERTING:
        payload_ptr->info[ i ].state = RIL_CALL_ALERTING;
        break;

      case QCRIL_CM_CLIST_STATE_INCOMING:
        payload_ptr->info[ i ].state = RIL_CALL_INCOMING;
        break;

      case QCRIL_CM_CLIST_STATE_WAITING:
        payload_ptr->info[ i ].state = RIL_CALL_WAITING;
        break;

      default:
        QCRIL_LOG_DEBUG( "Unknown call state %d\n",  call_info_ptr->info[i].state );       
        break;
    }

    payload_ptr->info[ i ].index = call_info_ptr->info[ i ].conn_index;

    if ( call_info_ptr->info[i].num.buf[ 0 ] == '+' )
    {
      payload_ptr->info[ i ].toa = 145;
    }
    else 
    {
      payload_ptr->info[ i ].toa = 129;
    }

    if ( ( ( call_info_ptr->info[ i ].state == QCRIL_CM_CLIST_STATE_ACTIVE ) ||
           ( call_info_ptr->info[ i ].state == QCRIL_CM_CLIST_STATE_HOLDING ) ) && 
         ( ( call_info_ptr->info[ i ].call_type == CM_CALL_TYPE_VOICE ) ||
           ( call_info_ptr->info[ i ].call_type == CM_CALL_TYPE_EMERGENCY ) ) && 
         call_info_ptr->in_mpty )
    {
      payload_ptr->info[ i ].isMpty = 1;
    }
    else
    {
      payload_ptr->info[ i ].isMpty = 0;
    }

    payload_ptr->info[ i ].isMT = ( call_info_ptr->info[ i ].direction == CM_CALL_DIRECTION_MT ) ? 1 : 0;
    payload_ptr->info[ i ].als = ( call_info_ptr->info[ i ].line == CM_ALS_LINE_02 ) ? 1 : 0;

    if ( QCRIL_CM_CLIST_CALL_TYPE_IS_VOICE( call_info_ptr->info[ i ].call_type ) ) 
    {
      payload_ptr->info[ i ].isVoice = 1;
      payload_ptr->info[ i ].isVoicePrivacy = call_info_ptr->info[ i ].is_private;
    }
    else
    {
      payload_ptr->info[ i ].isVoice = 0;
    }

    payload_ptr->info[ i ].number = (char *) &call_info_ptr->info[ i ].num.buf;
    payload_ptr->info[ i ].numberPresentation = call_info_ptr->info[ i ].num.pi;
    payload_ptr->info[ i ].name = call_info_ptr->info[ i ].name;
    payload_ptr->info[ i ].namePresentation = call_info_ptr->info[ i ].name_presentation;

    #ifdef FEATURE_QCRIL_UUS
    payload_ptr->info[ i ].uusInfo = NULL;

    /* Below paramaters are used for User-User-Signalling service */
    if ( qcril_cm_clist_is_uus_call( instance_id, call_info_ptr->info[ i ].modem_id, call_info_ptr->info[ i ].call_id ) &&
         call_info_ptr->info[i].uus_data.mt_user_data.present )
    {
      QCRIL_LOG_DEBUG( "Is MT UUS Data Available = %d\n", call_info_ptr->info[ i ].uus_data.mt_user_data.present );
      payload_ptr->uus_info[ i ].uusType = call_info_ptr->info[ i ].uus_data.mt_user_data.user_user_type;
      payload_ptr->uus_info[ i ].uusDcs = call_info_ptr->info[ i ].uus_data.mt_user_data.user_user_protocol_disc;
      payload_ptr->uus_info[ i ].uusLength = call_info_ptr->info[ i ].uus_data.mt_user_data.user_user_data_length;
      payload_ptr->uus_info[ i ].uusData = (char *) call_info_ptr->info[ i ].uus_data.mt_user_data.user_user_data;
      payload_ptr->info[ i ].uusInfo = &payload_ptr->uus_info[ i ];
    }
    #endif /* FEATURE_QCRIL_UUS */
     
    payload_ptr->info_ptr[ i ] = &payload_ptr->info[ i ];
    payload_ptr->num_of_calls += 1;

  } /* end for */

  if ( payload_ptr->num_of_calls == 0 )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Number of calls : %ld\n", payload_ptr->num_of_calls ); 
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );

    // Reset call waiting timer
    QCRIL_LOG_DEBUG( "Reset call waiting parameters" );
    t_rx_previous_waiting_call_id_time.tv_sec = 0;
    memset( &previous_waiting_call_number, 0, sizeof( previous_waiting_call_number ) );
  }
  else
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Number of calls : %ld\n", payload_ptr->num_of_calls ); 
    for ( i = 0; i < payload_ptr->num_of_calls; i++ )
    {
      QCRIL_LOG_DEBUG( "Reply to RIL --> call[%ld] : %s, index %d, toa %d, isMpty %d, isMT %d, als %d, isVoice %d, isVoicePrivacy %d\n",
                       i, call_state[ payload_ptr->info_ptr[ i ]->state ], payload_ptr->info_ptr[ i ]->index, 
                       payload_ptr->info_ptr[ i ]->toa, payload_ptr->info_ptr[ i ]->isMpty, payload_ptr->info_ptr[ i ]->isMT, 
                       payload_ptr->info_ptr[ i ]->als, payload_ptr->info_ptr[ i ]->isVoice, 
                       payload_ptr->info_ptr[ i ]->isVoicePrivacy );

      QCRIL_LOG_DEBUG( "                           num %s, num presentation %d, name %s, name presentation %d\n", 
                       payload_ptr->info_ptr[ i ]->number, payload_ptr->info_ptr[ i ]->numberPresentation,
                       payload_ptr->info_ptr[ i ]->name, payload_ptr->info_ptr[ i ]->namePresentation  ); 
    } /* end for */

    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    resp.resp_pkt = (void *) &payload_ptr->info_ptr;
    resp.resp_len = sizeof( RIL_Call * ) * payload_ptr->num_of_calls;
    qcril_send_request_response( &resp );
  }

  qcril_free( call_info_ptr );

  qcril_free( payload_ptr );

} /* qcril_cm_callsvc_request_get_current_calls() */


/*===========================================================================

  FUNCTION:  qcril_cm_callsvc_request_last_call_fail_cause

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_LAST_CALL_FAIL_CAUSE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_request_last_call_fail_cause
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_cm_struct_type *i_ptr;
  qcril_request_resp_params_type resp;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].call_fail_cause_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->call_fail_cause_mutex, details );

  if ( i_ptr->call_fail_cause == CALL_FAIL_NORMAL )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : Normal (%d)\n", i_ptr->call_fail_cause ); 
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_BUSY )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : Busy (%d)\n", i_ptr->call_fail_cause ); 
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_CONGESTION )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : Congestion (%d)\n", i_ptr->call_fail_cause ); 
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_ACM_LIMIT_EXCEEDED )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : ACM limit exceeded (%d)\n", i_ptr->call_fail_cause ); 
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_FDN_BLOCKED )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : FDN Check Failed (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_CDMA_LOCKED_UNTIL_POWER_CYCLE )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : CDMA locked until power cycle (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_CDMA_DROP )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : CDMA drop (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_CDMA_INTERCEPT )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : CDMA intercept (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_CDMA_REORDER )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : CDMA reorder (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_CDMA_SO_REJECT )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : CDMA SO reject (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_CDMA_RETRY_ORDER )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : CDMA retry order (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_CDMA_ACCESS_FAILURE )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : CDMA access failure (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_CDMA_PREEMPTED )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : CDMA preempted (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_CDMA_NOT_EMERGENCY )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : CDMA not emergency (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_IMSI_UNKNOWN_IN_VLR )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : IMSI unknown in VLR (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_IMEI_NOT_ACCEPTED )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : IMEI not accepted (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_CDMA_ACCESS_BLOCKED )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : CDMA Access Blocked (%d)\n", i_ptr->call_fail_cause );
  }
  else if ( i_ptr->call_fail_cause == CALL_FAIL_ERROR_UNSPECIFIED )
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Last call fail cause : Error unspecified (%d)\n", i_ptr->call_fail_cause );
  }

  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
  resp.resp_pkt = (void *) &i_ptr->call_fail_cause;
  resp.resp_len = sizeof( i_ptr->call_fail_cause );
  qcril_send_request_response( &resp );

  QCRIL_MUTEX_UNLOCK( &i_ptr->call_fail_cause_mutex, details );

} /* qcril_cm_callsvc_request_last_call_fail_cause() */


/*===========================================================================

  FUNCTION:  qcril_cm_callsvc_request_query_tty_mode

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_QUERY_TTY_MODE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_request_query_tty_mode
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  uint8 i;
  nv_stat_enum_type nv_status = NV_FAIL_S;
  nv_item_type nv_item;
  int nv_to_ril_tty_mode[ ] = { QCRIL_CM_TTY_MODE_FULL, QCRIL_CM_TTY_MODE_VCO, QCRIL_CM_TTY_MODE_HCO, QCRIL_CM_TTY_MODE_OFF };
  char *ril_tty_mode_name[ ] = { "TTY off", "TTY full", "TTY HCO", "TTY VCO" };
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *nv_cmd_api_name = "nv_cmd_ext_remote()";
  #else
  char *nv_cmd_api_name = "nv_cmd_remote()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should be requested for NV service */ 
  if ( qcril_arb_query_nv_srv_modem_id( QCRIL_ARB_NV_SRV_CAT_COMMON, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* In case of global device for split modem architecture, OEM is required to make sure the NV item values on both modems 
     are in sync. So read from one modem and write to the rest */
  for ( i = 0; i < modem_ids_list.num_of_modems; i++ )
  {
    modem_id = modem_ids_list.modem_id[ i ];
    QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

    if ( i == 0 )
    {
      QCRIL_LOG_RPC2A( modem_id, nv_cmd_api_name, "read NV_TTY_I" );
      nv_status = qcril_other_api_funcs[ modem_id ].nv_cmd_remote_func( NV_READ_F, NV_TTY_I, (nv_item_type *) &nv_item 
                                                                        #ifdef FEATURE_QCRIL_DSDS
                                                                        , as_id
                                                                        #endif /* FEATURE_QCRIL_DSDS */
                                                                      );

      if ( ( nv_status != NV_DONE_S ) && ( nv_status != NV_NOTACTIVE_S ) )
      {
        QCRIL_LOG_ERROR( "%s", "Read NV TTY setting failed.\n" );
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        break;
      }

      /* Inactive or Invalid TTY mode, default to TTY Off */
      if ( ( nv_status == NV_NOTACTIVE_S ) || ( nv_item.tty > QCRIL_CM_TTY_MODE_VCO ) )
      {
        /* Write TTY setting to NV. */
        nv_item.tty = 3; 
        QCRIL_LOG_RPC2A( modem_id, nv_cmd_api_name, "write NV_TTY_I" );
        nv_status = qcril_other_api_funcs[ modem_id ].nv_cmd_remote_func( NV_WRITE_F, NV_TTY_I, (nv_item_type *) &nv_item 
                                                                          #ifdef FEATURE_QCRIL_DSDS
                                                                          , as_id
                                                                          #endif /* FEATURE_QCRIL_DSDS */
                                                                        );

        if ( nv_status != NV_DONE_S )
        {
          QCRIL_LOG_ERROR( "%s", " Write new TTY setting to NV failed.\n" );
          qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
          return;
        }
      }

      /* Map NV TTY mode value to RIL TTY mode value */
      i_ptr->tty_mode = nv_to_ril_tty_mode[ nv_item.tty ];
    }
    else
    {
      /* Write TTY setting to NV. */
      QCRIL_LOG_RPC2A( modem_id, nv_cmd_api_name, "write NV_TTY_I" );
      nv_status = qcril_other_api_funcs[ modem_id ].nv_cmd_remote_func( NV_WRITE_F, NV_TTY_I, (nv_item_type *) &nv_item 
                                                                        #ifdef FEATURE_QCRIL_DSDS
                                                                        , as_id
                                                                        #endif /* FEATURE_QCRIL_DSDS */
                                                                      );

      if ( nv_status != NV_DONE_S )
      {
        QCRIL_LOG_ERROR( "%s", " Write new TTY setting to NV failed.\n" );
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        return;
      }
    } 
  }

  QCRIL_LOG_DEBUG( "Reply to RIL --> %s\n", ril_tty_mode_name[ i_ptr->tty_mode ] ); 

  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
  resp.resp_pkt = (void *) &i_ptr->tty_mode; 
  resp.resp_len = sizeof( i_ptr->tty_mode );
  qcril_send_request_response( &resp );

} /* qcril_cm_callsvc_request_query_tty_mode() */


/*===========================================================================

  FUNCTION:  qcril_cm_callsvc_request_set_tty_mode

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_TTY_MODE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_request_set_tty_mode
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  uint8 i;
  qcril_modem_ids_list_type modem_ids_list;
  qcril_cm_struct_type *i_ptr;
  int *tty_mode_ptr;
  nv_stat_enum_type nv_status = NV_FAIL_S;
  nv_item_type nv_item;
  int ril_to_nv_tty_mode[ ] = { 3, 0, 2, 1 }; /* Map qcril_cm_tty_mode_e_type to value used by NV e.g. QCRIL_CM_TTY_MODE_OFF (index 0) maps to 3 in NV. */
  char *ril_tty_mode_name[ ] = { "TTY off", "TTY full", "TTY HCO", "TTY VCO" };
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *nv_cmd_api_name = "nv_cmd_ext_remote()";
  #else
  char *nv_cmd_api_name = "nv_cmd_remote()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  tty_mode_ptr = ( int * )params_ptr->data;
  QCRIL_ASSERT( tty_mode_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Verify the parameters are valid */
  if ( params_ptr->datalen == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  if ( (*tty_mode_ptr < QCRIL_CM_TTY_MODE_OFF) || (*tty_mode_ptr > QCRIL_CM_TTY_MODE_VCO) ) 
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should be requested for NV service */ 
  if ( qcril_arb_query_nv_srv_modem_id( QCRIL_ARB_NV_SRV_CAT_3GPP2, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Write TTY setting to NV. */
  for ( i = 0; i < modem_ids_list.num_of_modems; i++ )
  {
    modem_id = modem_ids_list.modem_id[ i ];
    QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

    nv_item.tty = ril_to_nv_tty_mode[ *tty_mode_ptr ]; 
    QCRIL_LOG_RPC2A( modem_id, nv_cmd_api_name, "write NV_TTY_I" );
    nv_status = qcril_other_api_funcs[ modem_id ].nv_cmd_remote_func( NV_WRITE_F, NV_TTY_I, (nv_item_type *) &nv_item 
                                                                      #ifdef FEATURE_QCRIL_DSDS
                                                                      , as_id
                                                                      #endif /* FEATURE_QCRIL_DSDS */
                                                                    );

    if ( nv_status != NV_DONE_S )
    {
      QCRIL_LOG_ERROR( "%s", " Write new TTY setting to NV failed.\n" );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
      return;
    }
  }

  i_ptr->tty_mode = *tty_mode_ptr;

  QCRIL_LOG_DEBUG( "Reply to RIL --> %s\n", ril_tty_mode_name[ i_ptr->tty_mode ] ); 
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
  qcril_send_request_response( &resp );

} /* qcril_cm_callsvc_request_set_tty_mode() */


/*===========================================================================

  FUNCTION:  qcril_cm_callsvc_request_cdma_query_preferred_voice_privacy_mode

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_request_cdma_query_preferred_voice_privacy_mode
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_modem_ids_list_type modem_ids_list;
  nv_stat_enum_type nv_status = NV_FAIL_S;
  nv_item_type nv_item;
  int voice_privacy_pref;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *nv_cmd_api_name = "nv_cmd_ext_remote()";
  #else
  char *nv_cmd_api_name = "nv_cmd_remote()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should be requested for NV service */ 
  if ( qcril_arb_query_nv_srv_modem_id( QCRIL_ARB_NV_SRV_CAT_3GPP2, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* In case of global device for split modem architecture, only one modem is programmed to support CDMA. So read from 
     one modem is sufficient */ 
  modem_id = modem_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  QCRIL_LOG_RPC2A( modem_id, nv_cmd_api_name, "read NV_VOICE_PRIV_I" );
  nv_status = qcril_other_api_funcs[ modem_id ].nv_cmd_remote_func( NV_READ_F, NV_VOICE_PRIV_I, (nv_item_type *) &nv_item 
                                                                    #ifdef FEATURE_QCRIL_DSDS
                                                                    , as_id
                                                                    #endif /* FEATURE_QCRIL_DSDS */
                                                                  );
  if ( ( nv_status != NV_DONE_S ) && ( nv_status != NV_NOTACTIVE_S ) )
  {
    QCRIL_LOG_ERROR( "%s", "Read current Voice Privacy Mode from NV failed.\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    /* Inactive VOICE_PRIVACY, default to standard voice privacy */
    if ( nv_status == NV_NOTACTIVE_S )
    {
      nv_item.voice_priv = 0; 
      QCRIL_LOG_RPC2A( modem_id, nv_cmd_api_name, "write NV_VOICE_PRIV_I" );
      nv_status = qcril_other_api_funcs[ modem_id ].nv_cmd_remote_func( NV_WRITE_F, NV_VOICE_PRIV_I, (nv_item_type *) &nv_item 
                                                                        #ifdef FEATURE_QCRIL_DSDS
                                                                        , as_id
                                                                        #endif /* FEATURE_QCRIL_DSDS */
                                                                      );

      if ( nv_status != NV_DONE_S )
      {
        QCRIL_LOG_ERROR( "%s", " Write new VOICE PRIVACY setting to NV failed.\n" );
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
    }
    else
    {
      if ( nv_item.voice_priv == 0 ) 
      {
        voice_privacy_pref = QCRIL_CM_VOICE_PRIVACY_MODE_STANDARD;
        QCRIL_LOG_DEBUG( "%s", "Reply to RIL -->  standard voice privacy\n" );
      }
      else
      {
        voice_privacy_pref = QCRIL_CM_VOICE_PRIVACY_MODE_ENHANCED;
        QCRIL_LOG_DEBUG( "%s", "Reply to RIL -->  enhanced voice privacy\n" );
      }

      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
      resp.resp_pkt = (void * ) &voice_privacy_pref; 
      resp.resp_len = sizeof( voice_privacy_pref );
      qcril_send_request_response( &resp );

    }
  }

} /* qcril_cm_callsvc_request_cdma_query_preferred_voice_privacy_mode() */


/*===========================================================================

  FUNCTION:  qcril_cm_callsvc_request_cdma_set_preferred_voice_privacy_mode

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_request_cdma_set_preferred_voice_privacy_mode
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_modem_ids_list_type modem_ids_list;
  uint32 user_data;
  int *privacy_pref_ptr;
  boolean request_is_valid = TRUE;
  qcril_reqlist_u_type u_info;
  qcril_cm_req_info_type *req_info_ptr = &u_info.cm.info;
  qcril_cm_clist_call_ids_list_type call_id_list;
  char *privacy_mode_name = NULL;
  char details[80];
  nv_stat_enum_type nv_status = NV_FAIL_S;
  nv_item_type nv_item;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *nv_cmd_api_name = "nv_cmd_ext_remote()";
  #else
  char *nv_cmd_api_name = "nv_cmd_remote()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  privacy_pref_ptr = ( int * ) params_ptr->data;
  QCRIL_ASSERT( privacy_pref_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Verify the parameters are valid */
  if ( params_ptr->datalen == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  switch ( *privacy_pref_ptr )
  {
    case QCRIL_CM_VOICE_PRIVACY_MODE_STANDARD:
      req_info_ptr->privacy_pref = CM_PRIVACY_PREF_STANDARD;
      privacy_mode_name = "Standard";
      break;

    case QCRIL_CM_VOICE_PRIVACY_MODE_ENHANCED:
      req_info_ptr->privacy_pref = CM_PRIVACY_PREF_ENHANCED;
      privacy_mode_name = "Enhanced";
      break;

    default:
      request_is_valid = FALSE;
      break;
  } /* end switch */

  if ( !request_is_valid )
  {
    QCRIL_LOG_ERROR( "%s", " Invalid Voice Privacy Mode.\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should be requested for NV service */ 
  if ( qcril_arb_query_nv_srv_modem_id( QCRIL_ARB_NV_SRV_CAT_3GPP2, instance_id, &modem_ids_list ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* In case of global device for split modem architecture, only one modem is programmed to support CDMA. So write to 
     one modem is sufficient */ 
  modem_id = modem_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Write Privacy Pref Mode to NV. */
  nv_item.voice_priv = *privacy_pref_ptr; 

  QCRIL_LOG_RPC2A( modem_id, nv_cmd_api_name, "write NV_VOICE_PRIV_I" );
  nv_status = qcril_other_api_funcs[ modem_id ].nv_cmd_remote_func( NV_WRITE_F, NV_VOICE_PRIV_I, (nv_item_type *) &nv_item
                                                                    #ifdef FEATURE_QCRIL_DSDS
                                                                    , as_id
                                                                    #endif /* FEATURE_QCRIL_DSDS */
                                                                  );
  if ( nv_status != NV_DONE_S )
  {
    QCRIL_LOG_ERROR( "%s", " Write new Voice Privacy Mode to NV failed.\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Check if there is active voice call */
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, QCRIL_CM_CLIST_STATE_ACTIVE, &call_id_list );
  if ( ( call_id_list.num_of_call_ids == 0 ) || ( call_id_list.call_mode[ 0 ] != CM_CALL_MODE_INFO_CDMA ) )
  {
    /* No active CDMA voice call */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* There is an active CDMA voice call. Command CM to change voice privacy mode */

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_CALL_PRIVACY_PREF, &u_info, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = call_id_list.call_id[ 0 ];
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add entry to ReqList */
    return;
  }

  /* Command CM to change voice privacy mode */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_SNPRINTF( details, sizeof( details ), "%s, Token ID %d, call id %d", 
                  privacy_mode_name, qcril_log_get_token_id( params_ptr->t ), call_id_list.call_id[ 0 ] );
  QCRIL_LOG_RPC2( modem_id, "cm_mm_call_cmd_privacy_pref()", details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_privacy_pref_func( qcril_cm_callsvc_command_callback, 
                                                                         (void *) user_data, 
                                                                         i_ptr->client_info[ modem_id ].client_id,
                                                                         call_id_list.call_id[ 0 ],
                                                                         req_info_ptr->privacy_pref ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_callsvc_request_cdma_set_preferred_voice_privacy_mode() */


/*===========================================================================

  FUNCTION:  qcril_cm_callsvc_request_cdma_flash

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_FLASH.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_request_cdma_flash
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  char *flash_ptr;
  boolean emergency_flashed = FALSE;
  cm_call_id_type call_id;
  cm_num_s_type calling_number, dial_number;
  cm_orig_alpha_s_type alpha_buf;
  cm_cdma_orig_params_s_type cdma_orig_params;
  cm_call_sups_params_s_type sups_params;
  qcril_cm_clist_call_ids_list_type call_ids_list;
  qcril_reqlist_u_type u_info;
  char details[ 200 ];
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  #ifdef FEATURE_QCRIL_CALL_ORIG_EXTEN
  cm_cc_generic_params_s_type cc_params;
  #endif /* FEATURE_QCRIL_CALL_ORIG_EXTEN */

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_1; /* In case of emergency call, AS_ID_1 be acquired limited service */
  char *cm_mm_call_cmd_orig_api_name = "cm_mm_call_cmd_orig_per_subs()";
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_cmd_sups_per_subs()";
  #else
  char *cm_mm_call_cmd_orig_api_name = "cm_mm_call_cmd_orig()";
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_cmd_sups()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  flash_ptr = ( char * )params_ptr->data;
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Check if there is active voice call */
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, QCRIL_CM_CLIST_STATE_ACTIVE, &call_ids_list );
  if ( call_ids_list.num_of_call_ids == 0 )
  {
    QCRIL_LOG_ERROR( "%s", "No active voice call, FLASH not allowed\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  (void) qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ); 
  #endif /* FEATURE_QCRIL_DSDS */

  /* Request service on the modem that has the active voice call up */
  modem_id = call_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  if ( flash_ptr != NULL )
  {
    /* Check whether it is an emergency flash. If it is an emergency flash, remember to command CM to switch to emergency mode
       after the voice call is ended */
    if ( ( qcril_cm_util_is_emer_number( flash_ptr ) ) == E_SUCCESS )
    {
      QCRIL_LOG_DEBUG( "%s", "Flash with emergency number.\n" );
      emergency_flashed = TRUE;
    }
  }

  /* Add entry to ReqList */
  if ( emergency_flashed ) 
  {
    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                 QCRIL_EVT_CM_CALL_ORIG, &u_info, &reqlist_entry ); 
    if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
    {
      /* Fail to add to ReqList */
      return;
    }

    /* Initialize origination number */
    QCRIL_LOG_RPC2A( modem_id, "cm_num_init()", "" );
    qcril_cm_api_funcs[ modem_id ].cm_num_init_func( &calling_number );
    calling_number.number_plan = CM_NPI_ISDN;

    /* Initialize dial number */
    QCRIL_LOG_RPC2A( modem_id, "cm_num_fill()", "" );
    qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &dial_number, ( uint8 * ) flash_ptr, strlen( flash_ptr ), 
                                                       CM_DIGIT_MODE_4BIT_DTMF );
    dial_number.buf[ strlen( flash_ptr ) ] = '\0';
    dial_number.number_plan = CM_NPI_ISDN;

    alpha_buf.buf[0]='\0';
    alpha_buf.len = 0;

    /* Setup CDMA origination parameters */
    memset( &cdma_orig_params, 0, sizeof( cdma_orig_params ) );
    QCRIL_LOG_RPC2( modem_id, "cm_util_default_cdma_orig_params", "" );
    qcril_cm_api_funcs[ modem_id ].cm_util_default_cdma_orig_params_func( &cdma_orig_params );

    #ifdef FEATURE_QCRIL_CALL_ORIG_EXTEN
    memset( &cc_params, 0, sizeof(cc_params) );
    cc_params.is_fdn_to_check = TRUE;
    #endif /* FEATURE_QCRIL_CALL_ORIG_EXTEN */

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
    QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, called number %s", 
                    qcril_log_get_token_id( params_ptr->t ), dial_number.buf);

    QCRIL_LOG_RPC2( modem_id, cm_mm_call_cmd_orig_api_name, details );
    if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_orig_func( 
                                                                   #ifdef FEATURE_QCRIL_CALL_ORIG_EXTEN3
                                                                   qcril_cm_callsvc_command_callback_exten,
                                                                   #else
                                                                   qcril_cm_callsvc_command_callback,
                                                                   #endif
                                                                   (void *) user_data,
                                                                   i_ptr->client_info[ modem_id ].client_id,
                                                                   CM_CALL_TYPE_EMERGENCY,
                                                                   CM_SRV_TYPE_AUTOMATIC,
                                                                   #ifdef FEATURE_QCRIL_DSDS
                                                                   as_id,
                                                                   #endif /* FEATURE_QCRIL_DSDS */
                                                                   &calling_number,
                                                                   &dial_number,
                                                                   &alpha_buf,
                                                                   &cdma_orig_params,
                                                                   NULL,
                                                                   NULL,
                                                                   #ifdef FEATURE_QCRIL_CALL_ORIG_EXTEN
                                                                   NULL,
                                                                   &cc_params,
                                                                   #elif defined( FEATURE_QCRIL_CALL_ORIG_EXTEN3 )
                                                                   NULL,
                                                                   CM_ORIG_CLIENT_CATEG_USER,
                                                                   #endif /* FEATURE_QCRIL_CALL_ORIG_EXTEN */
                                                                   &call_id ) )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
    else
    {
      QCRIL_LOG_DEBUG( "Dial request, assigned call id = %d\n", call_id );
    }
  }
  else 
  {
    /* Not an emergency flash */
    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                 QCRIL_EVT_CM_CALL_SUPS, &u_info, &reqlist_entry ); 
    reqlist_entry.valid_sub_id = TRUE;
    reqlist_entry.sub_id = call_ids_list.call_id[ 0 ];
    if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
    {
      /* Fail to add to ReqList */
      return;
    }
   
    /* Flash with no info */
    if ( flash_ptr == NULL )
    {
      QCRIL_LOG_DEBUG( "%s", "Flash with no info\n" );
      QCRIL_LOG_RPC2A( modem_id, "cm_num_init()", "" );
      qcril_cm_api_funcs[ modem_id ].cm_num_init_func( &dial_number );
      dial_number.len = 0;
      dial_number.buf[ 0 ] = '\0';
    }
    /* Flash with info */
    else
    {
      /* Initialize dial number */
      QCRIL_LOG_RPC2A( modem_id, "cm_num_fill()", "" );
      qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &dial_number, ( uint8 * ) flash_ptr, strlen( flash_ptr ), 
                                                       CM_DIGIT_MODE_4BIT_DTMF );
      dial_number.buf[ strlen( flash_ptr ) ] = '\0';
    }
   
    memset( &sups_params, 0, sizeof( sups_params ) );
    memcpy( &sups_params.sups_number, &dial_number, sizeof( cm_num_s_type ) );
    sups_params.call_id = call_ids_list.call_id[ 0 ];
   
    /* Command CM to send FLASH */
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
    QCRIL_SNPRINTF( details, sizeof( details ), "CM_CALL_SUPS_TYPE_SIMPLE_FLASH Token ID %d, call id %d, dial number %s", 
                    qcril_log_get_token_id( params_ptr->t ), sups_params.call_id, sups_params.sups_number.buf );

    QCRIL_LOG_RPC2( modem_id, cm_mm_call_cmd_sups_api_name, details );
    if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_sups_func( qcril_cm_callsvc_command_callback, 
                                                                   (void *) user_data, 
                                                                   i_ptr->client_info[ modem_id ].client_id,
                                                                   CM_CALL_SUPS_TYPE_SIMPLE_FLASH,
                                                                   &sups_params
                                                                   #ifdef FEATURE_QCRIL_DSDS
                                                                   , as_id
                                                                   #endif /* FEATURE_QCRIL_DSDS */

                                                                 ) )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  } /* if ( emergency_flashed ) */

} /* qcril_cm_callsvc_request_cdma_flash() */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_orig

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_ORIG.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_orig
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type cdma_modem_id, evdo_modem_id, gwl_modem_id, pdt_modem_id, lpm_modem_id, modem_id;
  qcril_arb_pref_data_tech_e_type pref_data_tech;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  const cm_mm_call_info_s_type *call_info_ptr; 
  boolean unsol_call_state_changed = FALSE;
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID  );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID  );
  i_ptr = &qcril_cm[ instance_id ];
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Add a record to CList */
  if ( qcril_cm_clist_new( instance_id, modem_id, call_info_ptr, QCRIL_CM_CLIST_STATE_DIALING, &i_ptr->uus_data, 
                           &unsol_call_state_changed ) != E_SUCCESS )
  {

    QCRIL_LOG_ERROR( "Fail to add CList entry for orig : call_id %d", call_info_ptr->call_id );
  }

  if( qcril_arb_ma_is_dsds() )
  {
     /* In case of DSDS when an emergency call gets swapped,
          QCRIL will have to reject the dial request on the initial subscription*/  
     if( call_info_ptr->call_type == CM_CALL_TYPE_EMERGENCY )
     {
       if( qcril_reqlist_query_by_event( QCRIL_DSDS_INSTANCE_PAIR(instance_id), modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS )
       {
          QCRIL_LOG_DEBUG( "%s\n","rejecting the emergency call as it got switched to other subscription");
          qcril_default_request_resp_params( QCRIL_DSDS_INSTANCE_PAIR(instance_id), req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
       }
     }
  }

  /* See if there is any voice origination RIL request pending for the event */
  if ( ( ( call_info_ptr->call_type == CM_CALL_TYPE_VOICE ) || 
         ( call_info_ptr->call_type == CM_CALL_TYPE_EMERGENCY ) ||
         ( call_info_ptr->call_type == CM_CALL_TYPE_STD_OTASP ) ||
         ( call_info_ptr->call_type == CM_CALL_TYPE_NON_STD_OTASP ) ) &&
       ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS ) ) 
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Dial success, call type %d, call id %d\n", call_info_ptr->call_type, call_info_ptr->call_id ); 
    qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }

  /* Send unsolicited call state changed only after response to RIL request is sent */
  if ( unsol_call_state_changed )
  {
    qcril_cm_send_unsol_call_state_changed( instance_id );
  }

  /* For QC solution split modem (SVDO or SVLTE), put MDM to LPM mode while E911 */
  if ( call_info_ptr->call_type == CM_CALL_TYPE_EMERGENCY )
  {
    lpm_modem_id = QCRIL_MAX_MODEM_ID;

    /* Lookup modem id for configured to serve data service */
    qcril_arb_query_data_tech_modem_id( instance_id, &cdma_modem_id, &evdo_modem_id, &gwl_modem_id, &pdt_modem_id, &pref_data_tech );

    if ( ( evdo_modem_id != modem_id ) && ( evdo_modem_id != QCRIL_MAX_MODEM_ID ) )
    {
      lpm_modem_id = evdo_modem_id;
    }
    else if ( ( gwl_modem_id != modem_id ) && ( gwl_modem_id != QCRIL_MAX_MODEM_ID ) )
    {
      lpm_modem_id = gwl_modem_id;
    }

    if ( ( lpm_modem_id != QCRIL_MAX_MODEM_ID ) && ( i_ptr->ph_info[ lpm_modem_id ].oprt_mode == SYS_OPRT_MODE_ONLINE ) )
    {
      /* Command CM to change the phone's operating mode */
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, lpm_modem_id, QCRIL_REQ_ID_INTERNAL );
      QCRIL_LOG_RPC2A( lpm_modem_id, "cm_ph_cmd_oprt_mode()", "LPM" );
      (void) qcril_cm_api_funcs[ lpm_modem_id ].cm_ph_cmd_oprt_mode_func( qcril_cm_phonesvc_command_callback,
                                                                         (void *) user_data,
                                                                         i_ptr->client_info[ lpm_modem_id ].client_id,
                                                                         SYS_OPRT_MODE_LPM );
    }
  }


} /* qcril_cm_callsvc_event_orig */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_setup_ind

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_SETUP_IND.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_setup_ind
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  const cm_mm_call_info_s_type *call_info_ptr; 
  RIL_CDMA_SignalInfoRecord signal_info_rec;
  boolean unsol_call_state_changed = FALSE;
  cm_setup_res_params_s_type setup_res_params;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/
 
  QCRIL_LOG_DEBUG( "Rxed setup ind, call_id %d, call type %d\n", call_info_ptr->call_id, call_info_ptr->call_type );

  if ( ( call_info_ptr->call_type == CM_CALL_TYPE_VOICE ) ||
       ( call_info_ptr->call_type == CM_CALL_TYPE_EMERGENCY ) )
  {
    memset( &setup_res_params, CM_CALL_CMD_PARAM_DEFAULT_VALUE, sizeof( setup_res_params ) );

    setup_res_params.accept = TRUE;

    /* The default bearer capability to use on incoming voice calls. */
    qcril_cm_api_funcs[ modem_id ].cm_util_set_default_voice_bearer_cap_func( &setup_res_params.bearer_capability_1 );

    /* Based on TTY mode, iindicates whether CTM text teleophony is supported or not */
    if ( i_ptr->tty_mode != QCRIL_CM_TTY_MODE_OFF )
    { 
      setup_res_params.bearer_capability_1.ctm = 1;
    }
    else
    {
      setup_res_params.bearer_capability_1.ctm = 0;
    }

    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.present = %d\n", 
                     setup_res_params.bearer_capability_1.present );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.radio_channel_requirement = %d\n", 
                     setup_res_params.bearer_capability_1.radio_channel_requirement );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.coding_standard = %d\n", 
                     setup_res_params.bearer_capability_1.coding_standard );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.transfer_mode = %d\n", 
                     setup_res_params.bearer_capability_1.transfer_mode );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.information_transfer_capability = %d\n", 
                     setup_res_params.bearer_capability_1.information_transfer_capability );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.ctm = %d\n", 
                     setup_res_params.bearer_capability_1.ctm );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.gsm_speech_ver_pref_0 = %d\n", 
                     setup_res_params.bearer_capability_1.gsm_speech_ver_pref_0 );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.gsm_speech_ver_pref_1 = %d\n", 
                     setup_res_params.bearer_capability_1.gsm_speech_ver_pref_1 );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.gsm_speech_ver_pref_2 = %d\n", 
                     setup_res_params.bearer_capability_1.gsm_speech_ver_pref_2 );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.gsm_speech_ver_pref_3 = %d\n", 
                     setup_res_params.bearer_capability_1.gsm_speech_ver_pref_3 );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.gsm_speech_ver_pref_4 = %d\n", 
                     setup_res_params.bearer_capability_1.gsm_speech_ver_pref_4 );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.gsm_speech_ver_pref_5 = %d\n", 
                     setup_res_params.bearer_capability_1.gsm_speech_ver_pref_5 );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.compression = %d\n", 
                     setup_res_params.bearer_capability_1.compression );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.structure = %d\n", 
                     setup_res_params.bearer_capability_1.structure );
    QCRIL_LOG_DEBUG( "setup_res_params.bearer_capability_1.duplex_mode = %d\n", 
                     setup_res_params.bearer_capability_1.duplex_mode );

    /* Command CM to send a setup message response */
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, QCRIL_REQ_ID_INTERNAL );
    QCRIL_LOG_RPC( modem_id, "cm_mm_call_cmd_setup_res()", "call_id", call_info_ptr->call_id );
    (void) qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_setup_res_func( qcril_cm_callsvc_command_callback, 
                                                                         (void *) user_data, 
                                                                         i_ptr->client_info[ modem_id ].client_id, 
                                                                         call_info_ptr->call_id, 
                                                                         &setup_res_params );

    /* GSM has no signal info rec */
    signal_info_rec.isPresent = FALSE;

    /* Report the incoming voice call */
    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_CALL_RING, &unsol_resp );
    unsol_resp.resp_pkt = ( void * ) &signal_info_rec;
    unsol_resp.resp_len = sizeof( RIL_CDMA_SignalInfoRecord );
    qcril_send_unsol_response( &unsol_resp );

    /* Add a record to CList */
    if ( qcril_cm_clist_new( instance_id, modem_id, call_info_ptr, QCRIL_CM_CLIST_STATE_SETUP, &i_ptr->uus_data, 
                             &unsol_call_state_changed ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Fail to add CList entry for incom : call_id %d", call_info_ptr->call_id );
    }
  }

} /* qcril_cm_callsvc_event_setup_ind */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_user_data_ind

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_USER_DATA_IND

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_user_data_ind
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_cm_struct_type *i_ptr;
  qcril_cm_call_event_user_data_s_type *uus_ptr;              
  const cm_mm_call_info_s_type *call_info_ptr;
  cm_call_event_user_data_s_type user_data;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  uus_ptr = &i_ptr->uus_data;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );
  qcril_modem_id_e_type modem_id = QCRIL_DEFAULT_MODEM_ID;

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "UUS Data ind : call_id %d, uus present = %d\n", call_info_ptr->call_id,
                   call_info_ptr->mode_info.info.gw_cs_call.is_user_data_present );

  if ( call_info_ptr->mode_info.info.gw_cs_call.is_user_data_present )
  {
    memset( &user_data, 0, sizeof( user_data ) );
    qcril_cm_api_funcs[ modem_id ].cm_get_user_data_func( call_info_ptr, &user_data );
    if ( !user_data.mt_user_data.present )
    {
      QCRIL_LOG_DEBUG( "UUS MT Data ind : %s\n","UUS Data not present");
      return ;
    }

    memset( uus_ptr, 0, sizeof( qcril_cm_call_event_user_data_s_type ) );
    uus_ptr->call_id = call_info_ptr->call_id;
    memcpy( &uus_ptr->user_data, &user_data, sizeof( cm_call_event_user_data_s_type ) );
    QCRIL_LOG_DEBUG( "UUS Data ind : call_id %d, MT uus present = %d, UUS Len = %d , UUS Type = %d, UUS Data = %s, Dcs = %d\n",
                      uus_ptr->call_id, uus_ptr->user_data.mt_user_data.present, uus_ptr->user_data.mt_user_data.user_user_data_length,
                      uus_ptr->user_data.mt_user_data.user_user_type, uus_ptr->user_data.mt_user_data.user_user_data,
                      uus_ptr->user_data.mt_user_data.user_user_protocol_disc);
    QCRIL_LOG_DEBUG( "cause_val=%d, coding_standard=%d, diagnostic len=%d, location=%d, cause_present=%d, rec_present=%d, rec=%d\n",
                      uus_ptr->user_data.cm_cc_cause.cause_value, uus_ptr->user_data.cm_cc_cause.coding_standard,
                      uus_ptr->user_data.cm_cc_cause.diagnostic_length, uus_ptr->user_data.cm_cc_cause.location,
                      uus_ptr->user_data.cm_cc_cause.present, uus_ptr->user_data.cm_cc_cause.recommendation_present,
                      uus_ptr->user_data.cm_cc_cause.recommendation);
  }

} /* qcril_cm_callsvc_event_user_data_ind */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_progress_info_ind

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_PROGRESS_INFO_IND.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_progress_info_ind
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  const cm_mm_call_info_s_type *call_info_ptr; 
  qcril_cm_clist_public_type call_info;
  boolean unsol_call_state_changed = FALSE;
  int local_ringback_payload;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/
 
  /* Update the state of the record in CList if needed */
  if ( qcril_cm_clist_alert( instance_id, modem_id, call_info_ptr->call_id, &unsol_call_state_changed ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "No update done on CList entry for alert : call_id %d", call_info_ptr->call_id );
  }
  /* Send unsolicited call state changed */
  else if ( unsol_call_state_changed )
  {
    qcril_cm_send_unsol_call_state_changed( instance_id );
  }

  /* Local ringback processing */
  if  ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_GW_CS ) 
  {
    /* Play local Ringback tone if needed */
    if ( ( call_info_ptr->mode_info.info.gw_cs_call.call_progress == QCRIL_CM_REMOTE_ALERT ) &&
         !qcril_cm_clist_is_local_ringback( instance_id, modem_id, call_info_ptr->call_id ) )
    {
      local_ringback_payload = TRUE;
      /* As there will be only one MO call at any point of time not keeping any additional checks */
      QCRIL_LOG_DEBUG( "%s", "Remote alert, play local Ringback tone\n" );
      if ( qcril_cm_clist_update_local_ringback( instance_id, modem_id, call_info_ptr->call_id, local_ringback_payload ) != E_SUCCESS )
      {
        QCRIL_LOG_ERROR( "Failed to update the Ringback information of CList entry for call_id %d\n",call_info_ptr->call_id);
      }

      qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_RINGBACK_TONE, &unsol_resp );
      unsol_resp.resp_pkt = ( void * ) &local_ringback_payload;
      unsol_resp.resp_len = sizeof( local_ringback_payload );
      qcril_send_unsol_response( &unsol_resp );
    }
    /* stop local Ringback tone if USER_RESUMED */
    else if ( ( call_info_ptr->mode_info.info.gw_cs_call.call_progress == QCRIL_CM_USER_RESUMED )&&
              qcril_cm_clist_is_local_ringback( instance_id, modem_id, call_info_ptr->call_id ) )
    {
      local_ringback_payload = FALSE;
      /* As there will be only one MO call at any point of time not keeping any additional checks */
      if ( qcril_cm_clist_update_local_ringback( instance_id, modem_id, call_info_ptr->call_id, local_ringback_payload ) != E_SUCCESS )
      {
        QCRIL_LOG_ERROR( "Failed to update the Ringback information of CList entry for call_id %d\n",call_info_ptr->call_id);
      }

      qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_RINGBACK_TONE, &unsol_resp );
      unsol_resp.resp_pkt = ( void * ) &local_ringback_payload;
      unsol_resp.resp_len = sizeof( local_ringback_payload );
      qcril_send_unsol_response( &unsol_resp );
    }
  }

  /* Indicate call re-establishment to telephony so that it can mute/unmute of the audio device. */   
  if ( ( qcril_cm_clist_query_voice_call_id( instance_id, modem_id, call_info_ptr->call_id, &call_info ) == E_SUCCESS ) &&
       ( call_info.state == QCRIL_CM_CLIST_STATE_ACTIVE ) )  
  {   
    QCRIL_LOG_DEBUG( "%s", "Recieved CALL_EVENT_PROGRESS_INFO_IND during an active call. \n" );   
    qcril_hook_unsol_response( instance_id, QCRIL_EVT_HOOK_UNSOL_CALL_EVT_PROGRESS_INFO_IND, NULL, 0);   
  }   

} /* qcril_cm_callsvc_event_progress_info_ind */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_incom

===========================================================================*/
/*!
    @brief
    handle CM_CALL_EVENT_INCOM.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_incom
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr; 
  boolean unsol1_call_state_changed = FALSE, unsol2_call_state_changed = FALSE;
  qcril_cm_clist_public_type call_info;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* CDMA MT call overrides MO call */
  if ( ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_CDMA ) &&
       ( qcril_cm_clist_query_voice_call_id( instance_id, modem_id, call_info_ptr->call_id, &call_info ) == E_SUCCESS ) &&
       ( call_info.state != QCRIL_CM_CLIST_STATE_ACTIVE ) )
  {
    /* This call id already exists in the call list.  Getting an incoming event with the same call id means the bs is replacing 
       the existing call with the incoming call. */
    if ( qcril_cm_clist_replace( instance_id, modem_id, call_info_ptr->call_state, call_info.call_id, call_info.conn_index, 
                                 call_info_ptr, &unsol1_call_state_changed ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Fail to replace CList entry for existing call : call_id %d", 
                       call_info_ptr->call_id );
    }

    /* Update the call_fail_cause to indicate the BS preempted the existing call */
    QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].call_fail_cause_mutex\n", instance_id );
    QCRIL_MUTEX_LOCK( &i_ptr->call_fail_cause_mutex, details );

    i_ptr->call_fail_cause = CALL_FAIL_CDMA_PREEMPTED;

    QCRIL_MUTEX_UNLOCK( &i_ptr->call_fail_cause_mutex, details );
  }
  /* For GW calls, the clist entry will be created when receiving CM_CALL_EVENT_SETUP_IND. */
  else if ( qcril_cm_clist_query_voice_call_id( instance_id, modem_id, call_info_ptr->call_id, &call_info ) != E_SUCCESS )
  {
    /* Add a record to CList */
    if ( qcril_cm_clist_new( instance_id, modem_id, call_info_ptr, QCRIL_CM_CLIST_STATE_INCOMING, &i_ptr->uus_data, 
                             &unsol1_call_state_changed ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Fail to add CList entry for incom : call_id %d", call_info_ptr->call_id );
    }
  }
  else if ( qcril_cm_clist_incoming( instance_id, modem_id, call_info_ptr->call_id, &i_ptr->uus_data, 
                                     &unsol1_call_state_changed ) != E_SUCCESS ) 
  {
    QCRIL_LOG_ERROR( "Fail to update CList entry state for incom : call_id %d", call_info_ptr->call_id );
  }

  qcril_cm_util_process_cnap_info( instance_id, modem_id, call_info_ptr, &unsol2_call_state_changed );

  /* Send unsolicited call state changed */
  if ( unsol1_call_state_changed || unsol2_call_state_changed )
  {
    qcril_cm_send_unsol_call_state_changed( instance_id );
  }

} /* qcril_cm_callsvc_event_incom */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_connect

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_CONNECT.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_connect
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  const cm_mm_call_info_s_type *call_info_ptr; 
  int local_ringback_payload;
  boolean unsol_call_state_changed = FALSE;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/
 
  /* Update the state of the record in CList */
  if ( qcril_cm_clist_connect( instance_id, modem_id, call_info_ptr->call_id, &unsol_call_state_changed ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "Failed to update the state of CList entry for connect : call_id %d\n", call_info_ptr->call_id );
  }
  else
  {
    /* Send unsolicited call state changed*/
    if ( unsol_call_state_changed )
    {
      qcril_cm_send_unsol_call_state_changed( instance_id );
    }

    /* Stop local Ringback tone if needed */
    if ( ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_GW_CS ) &&
         ( call_info_ptr->mode_info.info.gw_cs_call.call_progress == QCRIL_CM_REMOTE_ALERT ) &&
         qcril_cm_clist_is_local_ringback( instance_id, modem_id, call_info_ptr->call_id ) )
    {
      local_ringback_payload = FALSE;
      if ( qcril_cm_clist_update_local_ringback( instance_id, modem_id, call_info_ptr->call_id, local_ringback_payload ) != E_SUCCESS)
      {
        QCRIL_LOG_ERROR( "Failed to update the Ringback information of CList entry for call_id %d\n",call_info_ptr->call_id);
      }

      qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_RINGBACK_TONE, &unsol_resp );
      unsol_resp.resp_pkt = ( void * ) &local_ringback_payload;
      unsol_resp.resp_len = sizeof( local_ringback_payload );
      qcril_send_unsol_response( &unsol_resp );
    }
  }

} /* qcril_cm_callsvc_event_connect */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_answer

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_ANSWER.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_answer
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{                                   
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  const cm_mm_call_info_s_type *call_info_ptr; 
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Update the answer indication of the record in CList */
  if ( qcril_cm_clist_answer( instance_id, modem_id, call_info_ptr->call_id ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "Failed to update the answer indication of CList entry for answer : call_id %d\n", call_info_ptr->call_id );
  }  

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, params_ptr->event_id, 
                                                call_info_ptr->call_id, &req_info ) == E_SUCCESS ) 
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> Answer success, call id %d\n", call_info_ptr->call_id ); 
    qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_callsvc_event_answer */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_sups

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_SUPS.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_sups
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{                                   
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  const cm_mm_call_info_s_type *call_info_ptr; 
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, params_ptr->event_id, 
                                                call_info_ptr->call_id, &req_info ) == E_SUCCESS ) 
  {
    qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_callsvc_event_sups */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_end

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_END.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_end
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr; 
  qcril_reqlist_public_type req_info;
  qcril_cm_clist_call_ids_list_type call_ids_list;
  nv_item_type nv_item;
  qcril_cm_clist_public_type emergency_call;
  cm_prl_pref_e_type prl_pref = CM_PRL_PREF_ANY;
  boolean unsol1_call_state_changed = FALSE, unsol2_call_state_changed = FALSE;
  int local_ringback_payload;
  qcril_modem_ids_list_type modem_ids_list;
  qcril_request_resp_params_type resp;
  qcril_unsol_resp_params_type unsol_resp;
  char details[ 40 ];

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *nv_cmd_api_name = "nv_cmd_ext_remote()";
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref_per_subs()";
  #else
  char *nv_cmd_api_name = "nv_cmd_remote()";
  char *cm_ph_cmd_sys_sel_pref_api_name = "cm_ph_cmd_sys_sel_pref()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Update last call fail cause */
  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].call_fail_cause_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->call_fail_cause_mutex, details );

  /* Update last call fail reason for non-data call */
  if ( ( call_info_ptr->call_type != CM_CALL_TYPE_CS_DATA ) && ( call_info_ptr->call_type != CM_CALL_TYPE_PS_DATA ) )
  {
    switch ( call_info_ptr->end_status )
    {
      case CM_CALL_END_CLIENT_END:
      case CM_CALL_END_REL_NORMAL:
        i_ptr->call_fail_cause = CALL_FAIL_NORMAL;
        break;

      case CM_CALL_END_NETWORK_END:
      case CM_CALL_END_LL_CAUSE:

        i_ptr->call_fail_cause = CALL_FAIL_NORMAL;

        if ( ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_GW_CS ) && 
             call_info_ptr->mode_info.info.gw_cs_call.cc_cause.present )
        {
          /* Refer to Table 10.5.123/3GPP TS 24.008 for cc_cause meaning */
          if ( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value == 1 )
          {
            i_ptr->call_fail_cause = CALL_FAIL_UNOBTAINABLE_NUMBER;
          }
          else if ( ( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value == 16 ) ||
                    ( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value == 31 ) )
          {
            i_ptr->call_fail_cause = CALL_FAIL_NORMAL;
          }
          else if ( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value == 17 )
          {
            i_ptr->call_fail_cause = CALL_FAIL_BUSY;
          }
          else if ( ( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value == 8 ) || 
                    ( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value == 55 ) ) 
          {
            i_ptr->call_fail_cause = CALL_FAIL_CALL_BARRED;
          }
          else if ( ( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value == 34 ) || 
                    ( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value == 42 ) ||
                    ( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value == 44 ) ||
                    ( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value == 47 ) ) 
          {
            i_ptr->call_fail_cause = CALL_FAIL_CONGESTION;
          }
          else if ( call_info_ptr->mode_info.info.gw_cs_call.cc_cause.cause_value == 68 ) 
          {
            i_ptr->call_fail_cause = CALL_FAIL_ACM_LIMIT_EXCEEDED;
          }
          else
          {
            i_ptr->call_fail_cause = CALL_FAIL_ERROR_UNSPECIFIED;
          }
        }

        if ( ( call_info_ptr->end_status == CM_CALL_END_LL_CAUSE ) && !call_info_ptr->mode_info.info.gw_cs_call.cc_cause.present )
        {
          i_ptr->call_fail_cause = CALL_FAIL_ERROR_UNSPECIFIED;

          /* check if the call is rejected to Mobility Management connection establishment procedure */
          if ( ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_GW_CS ) &&
               call_info_ptr->mode_info.info.gw_cs_call.cc_reject.present  &&
               ( call_info_ptr->mode_info.info.gw_cs_call.cc_reject.rej_type == OTA_REJECT_CAUSE ) )
          {
            QCRIL_LOG_DEBUG( "Lower Layer(NAS) Reject Cause received = %d\n",
                             call_info_ptr->mode_info.info.gw_cs_call.cc_reject.rej_value );
            if ( call_info_ptr->mode_info.info.gw_cs_call.cc_reject.rej_value == 4 )
            {
              i_ptr->call_fail_cause = CALL_FAIL_IMSI_UNKNOWN_IN_VLR;
            }
            else if ( call_info_ptr->mode_info.info.gw_cs_call.cc_reject.rej_value == 5 )
            {
              i_ptr->call_fail_cause = CALL_FAIL_IMEI_NOT_ACCEPTED;
            }
          }
        }
        break;

      case CM_CALL_END_INCOM_REJ:
      case CM_CALL_END_SETUP_REJ:
        i_ptr->call_fail_cause = CALL_FAIL_BUSY;
        break;

      case CM_CALL_END_NO_SRV:
      case CM_CALL_END_NO_GW_SRV:
      case CM_CALL_END_NO_FULL_SRV:
      case CM_CALL_END_MAX_PS_CALLS:
        i_ptr->call_fail_cause = CALL_FAIL_CONGESTION;
        break;

      case CM_CALL_END_NO_FUNDS:
        i_ptr->call_fail_cause = CALL_FAIL_ACM_LIMIT_EXCEEDED;
        break;

      case CM_CALL_END_CDMA_LOCK:
        i_ptr->call_fail_cause = CALL_FAIL_CDMA_LOCKED_UNTIL_POWER_CYCLE;
        break;
   
      case CM_CALL_END_FADE:
        i_ptr->call_fail_cause = CALL_FAIL_CDMA_DROP;
        break;

      case CM_CALL_END_INTERCEPT:
        i_ptr->call_fail_cause = CALL_FAIL_CDMA_INTERCEPT;
        break;
   
      case CM_CALL_END_REORDER:
        i_ptr->call_fail_cause = CALL_FAIL_CDMA_REORDER;
        break;

      case CM_CALL_END_REL_SO_REJ:
        i_ptr->call_fail_cause = CALL_FAIL_CDMA_SO_REJECT;
        break;

      case CM_CALL_END_RETRY_ORDER:
        i_ptr->call_fail_cause = CALL_FAIL_CDMA_RETRY_ORDER;
        break;

      case CM_CALL_END_ACC_FAIL:
      case CM_CALL_END_MAX_ACCESS_PROBE:
        i_ptr->call_fail_cause = CALL_FAIL_CDMA_ACCESS_FAILURE;
        break;

      case CM_CALL_END_INCOM_CALL:
        i_ptr->call_fail_cause = CALL_FAIL_CDMA_PREEMPTED;  
        break;

      case CM_CALL_END_EMERGENCY_FLASHED:
        i_ptr->call_fail_cause = CALL_FAIL_CDMA_NOT_EMERGENCY;
        break;

      case CM_CALL_END_ACCESS_BLOCK_ALL:
      case CM_CALL_END_PSIST_NG:
        i_ptr->call_fail_cause = CALL_FAIL_CDMA_ACCESS_BLOCKED;
        break;

      default:
        i_ptr->call_fail_cause = CALL_FAIL_ERROR_UNSPECIFIED;
        break;

    } /* end switch */

    QCRIL_LOG_DEBUG( "Call %d ended with reason %d\n", call_info_ptr->call_id, call_info_ptr->end_status ); 
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->call_fail_cause_mutex, details );

  /* Check if the call ID passed, maps to emergency call; 
     If an emergency call is currently in progress and is then terminated,
     RIL shall indicate RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE. */
  QCRIL_LOG_DEBUG( "End call call_type %d", call_info_ptr->call_type );

  if ( i_ptr->call_fail_cause == CALL_FAIL_CDMA_NOT_EMERGENCY ) 
  {
    QCRIL_LOG_DEBUG( "%s", "End call reason EMERGECNY FLASHED" );
    QCRIL_LOG_DEBUG( "call_id %d, call_type %d, call_mode %d, call_direction %d, call_state %d, line %d, num %d", 
                     call_info_ptr ->call_id, call_info_ptr->call_type, call_info_ptr->mode_info.info_type,
                     call_info_ptr->direction, call_info_ptr->call_state,
                     call_info_ptr->line, call_info_ptr->num );

    /* Check whether there is any active voice call */
    qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, QCRIL_CM_CLIST_STATE_ACTIVE, &call_ids_list );
    
    /* Look for the emergency call connection index */
    qcril_cm_clist_query_voice_call_id( instance_id, modem_id, call_info_ptr->call_id, &emergency_call );
    
    if ( call_ids_list.num_of_call_ids != 0 )
    {
      /* Since there should only be one voice call for CDMA, Replace the existing voice call 
       * with the emergency call on the call list. using the existing voice call call_id */
      if ( qcril_cm_clist_replace( instance_id, modem_id, CM_CALL_STATE_CONV, call_ids_list.call_id[ 0 ], emergency_call.conn_index, 
                                   call_info_ptr, &unsol1_call_state_changed ) != E_SUCCESS )
      {
        QCRIL_LOG_ERROR( "Fail to replace CList entry: call_id %d", call_ids_list.call_id[0] );
      }
    }
  }
  else if ( call_info_ptr->call_type == CM_CALL_TYPE_EMERGENCY ) 
  {
    /* If an emergency call is currently in progress and is then terminated, RIL shall indicate 
       RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE. */
    QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].emer_cb_state_mutex\n", instance_id );
    QCRIL_MUTEX_LOCK( &i_ptr->emer_cb_state_mutex, details );
    if ( i_ptr->emer_cb_state == CM_PH_STATE_EMERG_CB )
    {
      QCRIL_LOG_DEBUG( "%s", "Modem entered emergency callback mode " );
      qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE, &unsol_resp );
      qcril_send_unsol_response( &unsol_resp );
    }
    QCRIL_MUTEX_UNLOCK( &i_ptr->emer_cb_state_mutex, details );
  }

  /* Stop local Ringback tone if needed */
  if ( ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_GW_CS ) &&
       ( call_info_ptr->mode_info.info.gw_cs_call.call_progress == QCRIL_CM_REMOTE_ALERT ) &&
       qcril_cm_clist_is_local_ringback( instance_id, modem_id, call_info_ptr->call_id ) )
  {
    local_ringback_payload = FALSE;
    if ( qcril_cm_clist_update_local_ringback( instance_id, modem_id, call_info_ptr->call_id, local_ringback_payload ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Failed to update the Ringback information of CList entry for call_id %d\n",call_info_ptr->call_id);
    }

    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_RINGBACK_TONE, &unsol_resp );
    unsol_resp.resp_pkt = ( void * ) &local_ringback_payload;
    unsol_resp.resp_len = sizeof( local_ringback_payload );
    qcril_send_unsol_response( &unsol_resp );
  }

  /* Remove the record from the CList */
  if ( qcril_cm_clist_free( instance_id, modem_id, call_info_ptr->call_id, &unsol2_call_state_changed ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "Failed to delete the Clist entry : call_id %d", call_info_ptr->call_id );
  }

  /* See if there is any RIL request pending for the event */
  while ( qcril_reqlist_query_by_event_and_sub_id_all_states( instance_id, modem_id, params_ptr->event_id, call_info_ptr->call_id, 
                                                              &req_info ) == E_SUCCESS ) 
  {
    QCRIL_LOG_DEBUG( "Reply to RIL --> End success, call id %d\n", call_info_ptr->call_id ); 
    qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }

  /* See if there any DTMF events still pending after the call is ended */
  while ( qcril_reqlist_query_by_event_and_sub_id_all_states( instance_id, modem_id, QCRIL_EVT_CM_INBAND_REV_START_CONT_DTMF_CONF, 
                                                              call_info_ptr->call_id, &req_info ) == E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "Call ended, response to %s without waiting the ACK, token id %d, call id %d \n",
    qcril_log_lookup_event_name( req_info.request ), qcril_log_get_token_id( req_info.t ), call_info_ptr->call_id );
    qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }

  /* See if there any DTMF events still pending after the call is ended */
  while ( qcril_reqlist_query_by_event_and_sub_id_all_states( instance_id, modem_id, QCRIL_EVT_CM_INBAND_REV_STOP_CONT_DTMF_CONF, 
                                                              call_info_ptr->call_id, &req_info ) == E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "Call ended, response to %s without waiting the ACK, token id %d, call id %d \n",
                     qcril_log_lookup_event_name( req_info.request ), qcril_log_get_token_id( req_info.t ), call_info_ptr->call_id );
    qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }

  if ( ( call_info_ptr->call_type != CM_CALL_TYPE_CS_DATA ) && ( call_info_ptr->call_type != CM_CALL_TYPE_PS_DATA ) )
  {
    /* For any request that pending for CM_EVENT_CALL_MNG_CALLS_CONF, it is time now to response back since Modem may not send 
       pending events for those requests after END */
    while ( qcril_reqlist_query_by_event_all_states( instance_id, modem_id, QCRIL_EVT_CM_CALL_MNG_CALLS_CONF, &req_info ) == E_SUCCESS )
    {
      if ( ( req_info.request == RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND ) ||
           ( req_info.request == RIL_REQUEST_UDUB ) ||
           ( req_info.request == RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND ) ||
           ( req_info.request == RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE ) ||
           ( req_info.request == RIL_REQUEST_CONFERENCE ) ||
           ( req_info.request == RIL_REQUEST_SEPARATE_CONNECTION ) )
      {
        QCRIL_LOG_DEBUG( "Completing request %s upon CM_CALL_EVENT_MNG_CALLS_CONF \n", qcril_log_lookup_event_name( req_info.request ) ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        qcril_send_request_response( &resp );
      }  
      else
      {
        break;
      }
    }

    /* For any request that pending for CM_EVENT_CALL_END, it is time now to response back since Modem may not send pending 
       events for those requests after END */
    while ( qcril_reqlist_query_by_event_all_states( instance_id, modem_id, QCRIL_EVT_CM_CALL_END, &req_info ) == E_SUCCESS )
    {
      if ( ( req_info.request == RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND ) ||
           ( req_info.request == RIL_REQUEST_HANGUP ) ||
           ( req_info.request == RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND ) )
      {
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        qcril_send_request_response( &resp );
        QCRIL_LOG_DEBUG( "Completing request %s upon CM_CALL_EVENT_END \n", qcril_log_lookup_event_name( req_info.request ) ); 
      }  
      else
      {
        break;
      }
    }
  }

  /* Send unsolicited call state changed after response to RIL request */
  if ( unsol1_call_state_changed || unsol2_call_state_changed )
  {
    qcril_cm_send_unsol_call_state_changed( instance_id );
  }

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    return;
  }
  #endif /* FEATURE_QCRIL_DSDS */

  /* Adjust PRL preference if necessary */
  if ( ( ( call_info_ptr->call_type == CM_CALL_TYPE_OTAPA ) || ( call_info_ptr->call_type == CM_CALL_TYPE_STD_OTASP ) ||
         ( call_info_ptr->call_type == CM_CALL_TYPE_NON_STD_OTASP ) ) 
       && call_info_ptr->mode_info.info.cdma_call.is_otasp_commit )
  {
    /* Lookup the modem that should provide the service */
    if ( qcril_arb_query_ph_srv_modem_id( QCRIL_ARB_PH_SRV_CAT_3GPP2, instance_id, &modem_ids_list ) == E_SUCCESS )
    {
      QCRIL_LOG_DEBUG( "Verifying NV_HOME_SID_NID_I after OTASP/OTAPA call...MID %d\n", modem_id );

      QCRIL_LOG_RPC2A( modem_id, nv_cmd_api_name, "Read NV_HOME_SID_NID_I" );
      if ( qcril_other_api_funcs[ modem_id ].nv_cmd_remote_func( NV_READ_F, NV_HOME_SID_NID_I, (nv_item_type *) &nv_item
                                                                 #ifdef FEATURE_QCRIL_DSDS
                                                                 , as_id
                                                                 #endif /* FEATURE_QCRIL_DSDS */
                                                               ) == NV_DONE_S )
      {
        if ( nv_item.home_sid_nid.pair[ 0 ].sid % 2 )
        {
          QCRIL_LOG_DEBUG( "%s, Read SID Value=%d","SID is Odd - Automatic A mode selected", nv_item.home_sid_nid.pair[ 0 ].sid );
          prl_pref = CM_PRL_PREF_AVAIL_BC0_A;
        }
        else
        {
          QCRIL_LOG_DEBUG( "%s, Read SID Value=%d", "SID is Even - Automatic B mode selected", nv_item.home_sid_nid.pair[ 0 ].sid );
          prl_pref = CM_PRL_PREF_AVAIL_BC0_B;
        }

        /* Command CM to change to AutoAB System select update per SID */
        QCRIL_LOG_RPC2( modem_id, cm_ph_cmd_sys_sel_pref_api_name, "PRL_PREF" );
        if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_sys_sel_pref_func( qcril_cm_phonesvc_command_callback,
                                                                          (void*)QCRIL_TOKEN_ID_INTERNAL,
                                                                          i_ptr->client_info[ modem_id ].client_id,
                                                                          #ifdef FEATURE_QCRIL_DSDS
                                                                          as_id,
                                                                          #endif /* FEATURE_QCRIL_DSDS */
                                                                          CM_MODE_PREF_NO_CHANGE,
                                                                          CM_PREF_TERM_PERMANENT,
                                                                          0,
                                                                          CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                                          CM_BAND_PREF_NO_CHANGE,
                                                                          prl_pref,
                                                                          CM_ROAM_PREF_NO_CHANGE,
                                                                          CM_HYBR_PREF_NO_CHANGE,
                                                                          CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                                          CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                                                          NULL
                                                                          #ifndef FEATURE_QCRIL_DSDS
                                                                          , NULL
                                                                          #endif /* !FEATURE_QCRIL_DSDS */
                                                                        ) )
        {
          QCRIL_LOG_ERROR( "%s", "Failed to change Preference mode settings" );
        }
      }
    }

    QCRIL_LOG_DEBUG( "%s", "Verifying NV_HOME_SID_NID_I after OTASP/OTAPA call..." );

    QCRIL_LOG_RPC2A( modem_id, nv_cmd_api_name, "Read NV_HOME_SID_NID_I" );
    if ( qcril_other_api_funcs[ modem_id ].nv_cmd_remote_func( NV_READ_F, NV_HOME_SID_NID_I, (nv_item_type *) &nv_item 
                                                               #ifdef FEATURE_QCRIL_DSDS
                                                               , as_id
                                                               #endif /* FEATURE_QCRIL_DSDS */
                                                             ) == NV_DONE_S )
    {
      if ( nv_item.home_sid_nid.pair[ 0 ].sid % 2 )
      {
        QCRIL_LOG_DEBUG( "%s, Read SID Value=%d","SID is Odd - Automatic A mode selected", nv_item.home_sid_nid.pair[ 0 ].sid );
        prl_pref = CM_PRL_PREF_AVAIL_BC0_A;
      }
      else
      {
        QCRIL_LOG_DEBUG( "%s, Read SID Value=%d", "SID is Even - Automatic B mode selected", nv_item.home_sid_nid.pair[ 0 ].sid );
        prl_pref = CM_PRL_PREF_AVAIL_BC0_B;
      }

      /* Command CM to change to AutoAB System select update per SID */
      QCRIL_LOG_RPC2( modem_id, cm_ph_cmd_sys_sel_pref_api_name, "PRL_PREF" );
      if ( !qcril_cm_api_funcs[ modem_id ].cm_ph_cmd_sys_sel_pref_func( qcril_cm_phonesvc_command_callback,
                                                                        (void*)QCRIL_TOKEN_ID_INTERNAL,
                                                                        #ifdef FEATURE_QCRIL_DSDS
                                                                        as_id,
                                                                        #endif /* FEATURE_QCRIL_DSDS */
                                                                        i_ptr->client_info[ modem_id ].client_id,
                                                                        CM_MODE_PREF_NO_CHANGE,
                                                                        CM_PREF_TERM_PERMANENT,
                                                                        0,
                                                                        CM_GW_ACQ_ORDER_PREF_NO_CHANGE,
                                                                        CM_BAND_PREF_NO_CHANGE,
                                                                        prl_pref,
                                                                        CM_ROAM_PREF_NO_CHANGE,
                                                                        CM_HYBR_PREF_NO_CHANGE,
                                                                        CM_SRV_DOMAIN_PREF_NO_CHANGE,
                                                                        CM_NETWORK_SEL_MODE_PREF_NO_CHANGE,
                                                                        NULL
                                                                        #ifndef FEATURE_QCRIL_DSDS
                                                                        , NULL
                                                                        #endif /* !FEATURE_QCRIL_DSDS */
                                                                      ) )
      {
        QCRIL_LOG_ERROR( "%s", "Failed to change Preference mode settings" );
      }
    }
  }

} /* qcril_cm_callsvc_event_end */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_mng_calls_conf

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_MNG_CALLS_CONF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_mng_calls_conf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  const cm_mm_call_info_s_type *call_info_ptr; 
  boolean unsol_call_state_changed = FALSE;
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Update the state of records in the CList */
  if ( call_info_ptr->mode_info.info.gw_cs_call.call_ss_success )
  {
    if ( qcril_cm_clist_manage( instance_id, modem_id, &call_info_ptr->mode_info.info.gw_cs_call.active_calls_list,
                                &unsol_call_state_changed ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "%s", "Fail to update the state of Clist entries for manage\n" );
    }
  }

  if ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_GW_CS )
  {
    /* See if there is any RIL request pending for the event */
    if ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &req_info ) == E_SUCCESS ) 
    {
      /* Success in supplementary command */
      if ( call_info_ptr->mode_info.info.gw_cs_call.call_ss_success )
      {
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        qcril_send_request_response( &resp );
      }
      /* Failure in supplementary command */
      else
      {
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
    }
  }

  /* Send unsolicited call state changed */
  if ( unsol_call_state_changed )
  {
    qcril_cm_send_unsol_call_state_changed( instance_id );
  }

} /* qcril_cm_callsvc_event_mng_calls_conf */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_orig_fwd_status

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CALL_ORIG_FWD_STATUS
    Reports supplementary service related notification from the network when
    call either conditional/un-conditional call forwarding is active.

    @return
    RIL_SuppSvcNotification.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_orig_fwd_status
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  cm_mm_call_info_s_type *call_info_ptr;
  cm_call_ss_info_s_type *ss_info;
  boolean success = FALSE;
  RIL_SuppSvcNotification response;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  call_info_ptr = (cm_mm_call_info_s_type *)params_ptr->data;
  ss_info = &call_info_ptr->mode_info.info.gw_cs_call.ss_info;

  if ( ss_info->ss_code.present )
  {
    switch ( ss_info->ss_code.ss_code )
    {
      case qcril_cm_ss_cfu:
        if ( ss_info->ss_status.present && ss_info->ss_status.cm_ss_active )
        {
          response.notificationType = (int) QCRIL_CM_SS_MO_NOTIFICATION;
          response.code = (int) QCRIL_CM_SS_CSSI_UNCOND_FWD_ACTIVE;
          success = TRUE;
        }
        break;

      case qcril_cm_ss_cfb:
      case qcril_cm_ss_cfnry:
      case qcril_cm_ss_cfnrc:
      case qcril_cm_ss_allCondForwardingSS:
        if ( ss_info->ss_status.present && ss_info->ss_status.cm_ss_active )
        {
          response.notificationType = (int) QCRIL_CM_SS_MO_NOTIFICATION;
          response.code = (int) QCRIL_CM_SS_CSSI_COND_FWD_ACTIVE;
          success = TRUE;
        }
        break;

      default:
        break;
    }
  }

  if ( success )
  {
    QCRIL_LOG_DEBUG( "QCRIL_EVT_CM_CALL_ORIG_FWD_STATUS notification type %d, response code %d\n", 
                     response.notificationType, response.code);

    /* Call related notifications to RIL */
    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
    unsol_resp.resp_pkt = ( void * ) &response;
    unsol_resp.resp_len = sizeof( response );
    qcril_send_unsol_response( &unsol_resp );
  }

} /* qcril_cm_callsvc_event_orig_fwd_status */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_call_being_forwarded

===========================================================================*/
/*!
    @brief
    Reports supplementary service related notification from the network that
    outgoing call is being forwarded due to call forwarding being active.

    @return
    RIL_SuppSvcNotification.
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_call_being_forwarded
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  RIL_SuppSvcNotification response;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  response.notificationType = (int) QCRIL_CM_SS_MO_NOTIFICATION;
  response.code = (int) QCRIL_CM_SS_CSSI_CALL_FORWARDED;

  /* All the checks are already take care in CM like checking for the notification
     present and its value, hence sending the reponse directly to RIL*/

  /* Call related notifications to RIL */
  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
  unsol_resp.resp_pkt = ( void * ) &response;
  unsol_resp.resp_len = sizeof( response );
  qcril_send_unsol_response( &unsol_resp );

} /* qcril_cm_callsvc_event_call_being_forwarded */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_call_is_waiting

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CALL_IS_WAITING notification message from network when
    a mobile originated call is made and call is in waiting state on the
    terminating mobile side.

    @return
    RIL_SuppSvcNotification.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_call_is_waiting
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  RIL_SuppSvcNotification response;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  response.notificationType = (int) QCRIL_CM_SS_MO_NOTIFICATION;
  response.code = (int) QCRIL_CM_SS_CSSI_CALL_WAITING;

  /* All the checks are already take care in CM like checking for the notification
     present and its value, hence sending the reponse directly to RIL*/

  /* Call related notifications to RIL */
  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
  unsol_resp.resp_pkt = ( void * ) &response;
  unsol_resp.resp_len = sizeof( response );
  qcril_send_unsol_response( &unsol_resp );

} /* qcril_cm_callsvc_event_call_is_waiting */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_call_barred

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CALL_BARRED notification message from network when
    a MO call is made and barring of outgoing call barring is enabled or when
    the terminating mobile has enalbed incoming call barring.

    @return
    RIL_SuppSvcNotification.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_call_barred
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_cm_struct_type *i_ptr;
  cm_mm_call_info_s_type *call_info_ptr;
  cm_call_ss_info_s_type    *ss_info;
  boolean success = FALSE;
  RIL_SuppSvcNotification response;
  qcril_unsol_resp_params_type unsol_resp;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  call_info_ptr = (cm_mm_call_info_s_type *)params_ptr->data;
  ss_info = &call_info_ptr->mode_info.info.gw_cs_call.ss_info;

  switch ( ss_info->ss_code.ss_code )
  {
    case qcril_cm_ss_barringOfOutgoingCalls:
    case qcril_cm_ss_baoc:
    case qcril_cm_ss_boic:
    case qcril_cm_ss_boicExHC:
      response.notificationType = (int) QCRIL_CM_SS_MO_NOTIFICATION;
      response.code = (int) QCRIL_CM_SS_CSSI_OUTGOING_CALLS_BARRED;
      success = TRUE;
      break;

    case qcril_cm_ss_barringOfIncomingCalls:
    case qcril_cm_ss_baic:
    case qcril_cm_ss_bicRoam:
      response.notificationType = (int) QCRIL_CM_SS_MO_NOTIFICATION;
      response.code = (int) QCRIL_CM_SS_CSSI_INCOMING_CALLS_BARRED;
      success = TRUE;
      break;

    default:
      break;
  }

  if ( success )
  {
    QCRIL_LOG_DEBUG( "QCRIL_EVT_CM_CALL_BARRED notification type %d, response code = %d\n", 
                     response.notificationType, response.code);

    /* Update last call fail cause */
    QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].call_fail_cause_mutex\n", instance_id );
    QCRIL_MUTEX_LOCK( &i_ptr->call_fail_cause_mutex, details );
    i_ptr->call_fail_cause = CALL_FAIL_CALL_BARRED;
    QCRIL_MUTEX_UNLOCK( &i_ptr->call_fail_cause_mutex, details );

    /* Call related notifications to RIL */
    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
    unsol_resp.resp_pkt = ( void * ) &response;
    unsol_resp.resp_len = sizeof( response );
    qcril_send_unsol_response( &unsol_resp );
  }

} /* qcril_cm_callsvc_event_call_barred */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_restricted

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CALL_RESTRICTED notification message from network
    which is sent when clir suppression is rejected from network when a call
    is made with clir suppression enabled but clir is subscribed to permanant
    mode

    @return
    RIL_SuppSvcNotification.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_call_restricted
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  RIL_SuppSvcNotification response;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  response.notificationType = (int) QCRIL_CM_SS_MO_NOTIFICATION;
  response.code = (int) QCRIL_CM_SS_CSSI_CLIR_SUPPRESSION_REJ;

  /* All the checks are already take care in CM like checking for the notification
     present and its value, hence sending the reponse directly to RIL*/

  /* Call related notifications to RIL */
  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
  unsol_resp.resp_pkt = ( void * ) &response;
  unsol_resp.resp_len = sizeof( response );
  qcril_send_unsol_response( &unsol_resp );

} /* qcril_cm_callsvc_event_call_restricted */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_incom_fwd_call

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CALL_INCOM_FWD_CALL notification message from network
    which is sent when the incoming call is a forwarded call

    @return
    RIL_SuppSvcNotification.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_incom_fwd_call
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  RIL_SuppSvcNotification response;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  response.notificationType = (int) QCRIL_CM_SS_MT_NOTIFICATION;
  response.code = (int) QCRIL_CM_SS_CSSU_FORWARDED_CALL;

  /* All the checks are already take care in CM like checking for the notification
     present and its value, hence sending the reponse directly to RIL*/

  /* Call related notifications to RIL */
  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
  unsol_resp.resp_pkt = ( void * ) &response;
  unsol_resp.resp_len = sizeof( response );
  qcril_send_unsol_response( &unsol_resp );

} /* qcril_cm_callsvc_event_incom_fwd_call */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_cug_info_received

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CALL_CUG_INFO_RECEIVED notification from network when
    network includes the CUG_INDEX for either mobile originationg call or
    mobile terminationg call.

    @return
    RIL_SuppSvcNotification.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_cug_info_received
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  cm_mm_call_info_s_type *call_info_ptr;
  cm_forward_cug_info_s_type  *forward_cug_info;
  boolean success = FALSE;
  RIL_SuppSvcNotification response;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  call_info_ptr = (cm_mm_call_info_s_type *)params_ptr->data;
  forward_cug_info = &call_info_ptr->mode_info.info.gw_cs_call.forward_cug_info;

  if ( forward_cug_info->present && forward_cug_info->cm_cug_index.present )
  {
    response.index = forward_cug_info->cm_cug_index.lsb;

    if ( call_info_ptr->call_id < 7 )
    {
      response.notificationType = (int) QCRIL_CM_SS_MO_NOTIFICATION;
      response.code = (int) QCRIL_CM_SS_CSSI_CUG_CALL;
      success = TRUE;
    }
    else if ( ( call_info_ptr->call_id > 7 ) && ( call_info_ptr->call_id < 15 ) )
    {
      response.notificationType = (int) QCRIL_CM_SS_MT_NOTIFICATION;
      response.code = (int) QCRIL_CM_SS_CSSU_CUG_CALL;
      success = TRUE;
    }
    else
    {
      QCRIL_LOG_ERROR( "%s", "received unexpected call id for QCRIL_EVT_CM_CALL_CUG_INFO_RECEIVED\n");
    }
  }
  else
  {
    QCRIL_LOG_ERROR( "%s", "received null value for either cug_info or cug_index\n");
  }

  if ( success )
  {
    QCRIL_LOG_DEBUG( "QCRIL_EVT_CM_CALL_CUG_INFO_RECEIVED notification type %d, response code %d\n", 
                     response.notificationType, response.code);

    /* Call related notifications to RIL */
    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
    unsol_resp.resp_pkt = ( void * ) &response;
    unsol_resp.resp_len = sizeof( response );
    qcril_send_unsol_response( &unsol_resp );
  }

} /* qcril_cm_callsvc_event_cug_info_received */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_call_on_hold

===========================================================================*/
/*!
    Handles QCRIL_EVT_CM_CALL_ON_HOLD notification from network when
    the user on the other side of the call has put the call on HOLD.

    @return
    RIL_SuppSvcNotification.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_call_on_hold
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  RIL_SuppSvcNotification response;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  response.notificationType = (int) QCRIL_CM_SS_MT_NOTIFICATION;
  response.code = (int) QCRIL_CM_SS_CSSU_CALL_HOLD;

  /* All the checks are already take care in CM like checking for the notification
     present and its value, hence sending the reponse directly to RIL*/

  /* Call related notifications to RIL */
  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
  unsol_resp.resp_pkt = ( void * ) &response;
  unsol_resp.resp_len = sizeof( response );
  qcril_send_unsol_response( &unsol_resp );

} /* qcril_cm_callsvc_event_call_on_hold */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_call_retrieved

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CALL_RETRIEVED notification from network when
    the user on the other side of the call has RETRIEVED the HELD call.

    @return
    RIL_SuppSvcNotification.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_call_retrieved
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  RIL_SuppSvcNotification response;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  response.notificationType = (int) QCRIL_CM_SS_MT_NOTIFICATION;
  response.code = (int) QCRIL_CM_SS_CSSU_CALL_RETRIEVED;

  /* All the checks are already take care in CM like checking for the notification
     present and its value, hence sending the reponse directly to RIL*/

  /* Call related notifications to RIL */
  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
  unsol_resp.resp_pkt = ( void * ) &response;
  unsol_resp.resp_len = sizeof( response );
  qcril_send_unsol_response( &unsol_resp );

} /* qcril_cm_callsvc_event_call_retrieved */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_call_forwarded

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_CALL_FORWARDED.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_call_forwarded
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  RIL_SuppSvcNotification response;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* This notificaton is for caller "B" to indicate that its missed calls either due to CFB/CFNRY is
     forwarded to user "C" */
  QCRIL_LOG_DEBUG( "%s", "Received QCRIL_EVT_CM_CALL_FORWARDED\n");

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  response.notificationType = (int) QCRIL_CM_SS_MT_NOTIFICATION;
  response.code = (int) QCRIL_CM_SS_CSSU_ADDITIONAL_INCOM_CALL_FWD;

  /* Call related notifications to RIL */
  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
  unsol_resp.resp_pkt = ( void * ) &response;
  unsol_resp.resp_len = sizeof( response );
  qcril_send_unsol_response( &unsol_resp );

} /* qcril_cm_callsvc_event_call_forwarded */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_transferred_call

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CALL_TRANSFERRED_CALL notification from network for
    active call/held call/alerting call which has been diverted to a new
    number due to explicit call transpher.

    @return
    RIL_SuppSvcNotification.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_transferred_call
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_mm_call_info_s_type *call_info_ptr;
  cm_ect_indicator_s_type  *ect_info;
  RIL_SuppSvcNotification response;
  byte buffer[ CM_CALLED_PARTY_BCD_NO_LENGTH + 1 ];
  byte number[ 2 * CM_CALLED_PARTY_BCD_NO_LENGTH ];
  int count;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  call_info_ptr = (cm_mm_call_info_s_type *)params_ptr->data;
  ect_info = &call_info_ptr->mode_info.info.gw_cs_call.ect_info;

  response.notificationType = (int) QCRIL_CM_SS_MT_NOTIFICATION;

  if ( ect_info->callState == (ect_call_state_T) qcril_cm_ss_notification_alerting_ECT )
  {
    response.code = (int) QCRIL_CM_SS_CSSU_ECT_CALL_REMOTE_PTY_ALERT;
  }
  else if ( ect_info->callState == (ect_call_state_T) qcril_cm_ss_notification_alerting_active_ECT )
  {
    response.code = (int) QCRIL_CM_SS_CSSU_ECT_CALL_REMOTE_PTY_CONNECTED;

    if ( ect_info->routeDestNumber.present )
    {
      if ( ect_info->routeDestNumber.number[ 0 ].present )
      {
        QCRIL_ASSERT( ect_info->routeDestNumber.number[ 0 ].length < CM_CALLED_PARTY_BCD_NO_LENGTH );
        for ( count = 0; count < ect_info->routeDestNumber.number[ 0 ].length; count++ )
        {
          buffer[ count + 1 ] = ect_info->routeDestNumber.number[ 0 ].data[ count ];
        }

        buffer[ 0 ] = ect_info->routeDestNumber.number[ 0 ].length;

        qcril_cm_util_bcd_to_ascii( buffer, number );

        /* Set Type based on '+' prefix */
        response.type = ( QCRIl_CM_SS_TA_INTER_PREFIX == number[ 0 ] ) ? QCRIL_CM_SS_TA_INTERNATIONAL : QCRIL_CM_SS_TA_UNKNOWN;

        /* number[0] contains type and the rest contains the number in ASCII */
        if ( response.type == QCRIL_CM_SS_TA_INTERNATIONAL )
        {
          response.number = (char * )&number[ 1 ];
        }
        else
        {
          response.number = (char * )&number[ 0 ];
        }

        QCRIL_LOG_DEBUG( "ECT notification has number = %s\n",response.number);
      }
    }
  }
  else
  {
    QCRIL_LOG_ERROR( "%s", "received invalid call state value\n");
  }

  QCRIL_LOG_DEBUG( "QCRIL_EVT_CM_CALL_TRANSFERRED_CALL notification type %d, response code %d\n", 
                   response.notificationType, response.code );

  /* Call related notifications to RIL */
  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
  unsol_resp.resp_pkt = ( void * ) &response;
  unsol_resp.resp_len = sizeof( response );
  qcril_send_unsol_response( &unsol_resp );

} /* qcril_cm_callsvc_event_transferred_call */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_cnap_info_received

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CALL_CNAP_INFO_RECEIVED notification from network for
    incoming call to display the incoming caller name.

    @return
    none.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_cnap_info_received
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_mm_call_info_s_type *call_info_ptr = NULL;
  boolean unsol_call_state_changed = FALSE;
  qcril_cm_clist_public_type call_info;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  call_info_ptr = (cm_mm_call_info_s_type *)params_ptr->data;

  QCRIL_ASSERT( call_info_ptr != NULL );

  QCRIL_LOG_DEBUG( "CNAP event received with call id= %u num bytes= %u  coding scheme= %u\n",
                   call_info_ptr->call_id, call_info_ptr->enc_alpha.num_bytes, call_info_ptr->enc_alpha.coding_scheme);

  qcril_cm_util_process_cnap_info( instance_id, modem_id, call_info_ptr, &unsol_call_state_changed );

  if ( qcril_cm_clist_query_voice_call_id( instance_id, modem_id, call_info_ptr->call_id, &call_info ) == E_SUCCESS )
  {
    if ( ( call_info.state != QCRIL_CM_CLIST_STATE_SETUP ) && ( unsol_call_state_changed ) )
    {
      qcril_cm_send_unsol_call_state_changed( instance_id );
    }
    else
    {
      QCRIL_LOG_DEBUG( "call_state = %d, unsol_call_status_changed = %d\n", call_info.state, unsol_call_state_changed );
    }
  }
  else
  {
    QCRIL_LOG_DEBUG( "call does not exist with Call-Id = %d recieved in CM_CALL_EVENT_CNAP_INFO_RECEIVED\n", call_info_ptr->call_id);
  }

}  /* qcril_cm_callsvc_event_cnap_info_received */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_call_deflection

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CALL_DEFLECTION notification from network when either
    the mobile originated call is deflected from the termination side or the
    mobile terminating call is a defelected call.

    @return
    RIL_SuppSvcNotification.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_call_deflection
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  cm_mm_call_info_s_type *call_info_ptr;
  RIL_SuppSvcNotification response;
  boolean success = TRUE;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  call_info_ptr = (cm_mm_call_info_s_type *)params_ptr->data;

  /* call_ids are stored by CM similar to the ones stored in NAS
     for MO calls it ranges from 0-6 and for MT calls it ranges from 8-14 */
  if ( call_info_ptr->call_id < 7 )
  {
    response.notificationType = (int) QCRIL_CM_SS_MO_NOTIFICATION;
    response.code = (int) QCRIL_CM_SS_CSSI_CALL_DEFLECTED;
  }
  else if ( ( call_info_ptr->call_id > 7 ) && ( call_info_ptr->call_id < 15 ) )
  {
    response.notificationType = (int) QCRIL_CM_SS_MT_NOTIFICATION;
    response.code = (int) QCRIL_CM_SS_CSSU_DEFLECTED_CALL;
  }
  else
  {
    QCRIL_LOG_ERROR( "%s", "received unexpected call id for QCRIL_EVT_CM_CALL_DEFLECTION\n");
    success = FALSE;
  }

  if ( success )
  {
    QCRIL_LOG_DEBUG( "QCRIL_EVT_CM_CALL_DEFLECTION notification type %d, response code %d\n", 
                     response.notificationType, response.code);

    /* Call related notifications to RIL */
    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
    unsol_resp.resp_pkt = ( void * ) &response;
    unsol_resp.resp_len = sizeof( response );
    qcril_send_unsol_response( &unsol_resp );
  }

} /* qcril_cm_callsvc_event_call_deflection */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_otasp_status

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CALL_OTASP_STATUS notification message from network when
    a mobile originated or mobile terminated OTASP/OTAPA is made.

    @return
    RIL_CDMA_OTA_ProvisionStatus.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_otasp_status
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  cm_mm_call_info_s_type *otasp_info_ptr;
  RIL_CDMA_OTA_ProvisionStatus response;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  otasp_info_ptr = (cm_mm_call_info_s_type *)params_ptr->data;
  QCRIL_ASSERT( otasp_info_ptr != NULL );

  QCRIL_LOG_DEBUG( "QCRIL_EVT_CM_CALL_OTASP_STATUS status = %d\n",otasp_info_ptr->mode_info.info.cdma_call.otasp_status);

  if ( ( otasp_info_ptr->mode_info.info.cdma_call.otasp_status < CM_OTASP_STATUS_SPL_UNLOCKED ) ||
       ( otasp_info_ptr->mode_info.info.cdma_call.otasp_status > CM_OTASP_STATUS_OTAPA_ABORTED ) )
  {
    QCRIL_LOG_ERROR( "%s\n","Received unexpected otasp status ");
    return;
  }

  response = (RIL_CDMA_OTA_ProvisionStatus)otasp_info_ptr->mode_info.info.cdma_call.otasp_status;
  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_CDMA_OTA_PROVISION_STATUS, &unsol_resp );
  unsol_resp.resp_pkt = ( void * ) &response;
  unsol_resp.resp_len = sizeof( response );
  qcril_send_unsol_response( &unsol_resp );

} /* qcril_cm_callsvc_event_otasp_status */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_privacy_pref

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_PRIVACY_PREF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_privacy_pref
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  const cm_mm_call_info_s_type *call_info_ptr; 
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, params_ptr->event_id, 
                                                call_info_ptr->call_id, &req_info ) == E_SUCCESS ) 
  {
    if ( req_info.request == RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE )
    {
      if ( ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_CDMA ) &&
           ( call_info_ptr->mode_info.info.cdma_call.privacy_pref == req_info.sub.cm.info.privacy_pref ) )
      {
        if ( req_info.sub.cm.info.privacy_pref == CM_PRIVACY_PREF_STANDARD )
        {
          QCRIL_LOG_DEBUG( "Reply to RIL --> Standard Voice Privacy Mode, call id %d\n", call_info_ptr->call_id ); 
        }
        else
        {
          QCRIL_LOG_DEBUG( "Reply to RIL --> Enhanced Voice Privacy Mode, call id %d\n", call_info_ptr->call_id ); 
        }

        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        qcril_send_request_response( &resp );
      }
    }
    else
    {
      QCRIL_LOG_ERROR( "Unhandled CM_CALL_EVENT_PRIVACY_PREF for %s (%d)\n", 
                       qcril_log_lookup_event_name( req_info.request ), req_info.request ); 
      qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  }                               

} /* qcril_cm_callsvc_event_privacy_pref */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_privacy

===========================================================================*/
/*!
    @brief
    Handle CM_CALL_EVENT_PRIVACY.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_privacy
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  const cm_mm_call_info_s_type *call_info_ptr; 
  boolean unsol_call_state_changed = FALSE;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Update the state of the record in CList */

  if ( call_info_ptr->mode_info.info_type == CM_CALL_MODE_INFO_CDMA ) 
  {
    if ( qcril_cm_clist_update_voice_privacy_mode( instance_id, modem_id, call_info_ptr->call_id, 
                                                   call_info_ptr->mode_info.info.cdma_call.is_privacy,
                                                   &unsol_call_state_changed ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Failed to update the privacy mode of CList entry for connect : call_id %d\n", call_info_ptr->call_id );
    }
    /* Send unsolicited call state changed indication */
    else if ( unsol_call_state_changed )
    {
      qcril_cm_send_unsol_call_state_changed( instance_id );
    }
  }
  
} /* qcril_cm_callsvc_event_privacy */


/*=========================================================================
  FUNCTION:  qcril_cm_process_cdma_info_recs

===========================================================================*/
/*!
    @brief
    This function is called when the last CDMA information record in an OTA
    message has been received.  It processes all the information records and 
    sends the appropriate UNSOL RIL responses.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_process_cdma_info_recs 
(
  qcril_instance_id_e_type instance_id,
  qcril_modem_id_e_type modem_id
)
{
  qcril_cm_struct_type *i_ptr;
  boolean call_is_in_incoming_state = FALSE;
  boolean call_is_in_call_waiting_state = FALSE;
  boolean name_is_received = FALSE;
  boolean number_is_received = FALSE;
  boolean signal_is_received = FALSE;
  char name[ CM_MAX_ALPHA_TAG_CHARS ];
  cm_num_s_type number;
  RIL_CDMA_SignalInfoRecord signal_info_rec;
  uint8 i;
  uint8 display_tag;
  uint8 display_len;
  uint8 curr_pos = 0;
  qcril_cm_clist_public_type call_info;
  IxErrnoType err_no;
  boolean name_changed = FALSE;
  boolean number_changed = FALSE;
  RIL_CDMA_CallWaiting call_waiting;
  /* Info recs which will be sent to Android in RIL_UNSOL_CDMA_INFO_REC. */
  RIL_CDMA_InformationRecords info_recs; 
  uint8 alpha_buf[QCRIL_CM_MAX_ALPHA_BUF_SIZE];
  uint8 alpha_len;
  RIL_CDMA_InformationRecords * infoRecs_ptr;
  cm_call_id_type call_id;
  qcril_unsol_resp_params_type unsol_resp;
  char details[ 40 ];
  int offset = 0;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].cdma_info_rec_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->cdma_info_rec_mutex, details );

  if ( i_ptr->cdma_info_recs_timer_id != 0xFFFF )
  {
    qcril_cancel_timed_callback( (void *) i_ptr->cdma_info_recs_timer_id );
    i_ptr->cdma_info_recs_timer_id = 0xFFFF;
  }

  /* Initialize the variables */
  name[ 0 ] = '\0';
  memset( &number, 0, sizeof( cm_num_s_type ) );
  number.buf[ 0 ] = '\0';
  signal_info_rec.isPresent = FALSE;

  info_recs.numberOfInfoRecs = 0;

  infoRecs_ptr = &i_ptr->cdma_info_recs.recs;

  call_id = i_ptr->cdma_info_recs.call_id;

  if ( infoRecs_ptr->numberOfInfoRecs == 0 )
  {
    /* There are no info recs in the buffer waiting to be processed, so there
       is nothing to send to the UI. */
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  /* Determine the state of the call */
  err_no = qcril_cm_clist_query_voice_call_id( instance_id, modem_id, call_id, &call_info );

  /* If the call_id is not in the call list, we are likely in Idle state, in
     which case we will just buffer up all the info recs. */
  if ( err_no == E_SUCCESS )
  {
    if ( QCRIL_CM_CLIST_CALL_TYPE_IS_VOICE( call_info.call_type ) )
    {
      if ( call_info.state == QCRIL_CM_CLIST_STATE_INCOMING )
      {
        call_is_in_incoming_state = TRUE;
      }
      else if ( call_info.state == QCRIL_CM_CLIST_STATE_ACTIVE )
      {
        /* If the call is active and we get a Calling Party Number info rec,
           it is call waiting. */
        for ( i = 0; i < infoRecs_ptr->numberOfInfoRecs; i++ )
        {
          if ( ( infoRecs_ptr->infoRec[i].name == RIL_CDMA_CALLING_PARTY_NUMBER_INFO_REC ) ||
               ( infoRecs_ptr->infoRec[i].name == RIL_CDMA_T53_CLIR_INFO_REC ) )
          {
            call_is_in_call_waiting_state = TRUE;
          }
        }
      }
    }
  }

  QCRIL_LOG_DEBUG( "Call id=%d, Incoming state=%d, Call waiting state=%d", call_id, call_is_in_incoming_state, 
                   call_is_in_call_waiting_state );

  /* Loop through info recs and attempt to extract the name, number and signal
     info rec.  Records which are extracted will not be included in
     RIL_UNSOL_CDMA_INFO_REC. */
  for ( i = 0; i < infoRecs_ptr->numberOfInfoRecs; i++ )
  {
    switch ( infoRecs_ptr->infoRec[i].name )
    {
      case RIL_CDMA_CALLING_PARTY_NUMBER_INFO_REC:
        if ( !number_is_received && ( call_is_in_incoming_state || call_is_in_call_waiting_state ) )
        {
          /* A Calling Party Number info rec has been received.
             Extract the number. */
          number.number_type = infoRecs_ptr->infoRec[ i ].rec.number.number_type;
          QCRIL_LOG_DEBUG( "number_type : %d; number.buf[0] : %d", number.number_type,
                infoRecs_ptr->infoRec[ i ].rec.number.buf[0] );
          if ( ( number.number_type == QCRIL_CM_NUM_TYPE_INTERNATIONAL ) &&
               ( infoRecs_ptr->infoRec[ i ].rec.number.buf[0] != '+') )
          {
             offset = 1;
             number.buf[0] = '+';
          }
          number.len = infoRecs_ptr->infoRec[ i ].rec.number.len;
          memcpy( number.buf + offset, infoRecs_ptr->infoRec[ i ].rec.number.buf,
                infoRecs_ptr->infoRec[ i ].rec.number.len );
          number.buf[ offset + number.len ] = '\0';
          number.number_plan = infoRecs_ptr->infoRec[ i ].rec.number.number_plan;
          number.pi = infoRecs_ptr->infoRec[ i ].rec.number.pi;
          number.si = infoRecs_ptr->infoRec[ i ].rec.number.si;

          number_is_received = TRUE;

          QCRIL_LOG_DEBUG( "Received Number : %s; Number length : %d", number.buf, number.len );
        }
        else
        {
          /* Either we are not incoming or call waiting state, or we have already
             received a number; pass the info rec up to the UI. */
          info_recs.infoRec[ (uint8) info_recs.numberOfInfoRecs ] = infoRecs_ptr->infoRec[ i ];
          info_recs.numberOfInfoRecs++;
        }
        break;

      case RIL_CDMA_EXTENDED_DISPLAY_INFO_REC:
        if ( !name_is_received && ( call_is_in_incoming_state || call_is_in_call_waiting_state ) )
        {
          /* Curr_pos is our current position within the alpha buf inside the 
             Extended Display info rec. */
          curr_pos = 0;
          /* Alpha_len is our current position inside the alpha buf that will be sent
             in RIL_UNSOL_CDMA_INFO_REC. */
          alpha_len = 0;

          /* Traverse the entire alpha_buf in the Extended Display info rec.  If we
             find the name, it will be extracted.  Everything else will be sent
             to the UI in RIL_UNSOL_CDMA_INFO_REC. */
          while ( ( curr_pos + 1 ) < infoRecs_ptr->infoRec[ i ].rec.display.alpha_len )
          {
            /* The display_tag, display_len and chari fields are all 1 byte */
            display_tag = infoRecs_ptr->infoRec[ i ].rec.display.alpha_buf[ curr_pos ];
            display_len = infoRecs_ptr->infoRec[ i ].rec.display.alpha_buf[ curr_pos + 1 ];

            if ( curr_pos + display_len + 2 > QCRIL_CM_MAX_ALPHA_BUF_SIZE )
            {
              /* This record will exceed the size of the alpha buffer.  Break out
                 of the while loop, and send to the UI what has already been stored. */
              QCRIL_LOG_ERROR( "%s", "Size of alpha buffer has been exceeded.\n" );
              break;
            }

            /* If the display_tag is Calling Party Name, Original Called Name, or
               Text, extract the the name from the alpha buffer */
            if ( !name_is_received && ( ( display_tag == 0x8D ) || ( display_tag == 0x8F ) || ( display_tag == 0x9E ) ) )
            {
              memcpy( name, &infoRecs_ptr->infoRec[i].rec.display.alpha_buf[curr_pos+2], display_len );
              name[ display_len ] = '\0';

              name_is_received = TRUE;

              QCRIL_LOG_DEBUG( "Display name is received: %s", name );
            }
            else
            {
              /* It is not one of the display_tags we are looking for.  Store it so
                 it can be sent in RIL_UNSOL_CDMA_INFO_REC. */
              memcpy( &alpha_buf[ alpha_len ], &infoRecs_ptr->infoRec[ i ].rec.display.alpha_buf[ curr_pos ], display_len + 2 );
              alpha_len += display_len + 2;
            }

            /* Increment current position by the number of characters (display_len)
               plus 2 to account for the length of the display_tag and display_len
               fields. */
            curr_pos += display_len + 2;
          }

          /* Create an Extended Display info rec with the modified alpha buffer */
          if ( alpha_len > 0 )
          {
            info_recs.infoRec[ (uint8) info_recs.numberOfInfoRecs ].name = RIL_CDMA_EXTENDED_DISPLAY_INFO_REC;
            info_recs.infoRec[ (uint8) info_recs.numberOfInfoRecs ].rec.display.alpha_len = alpha_len;
            memcpy(info_recs.infoRec[ (uint8) info_recs.numberOfInfoRecs ].rec.display.alpha_buf, alpha_buf, alpha_len );
            info_recs.numberOfInfoRecs++;
          }
        }
        else
        {
          /* Either we are not incoming or call waiting state, or we have already
             received a name; pass the info rec up to the UI. */
          info_recs.infoRec[ (uint8) info_recs.numberOfInfoRecs ] = infoRecs_ptr->infoRec[ i ];
          info_recs.numberOfInfoRecs++;
        }
        break;

     case RIL_CDMA_SIGNAL_INFO_REC:
       if ( !signal_is_received && ( call_is_in_incoming_state || call_is_in_call_waiting_state ) )
       {
         /* A Signal info rec has been received. */
         signal_info_rec = infoRecs_ptr->infoRec[ i ].rec.signal;
         signal_is_received = TRUE;
       }
       else
       {
         /* Either we are not incoming or call waiting state, or we have already
            received a signal info rec; pass the info rec up to the UI. */
         info_recs.infoRec[ (uint8) info_recs.numberOfInfoRecs ] = infoRecs_ptr->infoRec[ i ];
         info_recs.numberOfInfoRecs++;
       }
       break;

     case RIL_CDMA_T53_CLIR_INFO_REC:
       if( !number_is_received && ( call_is_in_incoming_state || call_is_in_call_waiting_state ) )
       {
         /* Rejected by user */
         if( infoRecs_ptr->infoRec[ i ].rec.clir.cause == 1 )
         {
           number.pi = 1; // restricted
         }
         /* Coin line */
         else if ( infoRecs_ptr->infoRec[ i ].rec.clir.cause == 3 )
         {
           number.pi = 3; // payphone
         }
         /* No cause, interaction with other service, or service not available */
         else
         {
           number.pi = 2; // unknown
         }

         number_is_received = TRUE;
       }
       else
       {
         info_recs.infoRec[ (uint8) info_recs.numberOfInfoRecs ] = infoRecs_ptr->infoRec[ i ];
         info_recs.numberOfInfoRecs++;
       }
       break;

     case RIL_CDMA_DISPLAY_INFO_REC:
     case RIL_CDMA_CALLED_PARTY_NUMBER_INFO_REC:
     case RIL_CDMA_CONNECTED_NUMBER_INFO_REC:
     case RIL_CDMA_REDIRECTING_NUMBER_INFO_REC:
     case RIL_CDMA_LINE_CONTROL_INFO_REC:
     case RIL_CDMA_T53_RELEASE_INFO_REC:
     case RIL_CDMA_T53_AUDIO_CONTROL_INFO_REC:
       /* For all other info recs, we do not need to extract any information.  
          Just send them to Android via RIL_UNSOL_CDMA_INFO_REC. */
       info_recs.infoRec[ (uint8) info_recs.numberOfInfoRecs ] = infoRecs_ptr->infoRec[ i ];
       info_recs.numberOfInfoRecs++;
       break;
    }
  } /* for each info rec */

  if ( call_is_in_incoming_state )
  {
    if ( name_is_received && ( strcmp( name, call_info.name ) != 0 ) )
    {
      name_changed = TRUE;

      /* Update name in the call list*/
      if ( qcril_cm_clist_update_name( instance_id, modem_id, call_id, name ) != E_SUCCESS )
      {
        QCRIL_LOG_ERROR( "Failed to update the name of CList entry for call_id %d\n", call_id );
      }
    }

    if ( number_is_received && 
         ( ( strcmp( (char *) number.buf, (char *) call_info.num.buf ) != 0 ) || ( number.pi != call_info.num.pi ) ) )
    {
      number_changed = TRUE;

      /* Update number in the call list*/
      if ( qcril_cm_clist_update_number( instance_id, modem_id, call_id, &number ) != E_SUCCESS )
      {
        QCRIL_LOG_ERROR( "Failed to update the number of CList entry for call_id %d\n", call_id );
      }
    }

    if ( name_changed || number_changed )
    {
      /* If the name or number changed, send the call state changed event, 
         so Android can retrieve the updated values from the call list. */
      qcril_cm_send_unsol_call_state_changed( instance_id );
    }

    if (signal_is_received)
    {
      /* Report the incoming voice call */
      qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_CALL_RING, &unsol_resp );
      unsol_resp.resp_pkt = ( void * ) &signal_info_rec;
      unsol_resp.resp_len = sizeof( RIL_CDMA_SignalInfoRecord );
      qcril_send_unsol_response( &unsol_resp );
    }
  }

  if ( call_is_in_call_waiting_state )
  {
    boolean should_report_to_ui = TRUE;

    /* Fill in the Call Waiting information */
    call_waiting.number = (char *) number.buf;
    call_waiting.numberPresentation = number.pi;
    call_waiting.name = name;
    call_waiting.signalInfoRecord = signal_info_rec;

    QCRIL_LOG_DEBUG( "Number : %s; Number Presentation: %d; Name : %s; Signal Info Rec.isPresent : %d",
                    call_waiting.number,
                    call_waiting.numberPresentation,
                    call_waiting.name,
                    call_waiting.signalInfoRecord.isPresent
                  );

    QCRIL_LOG_DEBUG("previous_waiting_call_number: %s", previous_waiting_call_number.buf);
    QCRIL_LOG_DEBUG("t_rx_previous_waiting_call_id_time: %d", t_rx_previous_waiting_call_id_time.tv_sec );

    if( ( number.len == previous_waiting_call_number.len )  && ( strcmp( number.buf, previous_waiting_call_number.buf ) == 0 )  )
    {
      // The same number
      struct timeval cur_time;

      gettimeofday( &cur_time, NULL );

      QCRIL_LOG_DEBUG("The same number, cur_time = %d, delta = %d", cur_time.tv_sec, cur_time.tv_sec - t_rx_previous_waiting_call_id_time.tv_sec );

      if( cur_time.tv_sec - t_rx_previous_waiting_call_id_time.tv_sec < CALL_WAITING_DELTA )
      {
        // Ignore the next one
        should_report_to_ui = FALSE;
        QCRIL_LOG_DEBUG("Ignore this RIL_UNSOL_CDMA_CALL_WAITING");
      }
    } else {
      // A new one
      strcpy( previous_waiting_call_number.buf, number.buf );
      previous_waiting_call_number.len = number.len;

      QCRIL_LOG_DEBUG("NEW RIL_UNSOL_CDMA_CALL_WAITING");
    }
    // record the last call waiting time
    gettimeofday( &t_rx_previous_waiting_call_id_time, NULL );

    if( should_report_to_ui ) {
      qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_CDMA_CALL_WAITING, &unsol_resp );
      unsol_resp.resp_pkt = ( void * ) &call_waiting;
      unsol_resp.resp_len = sizeof( RIL_CDMA_CallWaiting );
      qcril_send_unsol_response( &unsol_resp );
    }
  }

  QCRIL_LOG_DEBUG( "Number of info recs to be sent in event is %d", info_recs.numberOfInfoRecs );

  if ( info_recs.numberOfInfoRecs > 0 )
  {
    /* If there are any info recs remaining after extracting the name, number
       and signal info, send them to the UI. */

    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_CDMA_INFO_REC, &unsol_resp );
    unsol_resp.resp_pkt = ( void * ) &info_recs;
    unsol_resp.resp_len = sizeof( RIL_CDMA_InformationRecords );
    qcril_send_unsol_response( &unsol_resp );
  }

  /* Clear the information record array */
  infoRecs_ptr->numberOfInfoRecs = 0;

  QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );

} /* qcril_cm_process_cdma_info_recs */


/*===========================================================================

  FUNCTION:  qcril_cm_poll_cdma_info_recs

===========================================================================*/
/*!
    @brief
    Sends the appropriate UNSOL RIL responses if the last CDMA information 
    record in an OTA message has not been received.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_poll_cdma_info_recs
(
  void *param
)
{
  uint32 timer_id = (uint32) param;
  qcril_instance_id_e_type instance_id = QCRIL_EXTRACT_INSTANCE_ID_FROM_USER_DATA( timer_id );
  qcril_modem_id_e_type modem_id = QCRIL_EXTRACT_MODEM_ID_FROM_USER_DATA( timer_id );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "Poll CDMA Info Recs Timer expired with ID %d\n", timer_id );

  qcril_cm_process_cdma_info_recs( instance_id, modem_id );

} /* qcril_cm_poll_dma_info_recs */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_caller_id

===========================================================================*/
/*!
    @brief
    Handles CM_CALL_EVENT_CALLER_ID.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_caller_id
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr;
  RIL_CDMA_InformationRecord * info_rec_ptr;
  uint8 index;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  index = i_ptr->cdma_info_recs.recs.numberOfInfoRecs;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].cdma_info_rec_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Buffer the info rec so it can be processed once all the information
     records have been received. */

  if ( i_ptr->cdma_info_recs.recs.numberOfInfoRecs == RIL_CDMA_MAX_NUMBER_OF_INFO_RECS )
  {
    QCRIL_LOG_ERROR( "%s", "Size of info rec array has been exceeded.\n" );
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  i_ptr->cdma_info_recs.call_id = call_info_ptr->call_id;

  info_rec_ptr = &i_ptr->cdma_info_recs.recs.infoRec[index];

  info_rec_ptr->name = RIL_CDMA_CALLING_PARTY_NUMBER_INFO_REC;
  info_rec_ptr->rec.number.len = call_info_ptr->num.len;
  memcpy(info_rec_ptr->rec.number.buf,
         call_info_ptr->num.buf,
         call_info_ptr->num.len);
  info_rec_ptr->rec.number.number_type = call_info_ptr->num.number_type;
  info_rec_ptr->rec.number.number_plan = call_info_ptr->num.number_plan;
  info_rec_ptr->rec.number.pi = call_info_ptr->num.pi;
  info_rec_ptr->rec.number.si = call_info_ptr->num.si;

  i_ptr->cdma_info_recs.recs.numberOfInfoRecs++;

  if ( !call_info_ptr->mode_info.info.cdma_call.is_last_cdma_info_rec )
  {
    /* If this is not the last info rec, set a sanity timer.  If the bs sends info recs
       which are unsupported by the bs, we may never get the notification for the last 
       info rec, so call the function to process the info recs after the sanity timer expires. */
    if ( i_ptr->cdma_info_recs_timer_id == 0xFFFF )
    {
      qcril_setup_timed_callback( instance_id, modem_id, qcril_cm_poll_cdma_info_recs, 
                                  &QCRIL_CM_TIMEVAL_CDMA_INFO_REC,
                                  &i_ptr->cdma_info_recs_timer_id );
    }
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );

  if ( call_info_ptr->mode_info.info.cdma_call.is_last_cdma_info_rec )
  {
    /* Received the last info record.  Process them now. */
    qcril_cm_process_cdma_info_recs( instance_id, modem_id );
  }

} /* qcril_cm_callsvc_event_caller_id */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_signal

===========================================================================*/
/*!
    @brief
    Handles CM_CALL_EVENT_SIGNAL.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_signal
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr; 
  RIL_CDMA_InformationRecord * info_rec_ptr;
  uint8 index;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  index = i_ptr->cdma_info_recs.recs.numberOfInfoRecs;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].cdma_info_rec_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Buffer the info rec so it can be processed once all the information
     records have been received. */

  if ( i_ptr->cdma_info_recs.recs.numberOfInfoRecs == RIL_CDMA_MAX_NUMBER_OF_INFO_RECS )
  {
    QCRIL_LOG_ERROR( "%s", "Size of info rec array has been exceeded.\n" );
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  /* do not play AWIM tones for data/sms call types.
     play tone for cm_call_type_none as it is for notification info records.
     do not play tone for call_type_otapa as it is a type of data call.  */
  if( ! ( ( call_info_ptr->call_type == CM_CALL_TYPE_VOICE ) ||
          ( call_info_ptr->call_type == CM_CALL_TYPE_STD_OTASP ) || ( call_info_ptr->call_type == CM_CALL_TYPE_NON_STD_OTASP ) ||
          ( call_info_ptr->call_type == CM_CALL_TYPE_EMERGENCY ) || ( call_info_ptr->call_type == CM_CALL_TYPE_NONE ) ||
          ( call_info_ptr->call_type == CM_CALL_TYPE_SUPS )  ||
          ( call_info_ptr->call_type == CM_CALL_TYPE_TEST ) ) )
  {
    QCRIL_LOG_ERROR( "Ignoring event = %d, due to non-voice call, call type = %d\n", params_ptr->event_id, call_info_ptr->call_type );
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  i_ptr->cdma_info_recs.call_id = call_info_ptr->call_id;

  info_rec_ptr = &i_ptr->cdma_info_recs.recs.infoRec[index];

  info_rec_ptr->name = RIL_CDMA_SIGNAL_INFO_REC;
  info_rec_ptr->rec.signal.isPresent = call_info_ptr->signal.is_signal_info_avail;
  info_rec_ptr->rec.signal.signalType = call_info_ptr->signal.signal_type;
  info_rec_ptr->rec.signal.alertPitch = call_info_ptr->signal.alert_pitch;
  info_rec_ptr->rec.signal.signal = call_info_ptr->signal.signal;

  i_ptr->cdma_info_recs.recs.numberOfInfoRecs++;

  if ( !call_info_ptr->mode_info.info.cdma_call.is_last_cdma_info_rec )
  {
    /* If this is not the last info rec, set a sanity timer.  If the bs sends info recs
       which are unsupported by the bs, we may never get the notification for the last 
       info rec, so call the function to process the info recs after the sanity timer expires. */
    if ( i_ptr->cdma_info_recs_timer_id == 0xFFFF )
    {
      qcril_setup_timed_callback( instance_id, modem_id, qcril_cm_poll_cdma_info_recs, 
                                  &QCRIL_CM_TIMEVAL_CDMA_INFO_REC,
                                  &i_ptr->cdma_info_recs_timer_id );
    }
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );

  if ( call_info_ptr->mode_info.info.cdma_call.is_last_cdma_info_rec )
  {
    /* Received the last info record.  Process them now. */
    qcril_cm_process_cdma_info_recs( instance_id, modem_id );
  }

} /* qcril_cm_callsvc_event_signal */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_display

===========================================================================*/
/*!
    @brief
    Handles CM_CALL_EVENT_DISPLAY.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_display
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr; 
  RIL_CDMA_InformationRecord * info_rec_ptr;
  uint8 index;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  index = i_ptr->cdma_info_recs.recs.numberOfInfoRecs;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].cdma_info_rec_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Buffer the info rec so it can be processed once all the information
     records have been received. */

  if ( i_ptr->cdma_info_recs.recs.numberOfInfoRecs == RIL_CDMA_MAX_NUMBER_OF_INFO_RECS )
  {
    QCRIL_LOG_ERROR( "%s", "Size of info rec array has been exceeded.\n" );
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  i_ptr->cdma_info_recs.call_id = call_info_ptr->call_id;

  info_rec_ptr = &i_ptr->cdma_info_recs.recs.infoRec[index];

  info_rec_ptr->name = RIL_CDMA_DISPLAY_INFO_REC;
  info_rec_ptr->rec.display.alpha_len = call_info_ptr->alpha.len;
  memcpy(info_rec_ptr->rec.display.alpha_buf,
         call_info_ptr->alpha.buf,
         call_info_ptr->alpha.len);

  i_ptr->cdma_info_recs.recs.numberOfInfoRecs++;

  QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Received the last info record.  Process them now. */
  qcril_cm_process_cdma_info_recs( instance_id, modem_id );

} /* qcril_cm_callsvc_event_display */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_called_party

===========================================================================*/
/*!
    @brief
    Handles CM_CALL_EVENT_CALLED_PARTY.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_called_party
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr; 
  RIL_CDMA_InformationRecord * info_rec_ptr;
  uint8 index;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  index = i_ptr->cdma_info_recs.recs.numberOfInfoRecs;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].cdma_info_rec_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Buffer the info rec so it can be processed once all the information
     records have been received. */

  if ( i_ptr->cdma_info_recs.recs.numberOfInfoRecs == RIL_CDMA_MAX_NUMBER_OF_INFO_RECS )
  {
    QCRIL_LOG_ERROR( "%s", "Size of info rec array has been exceeded.\n" );
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  i_ptr->cdma_info_recs.call_id = call_info_ptr->call_id;

  info_rec_ptr = &i_ptr->cdma_info_recs.recs.infoRec[index];

  info_rec_ptr->name = RIL_CDMA_CALLED_PARTY_NUMBER_INFO_REC;
  info_rec_ptr->rec.number.len = call_info_ptr->num.len;
  memcpy(info_rec_ptr->rec.number.buf,
         call_info_ptr->num.buf,
         call_info_ptr->num.len);
  info_rec_ptr->rec.number.number_type = call_info_ptr->num.number_type;
  info_rec_ptr->rec.number.number_plan = call_info_ptr->num.number_plan;

  i_ptr->cdma_info_recs.recs.numberOfInfoRecs++;

  QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Received the last info record.  Process them now. */
  qcril_cm_process_cdma_info_recs( instance_id, modem_id );

} /* qcril_cm_callsvc_event_called_party */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_connected_num

===========================================================================*/
/*!
    @brief
    Handles CM_CALL_EVENT_CONNECTED_NUM.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_connected_num
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr;
  RIL_CDMA_InformationRecord * info_rec_ptr;
  uint8 index;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  index = i_ptr->cdma_info_recs.recs.numberOfInfoRecs;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].cdma_info_rec_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Buffer the info rec so it can be processed once all the information
     records have been received. */

  if ( i_ptr->cdma_info_recs.recs.numberOfInfoRecs == RIL_CDMA_MAX_NUMBER_OF_INFO_RECS )
  {
    QCRIL_LOG_ERROR( "%s", "Size of info rec array has been exceeded.\n" );
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  i_ptr->cdma_info_recs.call_id = call_info_ptr->call_id;

  info_rec_ptr = &i_ptr->cdma_info_recs.recs.infoRec[index];

  info_rec_ptr->name = RIL_CDMA_CONNECTED_NUMBER_INFO_REC;
  info_rec_ptr->rec.number.len = call_info_ptr->num.len;
  memcpy(info_rec_ptr->rec.number.buf,
         call_info_ptr->num.buf,
         call_info_ptr->num.len);
  info_rec_ptr->rec.number.number_type = call_info_ptr->num.number_type;
  info_rec_ptr->rec.number.number_plan = call_info_ptr->num.number_plan;
  info_rec_ptr->rec.number.pi = call_info_ptr->num.pi;
  info_rec_ptr->rec.number.si = call_info_ptr->num.si;

  i_ptr->cdma_info_recs.recs.numberOfInfoRecs++;

  QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Received the last info record.  Process them now. */
  qcril_cm_process_cdma_info_recs( instance_id, modem_id );

} /* qcril_cm_callsvc_event_connected_num */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_ext_display 

===========================================================================*/
/*!
    @brief
    Handles CM_CALL_EVENT_EXT_DISP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_ext_display 
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr; 
  RIL_CDMA_InformationRecord * info_rec_ptr;
  uint8 index;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  index = i_ptr->cdma_info_recs.recs.numberOfInfoRecs;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].cdma_info_rec_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Buffer the info rec so it can be processed once all the information
     records have been received. */

  if ( i_ptr->cdma_info_recs.recs.numberOfInfoRecs == RIL_CDMA_MAX_NUMBER_OF_INFO_RECS )
  {
    QCRIL_LOG_ERROR( "%s", "Size of info rec array has been exceeded.\n" );
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  i_ptr->cdma_info_recs.call_id = call_info_ptr->call_id;

  info_rec_ptr = &i_ptr->cdma_info_recs.recs.infoRec[index];

  info_rec_ptr->name = RIL_CDMA_EXTENDED_DISPLAY_INFO_REC;
  info_rec_ptr->rec.display.alpha_len = call_info_ptr->alpha.len;
  memcpy(info_rec_ptr->rec.display.alpha_buf,
         call_info_ptr->alpha.buf,
         call_info_ptr->alpha.len);

  i_ptr->cdma_info_recs.recs.numberOfInfoRecs++;

  if ( !call_info_ptr->mode_info.info.cdma_call.is_last_cdma_info_rec )
  {
    /* If this is not the last info rec, set a sanity timer.  If the bs sends info recs
       which are unsupported by the bs, we may never get the notification for the last 
       info rec, so call the function to process the info recs after the sanity timer expires. */
    if ( i_ptr->cdma_info_recs_timer_id == 0xFFFF )
    {
      qcril_setup_timed_callback( instance_id, modem_id, qcril_cm_poll_cdma_info_recs, 
                                  &QCRIL_CM_TIMEVAL_CDMA_INFO_REC,
                                  &i_ptr->cdma_info_recs_timer_id );
    }
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );

  if ( call_info_ptr->mode_info.info.cdma_call.is_last_cdma_info_rec )
  {
    /* Received the last info record.  Process them now. */
    qcril_cm_process_cdma_info_recs( instance_id, modem_id );
  }

} /* qcril_cm_callsvc_event_ext_display  */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_nss_clir

===========================================================================*/
/*!
    @brief
    Handles CM_CALL_EVENT_NSS_CLIR_REC.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_nss_clir
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr; 
  RIL_CDMA_InformationRecord * info_rec_ptr;
  uint8 index;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  index = i_ptr->cdma_info_recs.recs.numberOfInfoRecs;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].cdma_info_rec_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Buffer the info rec so it can be processed once all the information
     records have been received. */

  if ( i_ptr->cdma_info_recs.recs.numberOfInfoRecs == RIL_CDMA_MAX_NUMBER_OF_INFO_RECS )
  {
    QCRIL_LOG_ERROR( "%s", "Size of info rec array has been exceeded.\n" );
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  i_ptr->cdma_info_recs.call_id = call_info_ptr->call_id;

  info_rec_ptr = &i_ptr->cdma_info_recs.recs.infoRec[index];

  info_rec_ptr->name = RIL_CDMA_T53_CLIR_INFO_REC;
  info_rec_ptr->rec.clir.cause = 
  call_info_ptr->mode_info.info.cdma_call.nss_clir_rec.cause;

  i_ptr->cdma_info_recs.recs.numberOfInfoRecs++;

  QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Received the last info record.  Process them now. */
  qcril_cm_process_cdma_info_recs( instance_id, modem_id );

} /* qcril_cm_callsvc_event_nss_clir */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_nss_rel

===========================================================================*/
/*!
    @brief
    Handles CM_CALL_EVENT_NSS_REL_REC.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_nss_rel
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr; 
  RIL_CDMA_InformationRecord * info_rec_ptr;
  uint8 index;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  index = i_ptr->cdma_info_recs.recs.numberOfInfoRecs;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].cdma_info_rec_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Buffer the info rec so it can be processed once all the information
     records have been received. */

  if ( i_ptr->cdma_info_recs.recs.numberOfInfoRecs == RIL_CDMA_MAX_NUMBER_OF_INFO_RECS )
  {
    QCRIL_LOG_ERROR( "%s", "Size of info rec array has been exceeded.\n" );
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  i_ptr->cdma_info_recs.call_id = call_info_ptr->call_id;

  info_rec_ptr = &i_ptr->cdma_info_recs.recs.infoRec[index];

  info_rec_ptr->name = RIL_CDMA_T53_RELEASE_INFO_REC;

  i_ptr->cdma_info_recs.recs.numberOfInfoRecs++;

  QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Received the last info record.  Process them now. */
  qcril_cm_process_cdma_info_recs( instance_id, modem_id );

} /* qcril_cm_callsvc_event_nss_rel */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_nss_aud_ctrl

===========================================================================*/
/*!
    @brief
    Handles CM_CALL_EVENT_NSS_AUD_CTRL.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_nss_aud_ctrl
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr; 
  RIL_CDMA_InformationRecord * info_rec_ptr;
  uint8 index;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  index = i_ptr->cdma_info_recs.recs.numberOfInfoRecs;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].cdma_info_rec_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Buffer the info rec so it can be processed once all the information
     records have been received. */

  if ( i_ptr->cdma_info_recs.recs.numberOfInfoRecs == RIL_CDMA_MAX_NUMBER_OF_INFO_RECS )
  {
    QCRIL_LOG_ERROR( "%s", "Size of info rec array has been exceeded.\n" );
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  i_ptr->cdma_info_recs.call_id = call_info_ptr->call_id;

  info_rec_ptr = &i_ptr->cdma_info_recs.recs.infoRec[index];

  info_rec_ptr->name = RIL_CDMA_T53_AUDIO_CONTROL_INFO_REC;
  info_rec_ptr->rec.audioCtrl.upLink =
  call_info_ptr->mode_info.info.cdma_call.nss_aud_ctrl_rec.up_link;
  info_rec_ptr->rec.audioCtrl.downLink =
  call_info_ptr->mode_info.info.cdma_call.nss_aud_ctrl_rec.down_link;

  i_ptr->cdma_info_recs.recs.numberOfInfoRecs++;

  QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Received the last info record.  Process them now. */
  qcril_cm_process_cdma_info_recs( instance_id, modem_id );

} /* qcril_cm_callsvc_event_nss_aud_ctrl */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_redirecting_number

===========================================================================*/
/*!
    @brief
    Handles CM_CALL_EVENT_REDIRECTING_NUMBER.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_redirecting_number
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr; 
  RIL_CDMA_InformationRecord * info_rec_ptr;
  uint8 index;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  index = i_ptr->cdma_info_recs.recs.numberOfInfoRecs;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].cdma_info_rec_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Buffer the info rec so it can be processed once all the information
     records have been received. */

  if ( i_ptr->cdma_info_recs.recs.numberOfInfoRecs == RIL_CDMA_MAX_NUMBER_OF_INFO_RECS )
  {
    QCRIL_LOG_ERROR( "%s", "Size of info rec array has been exceeded.\n" );
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  i_ptr->cdma_info_recs.call_id = call_info_ptr->call_id;

  info_rec_ptr = &i_ptr->cdma_info_recs.recs.infoRec[index];

  info_rec_ptr->name = RIL_CDMA_REDIRECTING_NUMBER_INFO_REC;
  info_rec_ptr->rec.redir.redirectingNumber.len =
  call_info_ptr->redirecting_number.num.len;
  memcpy(info_rec_ptr->rec.redir.redirectingNumber.buf,
         call_info_ptr->redirecting_number.num.buf,
         call_info_ptr->redirecting_number.num.len);
  info_rec_ptr->rec.redir.redirectingNumber.number_type =
  call_info_ptr->redirecting_number.num.number_type;
  info_rec_ptr->rec.redir.redirectingNumber.number_plan =
  call_info_ptr->redirecting_number.num.number_plan;
  info_rec_ptr->rec.redir.redirectingNumber.pi =
  call_info_ptr->redirecting_number.num.pi;
  info_rec_ptr->rec.redir.redirectingNumber.si =
  call_info_ptr->redirecting_number.num.si;

  info_rec_ptr->rec.redir.redirectingReason = 
  call_info_ptr->redirecting_number.redirecting_reason;

  i_ptr->cdma_info_recs.recs.numberOfInfoRecs++;

  QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Received the last info record.  Process them now. */
  qcril_cm_process_cdma_info_recs( instance_id, modem_id );

} /* qcril_cm_callsvc_event_redirecting_number */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_line_ctrl

===========================================================================*/
/*!
    @brief
    Handles CM_CALL_EVENT_LINE_CTRL.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_line_ctrl
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  const cm_mm_call_info_s_type *call_info_ptr;
  RIL_CDMA_InformationRecord * info_rec_ptr;
  uint8 index;
  char details[ 40 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  index = i_ptr->cdma_info_recs.recs.numberOfInfoRecs;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].cdma_info_rec_mutex\n", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Buffer the info rec so it can be processed once all the information
     records have been received. */

  if ( i_ptr->cdma_info_recs.recs.numberOfInfoRecs == RIL_CDMA_MAX_NUMBER_OF_INFO_RECS )
  {
    QCRIL_LOG_ERROR( "%s", "Size of info rec array has been exceeded.\n" );
    QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );
    return;
  }

  i_ptr->cdma_info_recs.call_id = call_info_ptr->call_id;

  info_rec_ptr = &i_ptr->cdma_info_recs.recs.infoRec[index];

  info_rec_ptr->name = RIL_CDMA_LINE_CONTROL_INFO_REC;
  info_rec_ptr->rec.lineCtrl.lineCtrlPolarityIncluded =
  call_info_ptr->mode_info.info.cdma_call.line_ctrl_polarity_included;
  info_rec_ptr->rec.lineCtrl.lineCtrlToggle =
  call_info_ptr->mode_info.info.cdma_call.line_ctrl_toggle;
  info_rec_ptr->rec.lineCtrl.lineCtrlReverse =
  call_info_ptr->mode_info.info.cdma_call.line_ctrl_reverse;
  info_rec_ptr->rec.lineCtrl.lineCtrlPowerDenial =
  call_info_ptr->mode_info.info.cdma_call.line_ctrl_power_denial;

  i_ptr->cdma_info_recs.recs.numberOfInfoRecs++;

  QCRIL_MUTEX_UNLOCK( &i_ptr->cdma_info_rec_mutex, details );

  /* Received the last info record.  Process them now. */
  qcril_cm_process_cdma_info_recs( instance_id, modem_id );

} /* qcril_cm_callsvc_event_line_ctrl */


/*===========================================================================

  FUNCTION:  qcril_cm_inbandsvc_request_dtmf

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_DTMF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inbandsvc_request_dtmf
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  qcril_cm_clist_call_ids_list_type call_ids_list;
  char * in_data_ptr;
  char details[ 80 ];
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (char *)params_ptr->data;
  QCRIL_ASSERT( in_data_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  if ( params_ptr->datalen == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Assuming CM will do DTMF digit range check */

  /* Check whether there is any active voice call */
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, QCRIL_CM_CLIST_STATE_ACTIVE, &call_ids_list );
  if ( call_ids_list.num_of_call_ids == 0 )
  {
    QCRIL_LOG_ERROR( "%s", "No active voice call, DTMF not allowed\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Lookup the modem that has the voice call setup */
  modem_id = call_ids_list.modem_id[ 0 ];

  /* Add entry to ReqList */
  /* For GW system, we sent start_cont_dtmf followed by stop_cont_dtmf to simulate burst_dtmf */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_INBAND_REV_START_CONT_DTMF_CONF, NULL, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = call_ids_list.call_id[ 0 ];
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  /* Request service on the modem that has voice call up */
  modem_id = call_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Command CM to start continuous DTMF */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, call id %d, dtmf_digit %c", 
                  qcril_log_get_token_id( params_ptr->t ), call_ids_list.call_id[ 0 ], in_data_ptr[ 0 ] );
  QCRIL_LOG_RPC2( modem_id, "cm_mm_inband_cmd_start_cont_dtmf()", details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_inband_cmd_start_cont_dtmf_func( qcril_cm_inband_command_callback,
                                                                              (void *) user_data,
                                                                              i_ptr->client_info[ modem_id ].client_id,
                                                                              call_ids_list.call_id[ 0 ],
                                                                              in_data_ptr[ 0 ] ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_inbandsvc_request_dtmf() */


/*===========================================================================

  FUNCTION:  qcril_cm_inbandsvc_request_dtmf_start

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_DTMF_START.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inbandsvc_request_dtmf_start
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{ 
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  qcril_cm_clist_call_ids_list_type call_ids_list;
  char *in_data_ptr;
  char details[ 80 ];
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  qcril_evt_e_type pending_event;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (char *)params_ptr->data;
  QCRIL_ASSERT( in_data_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  if ( params_ptr->datalen == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Check whether there is active or alerting voice call */
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, QCRIL_CM_CLIST_STATE_ACTIVE|QCRIL_CM_CLIST_STATE_ALERTING, 
                                                     &call_ids_list );
  if ( call_ids_list.num_of_call_ids == 0 )
  {
    QCRIL_LOG_ERROR( "%s", "No active voice call, DTMF START not allowed\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Lookup the modem that has the voice call setup */
  modem_id = call_ids_list.modem_id[ 0 ];

  if ( QCRIL_CM_SRV_STATUS_INDICATES_1XEVDO_SRV_AVAILABLE( i_ptr->ss_info[modem_id].srv_status, i_ptr->ss_info[modem_id].sys_mode,
                                                           i_ptr->ss_info[modem_id].hdr_hybrid, i_ptr->ss_info[modem_id].hdr_srv_status ))
  {
    pending_event = QCRIL_EVT_CM_INBAND_REV_START_CONT_DTMF;
  }
  else if ( QCRIL_CM_SRV_STATUS_INDICATES_GW_SRV_AVAILABLE( i_ptr->ss_info[modem_id].srv_status, i_ptr->ss_info[modem_id].sys_mode ) )
  {
    pending_event  = QCRIL_EVT_CM_INBAND_REV_START_CONT_DTMF_CONF;
  }

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                pending_event, NULL, &reqlist_entry );
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = call_ids_list.call_id[ 0 ];
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  /* Request service on the modem that has voice call up */
  modem_id = call_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Command CM to start continuous DTMF */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, call id %d, dtmf_digit %c", 
                  qcril_log_get_token_id( params_ptr->t ), call_ids_list.call_id[ 0 ], in_data_ptr[ 0 ] );
  QCRIL_LOG_RPC2( modem_id, "cm_mm_inband_cmd_start_cont_dtmf()", details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_inband_cmd_start_cont_dtmf_func( qcril_cm_inband_command_callback,
                                                                              (void *) user_data,
                                                                              i_ptr->client_info[ modem_id ].client_id,
                                                                              call_ids_list.call_id[ 0 ],
                                                                              in_data_ptr[ 0 ] ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_inbandsvc_request_dtmf_start() */


/*===========================================================================

  FUNCTION:  qcril_cm_inbandsvc_request_dtmf_stop

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_DTMF_STOP.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inbandsvc_request_dtmf_stop
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  qcril_cm_clist_call_ids_list_type call_ids_list;
  uint32 user_data;
  char details[ 80 ];
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  qcril_evt_e_type pending_event;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Check whether there is active or alerting voice call */
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, QCRIL_CM_CLIST_STATE_ACTIVE|QCRIL_CM_CLIST_STATE_ALERTING, 
                                                     &call_ids_list );
  if ( call_ids_list.num_of_call_ids == 0 )
  {
    QCRIL_LOG_ERROR( "%s", "No active voice call, DTMF STOP not allowed\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Lookup the modem that has the voice call setup */
  modem_id = call_ids_list.modem_id[ 0 ];

  if ( QCRIL_CM_SRV_STATUS_INDICATES_1XEVDO_SRV_AVAILABLE( i_ptr->ss_info[modem_id].srv_status, i_ptr->ss_info[modem_id].sys_mode,
                                                           i_ptr->ss_info[modem_id].hdr_hybrid, i_ptr->ss_info[modem_id].hdr_srv_status ))
  {
    pending_event = QCRIL_EVT_CM_INBAND_REV_STOP_CONT_DTMF;
  }
  else if ( QCRIL_CM_SRV_STATUS_INDICATES_GW_SRV_AVAILABLE( i_ptr->ss_info[modem_id].srv_status, i_ptr->ss_info[modem_id].sys_mode ) )
  {
    pending_event  = QCRIL_EVT_CM_INBAND_REV_STOP_CONT_DTMF_CONF;
  }

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               pending_event, NULL, &reqlist_entry );
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = call_ids_list.call_id[ 0 ];
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  /* Request service on the modem that has voice call up */
  modem_id = call_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Command CM to stop continuous DTMF */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, call id %d, duration 0", 
                  qcril_log_get_token_id( params_ptr->t ), call_ids_list.call_id[ 0 ] );
  QCRIL_LOG_RPC2( modem_id, "cm_mm_inband_cmd_stop_cont_dtmf()", details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_inband_cmd_stop_cont_dtmf_func( qcril_cm_inband_command_callback,
                                                                             (void *) user_data,
                                                                             i_ptr->client_info[ modem_id ].client_id,
                                                                             call_ids_list.call_id[ 0 ],
                                                                             0 ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_inbandsvc_request_dtmf_stop() */
                                      

/*===========================================================================

  FUNCTION:  qcril_cm_inbandsvc_request_cdma_burst_dtmf

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CDMA_BURST_DTMF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inbandsvc_request_cdma_burst_dtmf
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  char *dtmf_ptr;
  char *onlength_ptr = NULL;
  char *offlength_ptr = NULL;
  uint8 on_length = 1; /* DTMF pulse width, 150ms */
  uint8 off_length = 2; /* DTMF inter-digit interval, 150ms */
  qcril_cm_clist_call_ids_list_type call_ids_list;
  char details[200];
  long ret_val;
  char *end_ptr;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  dtmf_ptr =  ((char **)params_ptr->data)[ 0 ];
  QCRIL_ASSERT( dtmf_ptr != NULL );
  onlength_ptr = ((char **)params_ptr->data)[ 1 ];
  QCRIL_ASSERT( onlength_ptr != NULL );
  offlength_ptr = ((char **)params_ptr->data)[ 2 ];
  QCRIL_ASSERT( offlength_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Verify the parameters are valid */
  if ( params_ptr->datalen == 0 )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Check if there is active voice call */
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, QCRIL_CM_CLIST_STATE_ACTIVE, &call_ids_list );
  if ( call_ids_list.num_of_call_ids == 0 )
  {
    QCRIL_LOG_ERROR( "%s", "No active voice call, BURST DTMF not allowed\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Convert DTMF ON length string to DTMF ON duration */
  ret_val = strtol( onlength_ptr, &end_ptr, 0 );
  if ( ( errno == ERANGE ) && ( ( ret_val == LONG_MAX ) || ( ret_val == LONG_MIN ) ) )
  {
    QCRIL_LOG_ERROR( "Fail to convert DTMF ON length str = %s, default to: QCRIL_CM_DTMF_ON_150(150msecs) \n", onlength_ptr );
  }

  switch ( ret_val )
  {
    case 95 :
      on_length = QCRIL_CM_DTMF_ON_95;
      break;

    /* As per the Ril interface - 0 maps to default value */
    case 0   :
    case 150 :
      on_length = QCRIL_CM_DTMF_ON_150;
      break;

    case 200 :
      on_length = QCRIL_CM_DTMF_ON_200;
      break;

    case 250 :
      on_length = QCRIL_CM_DTMF_ON_250;
      break;

    case 300 :
      on_length = QCRIL_CM_DTMF_ON_300;
      break;

    case 350 :
      on_length = QCRIL_CM_DTMF_ON_350;
      break;

    default :
      on_length = QCRIL_CM_DTMF_ON_SMS;
      break;
  }
  QCRIL_LOG_DEBUG( "DTMF ON length ret_val = %d, on_length_val = %d \n", onlength_ptr , on_length );

  /* Convert DTMF OFF length string to DTMF OFF duration */
  ret_val = strtol( offlength_ptr, &end_ptr, 0 );
  if ( ( errno == ERANGE ) && ( ( ret_val == LONG_MAX ) || ( ret_val == LONG_MIN ) ) )
  {
    QCRIL_LOG_ERROR( "Fail to convert DTMF OFF length %s, default to: QCRIL_CM_DTMF_OFF_150 (150msecs)\n", offlength_ptr );
  }

  switch ( ret_val )
  {
    case 60 :
      off_length = QCRIL_CM_DTMF_OFF_60;
      break;

    case 100 :
      off_length = QCRIL_CM_DTMF_OFF_100;
      break;

    case 150 :
      off_length = QCRIL_CM_DTMF_OFF_150;
      break;

    case 200 :
      off_length = QCRIL_CM_DTMF_OFF_200;
      break;

    default :
      off_length = QCRIL_CM_DTMF_OFF_150;
      break;
  }
  QCRIL_LOG_DEBUG( "DTMF OFF length ret_val = %d, Off_length_val = %d \n", offlength_ptr , off_length );

  /* Lookup the modem that has the voice call setup */
  modem_id = call_ids_list.modem_id[ 0 ];
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                QCRIL_EVT_CM_INBAND_REV_BURST_DTMF, NULL, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = call_ids_list.call_id[ 0 ];
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  /* Request service on the modem that has voice call up */
  modem_id = call_ids_list.modem_id[ 0 ];

  /* Command CM to send burst DTMF */
  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, call id %d, dtmf string %s, on length %d, off length %d", 
                  qcril_log_get_token_id( params_ptr->t ), call_ids_list.call_id[ 0 ], dtmf_ptr, on_length, off_length );
  QCRIL_LOG_RPC2( modem_id, "cm_mm_inband_cmd_burst_dtmf()", details );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_inband_cmd_burst_dtmf_func( qcril_cm_inband_command_callback,
                                                                         (void *) user_data,
                                                                         i_ptr->client_info[ modem_id ].client_id,
                                                                         call_ids_list.call_id[ 0 ],
                                                                         on_length, off_length,
                                                                         strlen( dtmf_ptr ),
                                                                         (uint8 *) dtmf_ptr ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_inbandsvc_request_cdma_burst_dtmf() */

/*=========================================================================
  FUNCTION:  qcril_cm_inbandsvc_event_rev_start_cont_dtmf_conf

===========================================================================*/
/*!
    @brief
    Handle CM_INBAND_EVENT_REV_START_CONT_DTMF_CONF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inbandsvc_event_rev_start_cont_dtmf_conf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  cm_inband_info_s_type *inband_info_ptr;
  qcril_reqlist_public_type req_info;
  qcril_cm_clist_call_ids_list_type call_ids_list;
  char details[ 80 ];
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  inband_info_ptr = ( cm_inband_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( inband_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* See if there is any RIL request pending for the event */
  if ( ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, params_ptr->event_id, inband_info_ptr->call_id, 
                                                  &req_info ) == E_SUCCESS ) ) 
  {
    switch ( req_info.request )
    {
      case RIL_REQUEST_DTMF:
        /* Check whether there is active voice call */
        qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, QCRIL_CM_CLIST_STATE_ACTIVE, &call_ids_list );

        /* No active voice call, continuous DTMF automatically stopped */
        if ( call_ids_list.num_of_call_ids == 0 )
        {
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
          qcril_send_request_response( &resp );
        }
        /* For GW system, we sent start_cont_dtmf followed by stop_cont_dtmf to simulate burst_dtmf */
        /* Update state, sub ID and pending event ID of ReqList item */
        else if ( inband_info_ptr->success )
        {
           if ( ( qcril_reqlist_update_pending_event_id( instance_id, modem_id, req_info.t,
                                                         QCRIL_EVT_CM_INBAND_REV_STOP_CONT_DTMF_CONF ) == E_SUCCESS ) &&
                     ( qcril_reqlist_update_state( instance_id, modem_id, req_info.t, QCRIL_REQ_AWAITING_CALLBACK ) == E_SUCCESS ) &&
                     ( qcril_reqlist_update_sub_id( instance_id, req_info.t, call_ids_list.call_id[ 0 ] ) == E_SUCCESS ) )
           {
             QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, call id %d, duration 0",
                             qcril_log_get_token_id( params_ptr->t ), inband_info_ptr->call_id );
             QCRIL_LOG_RPC2( modem_id, "cm_mm_inband_cmd_stop_cont_dtmf()", details );
             user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, req_info.req_id );
             if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_inband_cmd_stop_cont_dtmf_func( qcril_cm_inband_command_callback,
                                                                                        (void *) user_data,
                                                                                        i_ptr->client_info[ modem_id ].client_id,
                                                                                        call_ids_list.call_id[ 0 ],
                                                                                        0 ) )
             {
               /* In case of ARM9 reset, the command callback will never be executed. So, need to
                  delete the entry from the ReqList, and call OnRequestComplete() */
               qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
               qcril_send_request_response( &resp );
             }
           }
           else
           {
             QCRIL_LOG_ERROR( "Fail to update ReqList item, %s(%d)\n", qcril_log_lookup_event_name( req_info.request ),
                              req_info.request );
             qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
             qcril_send_request_response( &resp );
           }
        }
        else
        {
          qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
        }

        break;

      case RIL_REQUEST_DTMF_START:
        if ( inband_info_ptr->success )
        {
           qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
           qcril_send_request_response( &resp );
        }
        else
        {
            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
            qcril_send_request_response( &resp );

          /* Should remove any pending RIL_REQUEST_DTMF_STOP here*/
          if ( qcril_reqlist_query_by_event_all_states( instance_id, modem_id, QCRIL_EVT_CM_INBAND_REV_STOP_CONT_DTMF_CONF, &req_info ) == E_SUCCESS )
          {
            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
            qcril_send_request_response( &resp );
          }
        }
        break;

      default:
        QCRIL_LOG_ERROR( "Unhandled CM_INBAND_EVENT_REV_START_CONT_DTMF_CONF for %s (%d)\n", 
                         qcril_log_lookup_event_name( req_info.request ), req_info.request ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        break;
    }
  }

} /* qcril_cm_inbandsvc_event_rev_start_cont_dtmf_conf */

/*=========================================================================
  FUNCTION:  qcril_cm_inbandsvc_event_rev_start_cont_dtmf

===========================================================================*/
/*!
    @brief
    Handle CM_INBAND_EVENT_REV_START_CONT_DTMF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inbandsvc_event_rev_start_cont_dtmf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  cm_inband_info_s_type *inband_info_ptr;
  qcril_reqlist_public_type req_info;
  qcril_cm_clist_call_ids_list_type call_ids_list;
  char details[ 80 ];
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  inband_info_ptr = ( cm_inband_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( inband_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* See if there is any RIL request pending for the event */
  if ( ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, params_ptr->event_id, inband_info_ptr->call_id,
                                                  &req_info ) == E_SUCCESS ) )
  {
    switch ( req_info.request )
    {
      case RIL_REQUEST_DTMF_START:
        if ( inband_info_ptr->success )
        {
           qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
           qcril_send_request_response( &resp );
        }
        else
        {
            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
            qcril_send_request_response( &resp );

          /* Should remove any pending RIL_REQUEST_DTMF_STOP here*/
          if ( qcril_reqlist_query_by_event_all_states( instance_id, modem_id, QCRIL_EVT_CM_INBAND_REV_STOP_CONT_DTMF, &req_info ) == E_SUCCESS )
          {
            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
            qcril_send_request_response( &resp );
          }
        }
        break;

      default:
        QCRIL_LOG_ERROR( "Unhandled CM_INBAND_EVENT_REV_START_CONT_DTMF for %s (%d)\n",
                         qcril_log_lookup_event_name( req_info.request ), req_info.request );
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        break;
    }
  }

} /* qcril_cm_inbandsvc_event_rev_start_cont_dtmf */


/*=========================================================================
  FUNCTION:  qcril_cm_inbandsvc_event_rev_stop_cont_dtmf

===========================================================================*/
/*!
    @brief
    Handle CM_INBAND_EVENT_REV_STOP_CONT_DTMF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inbandsvc_event_rev_stop_cont_dtmf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_inband_info_s_type *inband_info_ptr;
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  inband_info_ptr = ( cm_inband_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( inband_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* See if there is any RIL request pending for the event */
  if ( ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, params_ptr->event_id, inband_info_ptr->call_id,
                                                  &req_info ) == E_SUCCESS ) )
  {
    switch ( req_info.request )
    {
      case RIL_REQUEST_DTMF_STOP:
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        qcril_send_request_response( &resp );
        break;

      default:
        QCRIL_LOG_ERROR( "Unhandled CM_INBAND_EVENT_REV_STOP_CONT_DTMF for %s (%d)\n",
                         qcril_log_lookup_event_name( req_info.request ), req_info.request );
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        break;
    }
  }

} /* qcril_cm_inbandsvc_event_rev_stop_cont_dtmf */

/*=========================================================================
  FUNCTION:  qcril_cm_inbandsvc_event_rev_stop_cont_dtmf_conf

===========================================================================*/
/*!
    @brief
    Handle CM_INBAND_EVENT_REV_STOP_CONT_DTMF_CONF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inbandsvc_event_rev_stop_cont_dtmf_conf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_inband_info_s_type *inband_info_ptr;
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  inband_info_ptr = ( cm_inband_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( inband_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* See if there is any RIL request pending for the event */
  if ( ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, params_ptr->event_id, inband_info_ptr->call_id, 
                                                  &req_info ) == E_SUCCESS ) ) 
  {
    switch ( req_info.request )
    {
      case RIL_REQUEST_DTMF:
        /* For GW system, we sent start_cont_dtmf followed by stop_cont_dtmf to simulate burst_dtmf */
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        qcril_send_request_response( &resp );
        break;

      case RIL_REQUEST_DTMF_STOP:
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        qcril_send_request_response( &resp );
        break;

      default:
        QCRIL_LOG_ERROR( "Unhandled CM_INBAND_EVENT_REV_STOP_CONT_DTMF_CONF for %s (%d)\n", 
                         qcril_log_lookup_event_name( req_info.request ), req_info.request ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        break;
    }
  }

} /* qcril_cm_inbandsvc_event_rev_stop_cont_dtmf_conf */


/*=========================================================================
  FUNCTION:  qcril_cm_inbandsvc_event_rev_burst_dtmf

===========================================================================*/
/*!
    @brief
    handle CM_INBAND_EVENT_REV_BURST_DTMF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inbandsvc_event_rev_burst_dtmf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{ 
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_inband_info_s_type *inband_info_ptr;
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  inband_info_ptr = ( cm_inband_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( inband_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* See if there is any RIL request pending for the event */
  if ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, params_ptr->event_id, inband_info_ptr->call_id, 
                                                &req_info ) == E_SUCCESS ) 
  {
    switch ( req_info.request )
    {
      case RIL_REQUEST_CDMA_BURST_DTMF:
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
        qcril_send_request_response( &resp );
        break;

      default:
        QCRIL_LOG_ERROR( "Unhandled CM_INBAND_EVENT_REV_BURST_DTMF for %s (%d)\n", 
                         qcril_log_lookup_event_name( req_info.request ), req_info.request ); 
        qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        break;
    } /* end switch */
  }

} /* qcril_cm_inbandsvc_event_rev_burst_dtmf */


/*=========================================================================
  FUNCTION:  qcril_cm_inbandsvc_event_fwd_start_cont_dtmf

===========================================================================*/
/*!
    @brief
    Handle CM_INBAND_EVENT_FWD_START_CONT_DTMF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inbandsvc_event_fwd_start_cont_dtmf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  cm_inband_info_s_type *inband_info_ptr;
  char dtmf_digit;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  inband_info_ptr = ( cm_inband_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( inband_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "%s", "Received :CM_INBAND_EVENT_FWD_START_CONT_DTMF \n" );
  dtmf_digit =  inband_info_ptr->digits[0] ;
  QCRIL_LOG_DEBUG( "Recieved :dtmf char = %c\n", dtmf_digit);
  qcril_hook_unsol_response( instance_id, QCRIL_EVT_HOOK_UNSOL_CDMA_CONT_DTMF_START, &dtmf_digit, sizeof( dtmf_digit ) );

} /* qcril_cm_inbandsvc_event_fwd_start_cont_dtmf */


/*=========================================================================
  FUNCTION:  qcril_cm_inbandsvc_event_fwd_stop_cont_dtmf

===========================================================================*/
/*!
    @brief
    Handle CM_INBAND_EVENT_FWD_STOP_CONT_DTMF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inbandsvc_event_fwd_stop_cont_dtmf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  cm_inband_info_s_type *inband_info_ptr;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  inband_info_ptr = ( cm_inband_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( inband_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "%s", "Recieved :CM_INBAND_EVENT_FWD_STOP_CONT_DTMF \n" );

  qcril_hook_unsol_response( instance_id, QCRIL_EVT_HOOK_UNSOL_CDMA_CONT_DTMF_STOP, NULL, 0 );

} /* qcril_cm_inbandsvc_event_fwd_stop_cont_dtmf */


/*=========================================================================
  FUNCTION:  qcril_cm_inbandsvc_event_fwd_burst_dtmf

===========================================================================*/
/*!
    @brief
    handle CM_INBAND_EVENT_FWD_BURST_DTMF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_inbandsvc_event_fwd_burst_dtmf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  cm_inband_info_s_type *inband_info_ptr;
  char dtmf_payload[ QCRIL_CM_OEM_DTMF_FWD_BURST_PAYLOAD_LENGTH ];
  char on_len[ 4 ],off_len[ 4 ];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  inband_info_ptr = ( cm_inband_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( inband_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "%s", "Recieved :CM_INBAND_EVENT_FWD_BURST_DTMF \n" );
  memset( on_len, 0, sizeof( on_len ) );
  memset( off_len, 0, sizeof( off_len ) );
  memset( dtmf_payload, 0, sizeof( dtmf_payload ) );

  switch ( inband_info_ptr->on_length )
  {
    case 0 :
      strcpy( on_len, "95" );
      break;

    case 1 :
      strcpy( on_len, "150" );
      break;

    case 2 :
      strcpy( on_len, "200" );
      break;

    case 3 :
      strcpy( on_len, "250" );
      break;

    case 4 :
      strcpy( on_len, "300" );
      break;

    case 5 :
      strcpy( on_len, "350" );
      break;

    default :
      strcpy( on_len, "150" );
      break;
  }
  QCRIL_LOG_DEBUG( "DTMF : ON length received = %d, onlength str = %s \n", inband_info_ptr->on_length , on_len );

  switch ( inband_info_ptr->off_length )
  {
    case 0 :
      strcpy( off_len, "60" );
      break;

    case 1 :
      strcpy( off_len, "100" );
      break;

    case 2 :
      strcpy( off_len, "150" );
      break;

    case 3 :
      strcpy( off_len, "200" );
      break;

    default :
      strcpy( off_len, "150" );
      break;
  }

  QCRIL_LOG_DEBUG( "DTMF : OFF length recieved = %d, offlength str = %s \n", inband_info_ptr->off_length, off_len );

  memcpy(dtmf_payload, on_len, sizeof(on_len));
  memcpy(dtmf_payload + sizeof(on_len), off_len, sizeof(off_len));
  memcpy(dtmf_payload + sizeof(on_len) + sizeof(off_len), (void *)inband_info_ptr->digits , inband_info_ptr->cnt);

  qcril_hook_unsol_response( instance_id, QCRIL_EVT_HOOK_UNSOL_CDMA_BURST_DTMF, (char *)dtmf_payload, sizeof(dtmf_payload));

} /* qcril_cm_inbandsvc_event_fwd_burst_dtmf */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_udub

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_UDUB.
    Send UDUB (user determined used busy) to ringing or waiting call.
    using supplimentary services request to take care of both single and
    multiple calls scenarios.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_udub
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  qcril_cm_clist_call_ids_list_type call_ids_list_incoming;
  qcril_cm_clist_call_ids_list_type call_ids_list_waiting;
  cm_call_sups_params_s_type sups_params;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_cmd_sups_per_subs()";
  #else
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_cmd_sups()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  memset( &sups_params, 0, sizeof( sups_params ) );

  /* Lookup Call ID for Waiting Call */
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (int) QCRIL_CM_CLIST_STATE_WAITING, &call_ids_list_waiting );
  /* No Waiting Call ID is found */
  if ( call_ids_list_waiting.num_of_call_ids == 0 )
  {
    /* Lookup Call ID for Hold Call */
    qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (int) QCRIL_CM_CLIST_STATE_INCOMING, &call_ids_list_incoming );
    /* No Hold Call ID is found */
    if ( call_ids_list_incoming.num_of_call_ids == 0 )
    {
      QCRIL_LOG_DEBUG( "%s", "Rejecting RIL_REQUEST_UDUB request as there are no waiting and incoming calls\n");
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
      return;
    }
    else
    {
      sups_params.call_id = call_ids_list_incoming.call_id[ 0 ];
      /* Request service on the modem that has voice call up */
      modem_id = call_ids_list_incoming.modem_id[ 0 ];
    }
  }
  else
  {
    sups_params.call_id = call_ids_list_waiting.call_id[ 0 ];
    /* Request service on the modem that has voice call up */
    modem_id = call_ids_list_waiting.modem_id[ 0 ];
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

    /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_CALL_MNG_CALLS_CONF, NULL, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = sups_params.call_id;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_LOG_RPC( modem_id, cm_mm_call_cmd_sups_api_name, "CM_CALL_SUPS_TYPE_HELD_CALL_REL_OR_UDUB CallId", sups_params.call_id );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_sups_func( qcril_cm_callsvc_command_callback,
                                                                 (void *) user_data,
                                                                 i_ptr->client_info[ modem_id ].client_id,
                                                                 CM_CALL_SUPS_TYPE_HELD_CALL_REL_OR_UDUB,
                                                                 &sups_params 
                                                                 #ifdef FEATURE_QCRIL_DSDS
                                                                 , as_id
                                                                 #endif /* FEATURE_QCRIL_DSDS */
                                                               ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_udub() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_conference

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CONFERENCE.
    Used to start a conference call by combining the active and held calls or
    add another user to the existing conference call

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_conference
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  qcril_cm_clist_call_ids_list_type call_ids_list_active;
  qcril_cm_clist_call_ids_list_type call_ids_list_hold;
  cm_call_sups_params_s_type sups_params;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_sups_per_subs()";
  #else
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_sups()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  memset( &sups_params, 0, sizeof( sups_params ) );

  /* Lookup Call ID */
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_ACTIVE, &call_ids_list_active );
  /* No Call ID is found */
  if ( call_ids_list_active.num_of_call_ids == 0 )
  {
    /* Lookup Call ID */
    qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_HOLDING, &call_ids_list_hold );
    if ( call_ids_list_hold.num_of_call_ids == 0 )
    {
      QCRIL_LOG_DEBUG( "%s", "Rejecting RIL_REQUEST_CONFERENCE request as there are no active and held calls \n");
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
      return;
    }
    else
    {
      sups_params.call_id = call_ids_list_hold.call_id[ 0 ];
      /* Request service on the modem that has voice call up */
      modem_id = call_ids_list_hold.modem_id[ 0 ];
    }
  }
  else
  {
    sups_params.call_id = call_ids_list_active.call_id[ 0 ];
    /* Request service on the modem that has voice call up */
    modem_id = call_ids_list_active.modem_id[ 0 ];
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

    /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_CALL_MNG_CALLS_CONF, NULL, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = sups_params.call_id;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_LOG_RPC( modem_id, cm_mm_call_cmd_sups_api_name, "CM_CALL_SUPS_TYPE_MULTIPARTY_CALL CallId", sups_params.call_id );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_sups_func( qcril_cm_callsvc_command_callback,
                                                                 (void *) user_data,
                                                                 i_ptr->client_info[ modem_id ].client_id,
                                                                 CM_CALL_SUPS_TYPE_MULTIPARTY_CALL,
                                                                 &sups_params 
                                                                 #ifdef FEATURE_QCRIL_DSDS
                                                                 , as_id
                                                                 #endif /* FEATURE_QCRIL_DSDS */
                                                               ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_conference() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_separate_connection

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SEPARATE_CONNECTION.
    Used to retrieve the call id specified as input, which is done by putting
    active call on hold if any and retrieving the held call
    or if the call id specified in input is part of multipary call split it
    into a separate call.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_separate_connection
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  cm_call_id_type *call_id;
  IxErrnoType err_no;
  qcril_cm_clist_public_type info;
  cm_call_sups_params_s_type sups_params;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_sups_per_subs()";
  #else
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_sups()";
  #endif /* FEATURE_QCRIL_DSDS */
  qcril_cm_clist_call_ids_list_type call_ids_list_active;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  call_id = (cm_call_id_type *) params_ptr->data;
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  memset( &sups_params, 0, sizeof( sups_params ) );

  /* Lookup Call ID */
  err_no = qcril_cm_clist_query_by_conn_index( instance_id, call_id[ 0 ], &info );
  if ( err_no != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "Fail to find the call id = %d in the list\n", call_id[ 0 ] );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_ACTIVE, &call_ids_list_active );

  /* If there is only one active call, return success,  separate connection has no importance since call is already active */
  if( ( call_ids_list_active.num_of_call_ids == 1 ) && ( info.state == QCRIL_CM_CLIST_STATE_ACTIVE ) )
  {
    QCRIL_LOG_DEBUG( "%s\n", "returning success as there is only one active call" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
     return;
  }

  if ( ( info.state == QCRIL_CM_CLIST_STATE_ACTIVE ) ||
       ( info.state == QCRIL_CM_CLIST_STATE_HOLDING ) ||
       ( info.state == QCRIL_CM_CLIST_STATE_INCOMING ) ||
       ( info.state == QCRIL_CM_CLIST_STATE_WAITING ) )
  {
    sups_params.call_id = info.call_id;
  }
  else
  {
    QCRIL_LOG_ERROR( "Rejecting RIL_REQUEST_SEPARATE_CONNECTION request as the call with id = %d is in invalid state = %d \n", 
                     call_id[ 0 ], info.state );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  /* Request service on the modem that has voice call up */
  modem_id = info.modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK,
                               QCRIL_EVT_CM_CALL_MNG_CALLS_CONF, NULL, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = sups_params.call_id;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

  QCRIL_LOG_RPC( modem_id, cm_mm_call_cmd_sups_api_name, "CM_CALL_SUPS_TYPE_SELECT_CALL_X CallId", sups_params.call_id );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_sups_func( qcril_cm_callsvc_command_callback,
                                                                 (void *) user_data,
                                                                 i_ptr->client_info[ modem_id ].client_id,
                                                                 CM_CALL_SUPS_TYPE_SELECT_CALL_X,
                                                                 &sups_params 
                                                                 #ifdef FEATURE_QCRIL_DSDS
                                                                 , as_id
                                                                 #endif /* FEATURE_QCRIL_DSDS */
                                                               ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_separate_connection() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_explicit_call_transfer

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_EXPLICIT_CALL_TRANSFER.
    Used to invoke the ECT supplimentary serivce, which will disconnect the
    active and held/waiting calls and allow them to connect to each other.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_explicit_call_transfer
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  qcril_cm_clist_call_ids_list_type call_ids_list_active;
  qcril_cm_clist_call_ids_list_type call_ids_list_alerting;
  cm_call_sups_params_s_type sups_params;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_sups_per_subs()";
  #else
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_sups()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  memset( &sups_params, 0, sizeof( sups_params ) );

  /* Lookup Call ID for Active Calls*/
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_ACTIVE, &call_ids_list_active );
  /* No Active Call ID is found */
  if ( call_ids_list_active.num_of_call_ids == 0 )
  {
    /* Lookup Call ID for Alering Call */
    qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_ALERTING, 
                                                       &call_ids_list_alerting );
    /* No Alerting Call ID is found */
    if ( call_ids_list_alerting.num_of_call_ids == 0 )
    {
      QCRIL_LOG_DEBUG( "%s", "Rejecting RIL_REQUEST_EXPLICIT_CALL_TRANSFER request as there are no active and alerting calls\n");
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
      return;
    }
    else
    {
      sups_params.call_id = call_ids_list_alerting.call_id[ 0 ];
      /* Request service on the modem that has voice call up */
      modem_id = call_ids_list_alerting.modem_id[ 0 ];
    }
  }
  else
  {
    sups_params.call_id = call_ids_list_active.call_id[ 0 ];
    /* Request service on the modem that has voice call up */
    modem_id = call_ids_list_active.modem_id[ 0 ];
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

    /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_CALL_MNG_CALLS_CONF, NULL, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = sups_params.call_id;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

  QCRIL_LOG_RPC( modem_id, cm_mm_call_cmd_sups_api_name, "CM_CALL_SUPS_TYPE_EXPLICIT_CALL_TRANSFER CallId", sups_params.call_id );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_sups_func( qcril_cm_callsvc_command_callback,
                                                                 (void *) user_data,
                                                                 i_ptr->client_info[ modem_id ].client_id,
                                                                 CM_CALL_SUPS_TYPE_EXPLICIT_CALL_TRANSFER,
                                                                 &sups_params 
                                                                 #ifdef FEATURE_QCRIL_DSDS
                                                                 , as_id
                                                                 #endif /* FEATURE_QCRIL_DSDS */
                                                               ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_explicit_call_transfer() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_switch_waiting_or_holding_and_active

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE.
    Used to put the active calls on hold so that the waiting or the held call
    can be answered or retrieved
    and incase of single call to toggle between active and hold states

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_switch_waiting_or_holding_and_active
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  qcril_cm_clist_call_ids_list_type call_ids_list_active;
  qcril_cm_clist_call_ids_list_type call_ids_list_held;
  qcril_cm_clist_call_ids_list_type call_ids_list_waiting;
  qcril_cm_clist_call_ids_list_type call_ids_list_incoming;  
  cm_call_sups_params_s_type sups_params;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_sups_per_subs()";
  #else
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_sups()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  memset( &sups_params, 0, sizeof( sups_params ) );

  /* Lookup Call ID for Active Calls*/
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_ACTIVE, &call_ids_list_active );
  /* No Active Call ID is found */
  if ( call_ids_list_active.num_of_call_ids == 0 )
  {
    /* Lookup Call ID for Hold Call */
    qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_HOLDING, &call_ids_list_held );
    /* No Held Call ID is found */
    if ( call_ids_list_held.num_of_call_ids == 0 )
    {
      /* Lookup Call ID for Waiting Call */
      qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_WAITING, &call_ids_list_waiting );
        /* No Waiting Call ID is found */
      if ( call_ids_list_waiting.num_of_call_ids == 0 )
      {
        /* Lookup Call ID for Incoming Call */
        qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_INCOMING, 
                                                           &call_ids_list_incoming );
          /* No Incoming Call ID is found */
        if ( call_ids_list_incoming.num_of_call_ids == 0 )
        {
          QCRIL_LOG_DEBUG( "%s", "Rejecting RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE request as there are no active, hold and waiting calls\n");
          qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
          return;
        }
        else
        {
          sups_params.call_id = call_ids_list_incoming.call_id[ 0 ];        
          /* Request service on modem that has voice call up */
          modem_id = call_ids_list_incoming.modem_id[ 0 ];        
        }
      }
      else
      {
        sups_params.call_id = call_ids_list_waiting.call_id[ 0 ];
        /* Request service on modem that has voice call up */
        modem_id = call_ids_list_waiting.modem_id[ 0 ];        
      }
    }
    else
    {
     sups_params.call_id = call_ids_list_held.call_id[ 0 ];
     /* Request service on modem that has voice call up */
     modem_id = call_ids_list_held.modem_id[ 0 ];        
    }
  }
  else
  {
    sups_params.call_id = call_ids_list_active.call_id[ 0 ];
    /* Request service on modem that has voice call up */
    modem_id = call_ids_list_active.modem_id[ 0 ];        
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

    /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_CALL_MNG_CALLS_CONF, NULL, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = sups_params.call_id;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

  QCRIL_LOG_RPC( modem_id, cm_mm_call_cmd_sups_api_name, "CM_CALL_SUPS_TYPE_HOLD_CALL CallId", sups_params.call_id );
  if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_sups_func( qcril_cm_callsvc_command_callback,
                                                                 (void *) user_data,
                                                                 i_ptr->client_info[ modem_id ].client_id,
                                                                 CM_CALL_SUPS_TYPE_HOLD_CALL,
                                                                 &sups_params 
                                                                 #ifdef FEATURE_QCRIL_DSDS
                                                                 , as_id
                                                                 #endif /* FEATURE_QCRIL_DSDS */
                                                               ) )
  {
    /* In case of ARM9 reset, the command callback will never be executed. So, need to
       delete the entry from the ReqList, and call OnRequestComplete() */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_switch_waiting_or_holding_and_active() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_hangup_waiting_or_background

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND.
    Used to release all held calls or set UDUB to the waiting calls.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_hangup_waiting_or_background
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  qcril_cm_clist_call_ids_list_type call_ids_list_held;
  qcril_cm_clist_call_ids_list_type call_ids_list_waiting;
  qcril_cm_clist_call_ids_list_type call_ids_list_incoming;  
  cm_call_sups_params_s_type sups_params;
  cm_end_params_s_type end_params;
  qcril_evt_e_type pending_event_id;
  char details[ 80 ];
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_1;
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_sups_per_subs()";
  #else
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_sups()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  (void) qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id );
  #endif /* FEATURE_QCRIL_DSDS */

  memset( &sups_params, 0, sizeof( sups_params ) );

  /* Lookup Call ID for Waiting Call */
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_WAITING, &call_ids_list_waiting );

  /* No Waiting Call ID is found */
  if ( call_ids_list_waiting.num_of_call_ids == 0 )
  {
    /* Lookup Call ID for Incoming Call */
    qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_INCOMING, &call_ids_list_incoming );  
    if ( call_ids_list_incoming.num_of_call_ids == 0 )
    {
      /* Lookup Call ID for Hold Call */
      qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_HOLDING, &call_ids_list_held );
      /* No Hold Call ID is found */
      if ( call_ids_list_held.num_of_call_ids == 0 )
      {
        QCRIL_LOG_DEBUG( "%s", 
                         "Rejecting RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND request as there are no waiting and hold calls\n");
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, 
                                           RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        return;
      }
      else
      {
        sups_params.call_id = call_ids_list_held.call_id[ 0 ];
        modem_id = call_ids_list_held.modem_id[ 0 ];
        pending_event_id = QCRIL_EVT_CM_CALL_MNG_CALLS_CONF;
      }
    }
    else
    {
      sups_params.call_id = call_ids_list_incoming.call_id[ 0 ];
      modem_id = call_ids_list_incoming.modem_id[ 0 ];
      if ( call_ids_list_incoming.call_mode[ 0 ] == CM_CALL_MODE_INFO_CDMA )
      {
        pending_event_id = QCRIL_EVT_CM_CALL_END;
      }
      /* If MT call already answered, just end call without udub */
      else if ( call_ids_list_incoming.answered[ 0 ] )
      {
        pending_event_id = QCRIL_EVT_CM_CALL_END;
      }
      else
      {
        pending_event_id = QCRIL_EVT_CM_CALL_MNG_CALLS_CONF;
      }
    }
  }
  else
  {
    sups_params.call_id = call_ids_list_waiting.call_id[0];
    modem_id = call_ids_list_waiting.modem_id[ 0 ];
    /* If MT call already answered, just end call without udub */
    if ( call_ids_list_waiting.answered[ 0 ] )
    {
      pending_event_id = QCRIL_EVT_CM_CALL_END;
    }
    else
    {
      pending_event_id = QCRIL_EVT_CM_CALL_MNG_CALLS_CONF;
    }
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               pending_event_id, NULL, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = sups_params.call_id;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  if ( pending_event_id == QCRIL_EVT_CM_CALL_END )
  {
    /* Command CM to end the call */
    memset( &end_params, 0, sizeof( end_params ) );
    end_params.call_id = sups_params.call_id;
    end_params.info_type = CM_CALL_MODE_INFO_CDMA;

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
    QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, call id %d, mode info %d", 
                    qcril_log_get_token_id( params_ptr->t ), end_params.call_id, end_params.info_type );

    QCRIL_LOG_RPC2( modem_id, "cm_mm_call_cmd_end()", details );
    if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_end_func( qcril_cm_callsvc_command_callback, 
                                                                  (void *) user_data, 
                                                                  i_ptr->client_info[ modem_id ].client_id,
                                                                  1,
                                                                  &end_params ) )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  }  
  else 
  {
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

    QCRIL_LOG_RPC( modem_id, cm_mm_call_cmd_sups_api_name, "CM_CALL_SUPS_TYPE_HELD_CALL_REL_OR_UDUB CallId", 
                   sups_params.call_id );
    if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_sups_func( qcril_cm_callsvc_command_callback,
                                                                   (void *) user_data,
                                                                   i_ptr->client_info[ modem_id ].client_id,
                                                                   CM_CALL_SUPS_TYPE_HELD_CALL_REL_OR_UDUB,
                                                                   &sups_params 
                                                                   #ifdef FEATURE_QCRIL_DSDS
                                                                   , as_id
                                                                   #endif /* FEATURE_QCRIL_DSDS */
                                                                 ) )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  }

} /* qcril_cm_supsvc_request_hangup_waiting_or_background() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_hangup_foreground_resume_background

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND.
    Used to disconnect all the active calls so that the held or the waiting
    calls can be retrieved or answered

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_hangup_foreground_resume_background
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  uint32 user_data;
  qcril_cm_clist_call_ids_list_type call_ids_list_active;
  qcril_cm_clist_call_ids_list_type call_ids_list_held;
  qcril_cm_clist_call_ids_list_type call_ids_list_waiting;
  qcril_cm_clist_call_ids_list_type call_ids_list_incoming;  
  qcril_cm_clist_call_ids_list_type call_ids_list_all;  
  cm_call_mode_info_e_type call_mode;
  qcril_evt_e_type pending_event_id;
  cm_end_params_s_type end_params;
  cm_call_sups_params_s_type sups_params;
  char details[ 80 ];
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_1;
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_sups_per_subs()";
  #else
  char *cm_mm_call_cmd_sups_api_name = "cm_mm_call_sups()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  (void) qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id );
  #endif /* FEATURE_QCRIL_DSDS */

  memset( &sups_params, 0, sizeof( sups_params ) );

  /* Lookup Call ID for Active Calls*/
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_ACTIVE, &call_ids_list_active );
  /* No Active Call ID is found */
  if ( call_ids_list_active.num_of_call_ids == 0 )
  {
    /* Lookup Call ID for Hold Call */
    qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_HOLDING, &call_ids_list_held );
    /* No Hold Call ID is found */
    if ( call_ids_list_held.num_of_call_ids == 0 )
    {
      /* Lookup Call ID for Waiting Call */
      qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_WAITING, &call_ids_list_waiting );
        /* No Waiting Call ID is found */
      if ( call_ids_list_waiting.num_of_call_ids == 0 )
      {
        /* Lookup Call ID for Incoming Call */
        qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, (uint32) QCRIL_CM_CLIST_STATE_INCOMING, 
                                                           &call_ids_list_incoming);
          /* No Incoming Call ID is found */
        if ( call_ids_list_incoming.num_of_call_ids == 0 )
        {      
          QCRIL_LOG_DEBUG( "%s", 
                           "Rejecting RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE request as there are no active, hold waiting and incoming calls\n");
          qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
          return;
        }
        else
        {
          sups_params.call_id = call_ids_list_incoming.call_id[ 0 ];        
          modem_id = call_ids_list_incoming.modem_id[ 0 ];        
          call_mode = call_ids_list_incoming.call_mode[ 0 ];        
        }
      }
      else
      {
        sups_params.call_id = call_ids_list_waiting.call_id[ 0 ];
        modem_id = call_ids_list_waiting.modem_id[ 0 ];        
        call_mode = call_ids_list_waiting.call_mode[ 0 ];        
      }
    }
    else
    {
      sups_params.call_id = call_ids_list_held.call_id[ 0 ];
      modem_id = call_ids_list_held.modem_id[ 0 ];        
      call_mode = call_ids_list_held.call_mode[ 0 ];        
    }
  }
  else
  {
    sups_params.call_id = call_ids_list_active.call_id[ 0 ];
    modem_id = call_ids_list_active.modem_id[ 0 ];        
    call_mode = call_ids_list_active.call_mode[ 0 ];        
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  /* Figure out the CM API to be called */
  qcril_cm_clist_query_voice_call_ids_list_by_state( instance_id, 
                                                     (uint32) ( QCRIL_CM_CLIST_STATE_ACTIVE | QCRIL_CM_CLIST_STATE_HOLDING |
                                                     QCRIL_CM_CLIST_STATE_DIALING | QCRIL_CM_CLIST_STATE_ALERTING |
                                                     QCRIL_CM_CLIST_STATE_INCOMING | QCRIL_CM_CLIST_STATE_WAITING ),
                                                     &call_ids_list_all );

  /* If there is only one call which is active call, in this case we are supposed to end the call using cm_mm_call_cmd_end() 
     instead of cm_mm_call_cmd_sups()  hence queueing QCRIL_EVT_CM_CALL_END instead of QCRIL_EVT_CM_CALL_MNG_CALLS_CONF */
        
  QCRIL_LOG_DEBUG( "no of active calls = %lu & no of calls = %lu\n", 
                   call_ids_list_active.num_of_call_ids, call_ids_list_all.num_of_call_ids );    

  if ( ( call_ids_list_all.num_of_call_ids == 1 ) && ( call_ids_list_active.num_of_call_ids == 1 ) )
  {
    pending_event_id = QCRIL_EVT_CM_CALL_END; 
  }
  else
  {
    pending_event_id = QCRIL_EVT_CM_CALL_MNG_CALLS_CONF; 
  }

  /* Add entry to ReqList */
  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               pending_event_id, NULL, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = sups_params.call_id;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    return;
  }

  /* Command CM to end the call */
  memset( &end_params, 0, sizeof( end_params ) );
  end_params.call_id = sups_params.call_id;
  end_params.info_type = call_mode;

  if ( pending_event_id == QCRIL_EVT_CM_CALL_END )
  {
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
    QCRIL_SNPRINTF( details, sizeof( details ), "Token ID %d, call id %d, mode info %d", 
                    qcril_log_get_token_id( params_ptr->t ), end_params.call_id, end_params.info_type );
    QCRIL_LOG_RPC2( modem_id, "cm_mm_call_cmd_end()", details );
    if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_end_func( qcril_cm_callsvc_command_callback, 
                                                                  (void *) user_data, 
                                                                  i_ptr->client_info[ modem_id ].client_id,
                                                                  1,
                                                                  &end_params ) )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  }
  else 
  {
    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

    QCRIL_LOG_RPC( modem_id, cm_mm_call_cmd_sups_api_name, "CM_CALL_SUPS_TYPE_ACTIVE_CALL_REL CallId", sups_params.call_id );
    if ( !qcril_cm_api_funcs[ modem_id ].cm_mm_call_cmd_sups_func( qcril_cm_callsvc_command_callback,
                                                                   (void *) user_data,
                                                                   i_ptr->client_info[ modem_id ].client_id,
                                                                   CM_CALL_SUPS_TYPE_ACTIVE_CALL_REL,
                                                                   &sups_params
                                                                   #ifdef FEATURE_QCRIL_DSDS
                                                                   , as_id
                                                                   #endif /* FEATURE_QCRIL_DSDS */
                                                                  ) )
    {
      /* In case of ARM9 reset, the command callback will never be executed. So, need to
         delete the entry from the ReqList, and call OnRequestComplete() */
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  }

} /* qcril_cm_supsvc_request_hangup_foreground_resume_background() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_query_clip

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_QUERY_CLIP.
    Queries for the status of the calling line identity presentation
    supplimentary services present with the network(for MMI code *#30#).

    Input Paramerers:
    NULL

    Result:
    NULL ( after receiving the appropriate response from AMSS,
           returns the status of CLIP i.e whether it is active or not )
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_query_clip
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  uint32 user_data;
  qcril_reqlist_u_type u_info;
  qcril_cm_ss_type *req_info_ptr = &u_info.cm.info.ss_info;
  qcril_cm_ss_sups_req_parm_u_type ss_data;
  char ss_buf[QCRIL_CM_SS_MAX_SUPS_LENGTH];
  boolean cm_result;
  cm_num_s_type dialed_digits;
  qcril_cm_ss_sups_params_s_type ss_params;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_sups_cmd_interrogate_api_name = "cm_sups_cmd_interrogate_per_subs()";
  #else
  char *cm_sups_cmd_interrogate_api_name = "cm_sups_cmd_interrogate()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  req_info_ptr->ss_code = (int) qcril_cm_ss_clip;
  req_info_ptr->ss_ref = qcril_cm_ss_get_ss_ref();

  ss_data.interr.ss_code = req_info_ptr->ss_code;
  ss_data.interr.ss_ref = req_info_ptr->ss_ref;
  ss_data.interr.basic_service.present = FALSE;

  /* fill the sups params required for sups string construction */
  memset( &ss_params, 0, sizeof( ss_params ) );
  ss_params.mode = QCRIL_CM_SS_MODE_QUERY;
  ss_params.code = ss_data.interr.ss_code;

  /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
     check in future. The string should be sent to modem for any call control */
  if ( E_SUCCESS != qcril_cm_ss_build_sups_string( &ss_params, ss_buf, QCRIL_CM_SS_MAX_SUPS_LENGTH ) )
  {
    QCRIL_LOG_ERROR( "%s", "Sups string construction failed \n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_LOG_DEBUG( "Sups String constructed is %s\n", ss_buf );

  qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &dialed_digits, (byte *)ss_buf, (byte)strlen( ss_buf ), CM_DIGIT_MODE_8BIT_ASCII );

  #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN
  /* Below FDN check code leg can be removed once the modem call control feature is turned on */
  if ( !qcril_cm_fdn_check_is_passed( instance_id, modem_id, ss_buf, strlen( ss_buf ) ) )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_FDN_CHECK_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  #endif /* #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN*/

  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_SUPS_INTERROGATE_CONF, &u_info, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = req_info_ptr->ss_ref;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

  QCRIL_LOG_RPC( modem_id, cm_sups_cmd_interrogate_api_name, "CLIP ss_ref", req_info_ptr->ss_ref );
  cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_interrogate_func( 
                                                                           #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                           qcril_cm_supsvc_command_callback_exten,
                                                                           #else
                                                                           qcril_cm_supsvc_command_callback,
                                                                           #endif
                                                                           (void *) user_data,
                                                                           i_ptr->client_info[ modem_id ].client_id,
                                                                           &ss_data.interr
                                                                           #ifdef FEATURE_QCRIL_DSDS
                                                                           , &dialed_digits
                                                                           , CM_ORIG_CLIENT_CATEG_USER
                                                                           , FALSE 
                                                                           , as_id
                                                                           #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                           , &dialed_digits
                                                                           , CM_ORIG_CLIENT_CATEG_USER
                                                                           #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                           , &dialed_digits
                                                                           , FALSE
                                                                           #endif
                                                                         );
  if ( !cm_result )
  {  
    QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_interrogate() \n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_query_clip() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_set_clir

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_CLIR.

    Sets the default CLIR value (i_ptr->clir) as per the received input(n value).  

    If RIL_REQUEST_DIAL does not specify valid CLIR parameter, use the default
    clir value.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_set_clir
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_cm_struct_type *i_ptr;
  int *in_data_ptr;
  uint8  clir_n_param;
  char args[ PROPERTY_VALUE_MAX ];
  char details[ 40 ];
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (int *)params_ptr->data;
  QCRIL_ASSERT( in_data_ptr != NULL );
  clir_n_param=  (uint8) in_data_ptr[0]; /* 27.007, section 7.8 */
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "RIL_REQUEST_SET_CLIR input = %d\n", clir_n_param);

  if ( ( clir_n_param == (uint8) QCRIl_CM_SS_CLIR_PRESENTATION_INDICATOR ) ||
       ( clir_n_param == (uint8) QCRIL_CM_SS_CLIR_INVOCATION_OPTION ) ||
       ( clir_n_param == (uint8) QCRIL_CM_SS_CLIR_SUPPRESSION_OPTION ) )
  {
    QCRIL_SNPRINTF( details, sizeof( details ), "cm_info[%d].ss_mutex\n", instance_id );
    QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );

    i_ptr->clir = clir_n_param;

    /* Save CLIR setting to system property */
    QCRIL_SNPRINTF( args, sizeof( args ), "%d", i_ptr->clir );
    if ( property_set( QCRIL_CM_CLIR, args ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Fail to save %s to system property\n", QCRIL_CM_CLIR );
    }                                                                                

    QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );

    /* sending confirmation as we just need to store the request,
       and use it only when call is initiated */
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    QCRIL_LOG_ERROR( "%s", "received invalid params in RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION\n");
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_set_clir() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_get_clir

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_GET_CLIR.
    Queries for the status of the calling line identity restriction.

    Input Paramerers:
    NULL

    Result:
    NULL ( after receiving the appropriate response from AMSS,
           returns the status of CLIR i.e whether it is active or not )
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_get_clir
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  uint32 user_data;
  qcril_reqlist_u_type u_info;
  qcril_cm_ss_type *req_info_ptr = &u_info.cm.info.ss_info;
  qcril_cm_ss_sups_req_parm_u_type ss_data;
  boolean cm_result;
  cm_num_s_type dialed_digits;
  char ss_buf[ QCRIL_CM_SS_MAX_SUPS_LENGTH ];
  qcril_cm_ss_sups_params_s_type ss_params;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_sups_cmd_interrogate_api_name = "cm_sups_cmd_interrogate_per_subs()";
  #else
  char *cm_sups_cmd_interrogate_api_name = "cm_sups_cmd_interrogate()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  req_info_ptr->ss_code = (uint8) qcril_cm_ss_clir;
  req_info_ptr->ss_ref = qcril_cm_ss_get_ss_ref();

  ss_data.interr.ss_code = req_info_ptr->ss_code;
  ss_data.interr.ss_ref = req_info_ptr->ss_ref;
  ss_data.interr.basic_service.present = FALSE;

  /* fill the sups params required for sups string construction */
  memset( &ss_params, 0, sizeof( ss_params ) );
  ss_params.mode = QCRIL_CM_SS_MODE_QUERY;
  ss_params.code = ss_data.interr.ss_code;

  /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
     check in future. The string should be sent to modem for any call control */
  if( E_SUCCESS != qcril_cm_ss_build_sups_string( &ss_params, ss_buf, QCRIL_CM_SS_MAX_SUPS_LENGTH ) )
  {
    QCRIL_LOG_ERROR( "%s", "Sups string construction failed \n");
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_LOG_DEBUG( "Sups String constructed is %s\n", ss_buf );

  qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &dialed_digits, (byte *)ss_buf, (byte)strlen( ss_buf ), CM_DIGIT_MODE_8BIT_ASCII );
  
  #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN
  /* Below FDN check code leg can be removed once the modem call control feature is turned on */
  if ( !qcril_cm_fdn_check_is_passed( instance_id, modem_id, ss_buf, strlen( ss_buf ) ) )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_FDN_CHECK_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  #endif /* #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN*/

  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_SUPS_INTERROGATE_CONF, &u_info, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = req_info_ptr->ss_ref;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList*/
    return;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

  QCRIL_LOG_RPC( modem_id, cm_sups_cmd_interrogate_api_name, "CLIR basic_service.present = FALSE ss_ref", req_info_ptr->ss_ref );
  cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_interrogate_func( 
                                                                           #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                           qcril_cm_supsvc_command_callback_exten,
                                                                           #else
                                                                           qcril_cm_supsvc_command_callback,
                                                                           #endif
                                                                           (void *) user_data,
                                                                           i_ptr->client_info[ modem_id ].client_id,
                                                                           &ss_data.interr 
                                                                           #ifdef FEATURE_QCRIL_DSDS
                                                                           , &dialed_digits
                                                                           , CM_ORIG_CLIENT_CATEG_USER
                                                                           , FALSE 
                                                                           , as_id
                                                                           #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                           , &dialed_digits
                                                                           , CM_ORIG_CLIENT_CATEG_USER
                                                                           #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                           , &dialed_digits
                                                                           , FALSE
                                                                           #endif
                                                                         );    
  if ( !cm_result )
  {
    QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_interrogate() \n");
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_get_clir() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_set_call_forward

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_CALL_FORWARD.
    Sets the Call Forwarding supplimentary services as per the received
    input(RIL_CallForwardInfo) based on the status value

    Input Paramerers:
    "RIL_CallForwardInfo"

    * status is:
    *            0 = disable
    *            1 = enable
    *            2 = not used
    *            3 = registeration
    *            4 = erasure
    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_set_call_forward
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  uint32 user_data;
  boolean cm_result = TRUE;
  qcril_cm_ss_callforwd_info_param_u_type *in_data_ptr;
  unsigned int in_data_len = (int) params_ptr->datalen;
  unsigned int bcd_num_len = 0;
  qcril_reqlist_u_type u_info;
  qcril_cm_ss_type *req_info_ptr = &u_info.cm.info.ss_info;
  qcril_cm_ss_sups_req_parm_u_type ss_data;
  cm_num_s_type number, dial_digits;
  byte  bcd_number[ CM_CALLED_PARTY_BCD_NO_LENGTH ];
  char *cf_reason_name; /* Name for call forward reason given */
  char ss_buf[ QCRIL_CM_SS_MAX_SUPS_LENGTH ];
  qcril_cm_ss_sups_params_s_type ss_params;
  #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN
  boolean is_fdn_check_passed = FALSE;
  #endif /* !FEATURE_QCRIL_SUPS_CC_EXTEN */
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_sups_cmd_activate_api_name = "cm_sups_cmd_activate_per_subs()";
  char *cm_sups_cmd_deactivate_api_name = "cm_sups_cmd_deactivate_per_subs()";
  char *cm_sups_cmd_register_api_name = "cm_sups_cmd_register_per_subs()";
  char *cm_sups_cmd_erase_api_name = "cm_sups_cmd_erase_per_subs()";
  #else
  char *cm_sups_cmd_activate_api_name = "cm_sups_cmd_activate()";
  char *cm_sups_cmd_deactivate_api_name = "cm_sups_cmd_deactivate()";
  char *cm_sups_cmd_register_api_name = "cm_sups_cmd_register()";
  char *cm_sups_cmd_erase_api_name = "cm_sups_cmd_erase()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (qcril_cm_ss_callforwd_info_param_u_type *)params_ptr->data;
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  memset( &ss_data, 0, sizeof( ss_data ) );
  QCRIL_LOG_DEBUG( "RIL_REQUEST_SET_CALL_FORWARD status = %d, reason = %d, serviceClass = %d\n",
                   in_data_ptr->status, in_data_ptr->reason, in_data_ptr->service_class );

  memset( bcd_number, 0, sizeof( bcd_number ) );
 
  if ( !qcril_cm_ss_req_set_call_fwd_is_valid( in_data_len, in_data_ptr ) )
  {
    QCRIL_LOG_ERROR( "%s", "received invalid paramets in RIL_REQUEST_SET_CALL_FORWARD\n");
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  if ( in_data_ptr->number != NULL )
  {
    qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &number, (byte *)in_data_ptr->number, (byte)strlen(in_data_ptr->number), 
                                                     CM_DIGIT_MODE_8BIT_ASCII );
  
    if ( number.len > 0 )
    {
      QCRIL_LOG_DEBUG( "toa = %d, number is = %s\n",in_data_ptr->toa ,in_data_ptr->number);
  
      /* Number type documented in GSM 04.08 section 10.5.4.7  */
      /* If user speficied the number type, it has precedence. */
      /* The BCD encoding routine will set final type value.   */
      number.number_type = (in_data_ptr->toa & CM_TON_MASK) >> 4;
      number.number_plan = (in_data_ptr->toa & 0x0F);
      qcril_cm_util_number_to_bcd( &number, bcd_number );
  
      /* qcril_cm_util_phone_number_to_bcd saves the length in bcd_number[0] */
      bcd_num_len = bcd_number[ 0 ];
      memcpy( &bcd_number[ 0 ], &bcd_number[ 1 ], bcd_num_len );
      bcd_number[ bcd_num_len ] = '\0';
    }
  }

  req_info_ptr->ss_code = qcril_cm_ss_get_cfw_ss_code( in_data_ptr->reason, &cf_reason_name );
  req_info_ptr->ss_ref = qcril_cm_ss_get_ss_ref();

  /* fill the sups params required for sups string construction */
  memset( &ss_params, 0, sizeof( ss_params ) );
  ss_params.mode = in_data_ptr->status;
  ss_params.code = req_info_ptr->ss_code;
  ss_params.service_class = in_data_ptr->service_class;
  ss_params.req.reg.number = in_data_ptr->number;
  ss_params.req.reg.nr_timer = in_data_ptr->no_reply_timer;

  /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
     check in future. The string should be sent to modem for any call control */
  if ( qcril_cm_ss_build_sups_string( &ss_params, ss_buf, QCRIL_CM_SS_MAX_SUPS_LENGTH ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "Sups string construction failed \n");
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_LOG_DEBUG( "Sups String constructed is %s\n", ss_buf);

  qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &dial_digits, (byte *)ss_buf, (byte)strlen( ss_buf ), CM_DIGIT_MODE_8BIT_ASCII );

  #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN
  /* Below FDN check code leg can be removed once the modem call control feature is turned on */
  is_fdn_check_passed = qcril_cm_fdn_check_is_passed( instance_id, modem_id, ss_buf, strlen( ss_buf ) );

  /* The sups string constructed for REGISTER will be of the form **SC*SIA*SIB*SIC#
     In case of call forwarding both **, * are valid for REGISTER. So the dialled string 
     could as well be a REGISTER starting with a single asterix. Treat both *, ** as valid 
     for call forwarding register */
  if ( !is_fdn_check_passed && ( in_data_ptr->status == QCRIL_CM_SS_MODE_REG ) )
  {
    /* Now check for string starting with a single asterix */
    is_fdn_check_passed = qcril_cm_fdn_check_is_passed( instance_id, modem_id, &ss_buf[ 1 ], strlen( ss_buf ) - 1 );
  }

  if ( !is_fdn_check_passed )
  {
     qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_FDN_CHECK_FAILURE, &resp );
     qcril_send_request_response( &resp );
     return;
  }
  #endif /* #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN*/

  switch ( in_data_ptr->status )
  {
    case QCRIL_CM_SS_MODE_DISABLE:
      ss_data.deact.ss_code = req_info_ptr->ss_code;
      ss_data.deact.ss_ref = req_info_ptr->ss_ref;
      qcril_cm_ss_set_bsg_info( in_data_ptr->service_class, &ss_data.deact.basic_service );
      qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                    QCRIL_EVT_CM_SUPS_DEACTIVATE_CONF, &u_info, &reqlist_entry ); 
      reqlist_entry.valid_sub_id = TRUE;
      reqlist_entry.sub_id = req_info_ptr->ss_ref;
      if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
      {
        /* Fail to add to ReqList */
        return;
      }

      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

      QCRIL_LOG_RPC_SS( modem_id, cm_sups_cmd_deactivate_api_name, cf_reason_name, ss_data.deact.ss_ref, 
                        ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code );
      cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_deactivate_func( 
                                                                              #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                              qcril_cm_supsvc_command_callback_exten,
                                                                              #else
                                                                              qcril_cm_supsvc_command_callback,
                                                                              #endif
                                                                              (void *) user_data,
                                                                              i_ptr->client_info[ modem_id ].client_id,
                                                                              &ss_data.deact
                                                                              #ifdef FEATURE_QCRIL_DSDS
                                                                              , &dial_digits
                                                                              , CM_ORIG_CLIENT_CATEG_USER
                                                                              , FALSE 
                                                                              , as_id
                                                                              #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                              , &dial_digits
                                                                              , CM_ORIG_CLIENT_CATEG_USER
                                                                              #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                              , &dial_digits
                                                                              , FALSE
                                                                              #endif
                                                                            );
      if ( !cm_result )
      {
        QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_deactivate() \n");
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
      break;

    case QCRIL_CM_SS_MODE_ENABLE:
      ss_data.act.ss_code = req_info_ptr->ss_code;
      ss_data.act.ss_ref = req_info_ptr->ss_ref;
      qcril_cm_ss_set_bsg_info( in_data_ptr->service_class, &ss_data.act.basic_service );
      qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                   QCRIL_EVT_CM_SUPS_ACTIVATE_CONF, &u_info, &reqlist_entry ); 
      reqlist_entry.valid_sub_id = TRUE;
      reqlist_entry.sub_id = req_info_ptr->ss_ref;
      if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
      {
        /* Fail to add to ReqList */
        return;
      }
     
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

      QCRIL_LOG_RPC_SS( modem_id, cm_sups_cmd_activate_api_name, cf_reason_name, ss_data.act.ss_ref, 
                        ss_data.act.basic_service.code_type, ss_data.act.basic_service.bs_code );
      cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_activate_func(         
                                                                            #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                            qcril_cm_supsvc_command_callback_exten,
                                                                            #else
                                                                            qcril_cm_supsvc_command_callback,
                                                                            #endif
                                                                            (void *) user_data,
                                                                            i_ptr->client_info[ modem_id ].client_id,
                                                                            &ss_data.act
                                                                            #ifdef FEATURE_QCRIL_DSDS
                                                                            , &dial_digits
                                                                            , CM_ORIG_CLIENT_CATEG_USER
                                                                            , FALSE 
                                                                            , as_id
                                                                            #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                            , &dial_digits
                                                                            , CM_ORIG_CLIENT_CATEG_USER
                                                                            #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                            , &dial_digits
                                                                            , FALSE
                                                                            #endif
                                                                          );
      if ( !cm_result )
      {
        QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_activate() \n");
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
      break;

    case QCRIL_CM_SS_MODE_REG:
      ss_data.reg.ss_code = req_info_ptr->ss_code;
      ss_data.reg.ss_ref = req_info_ptr->ss_ref;
      qcril_cm_ss_set_bsg_info( in_data_ptr->service_class, &ss_data.reg.basic_service );

      /* filling call fwd address structure */
      if ( 0 < bcd_num_len )
      {
        ss_data.reg.fwd_to_num.present = TRUE;
        ss_data.reg.fwd_to_num.length = (byte) bcd_num_len;
        memcpy( ss_data.reg.fwd_to_num.data, bcd_number, bcd_num_len );
      }
      else
      {
        ss_data.reg.fwd_to_num.present = FALSE;
      }

      if ( ( in_data_ptr->reason == (int) QCRIL_CM_SS_CCFC_REASON_NOREPLY ) &&
           ( in_data_ptr->no_reply_timer != 0 ) )
      {
        ss_data.reg.nr_timer.present = TRUE;
        ss_data.reg.nr_timer.timer_value = (byte) in_data_ptr->no_reply_timer;
      }
      else
      {
        ss_data.reg.nr_timer.present = FALSE;
      }

      qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                   QCRIL_EVT_CM_SUPS_REGISTER_CONF, &u_info, &reqlist_entry ); 
      reqlist_entry.valid_sub_id = TRUE;
      reqlist_entry.sub_id = req_info_ptr->ss_ref;
      if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
      {
        /* Fail to add to ReqList */
        return;
      }

      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

      QCRIL_LOG_RPC_SS( modem_id, cm_sups_cmd_register_api_name, cf_reason_name, ss_data.reg.ss_ref, 
                        ss_data.reg.basic_service.code_type, ss_data.reg.basic_service.bs_code );
      cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_register_func( 
                                                                            #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                            qcril_cm_supsvc_command_callback_exten,
                                                                            #else
                                                                            qcril_cm_supsvc_command_callback,
                                                                            #endif
                                                                            (void *) user_data,
                                                                            i_ptr->client_info[ modem_id ].client_id,
                                                                            &ss_data.reg
                                                                            #ifdef FEATURE_QCRIL_DSDS
                                                                            , &dial_digits
                                                                            , CM_ORIG_CLIENT_CATEG_USER
                                                                            , FALSE 
                                                                            , as_id
                                                                            #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                            , &dial_digits
                                                                            , CM_ORIG_CLIENT_CATEG_USER
                                                                            #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                            , &dial_digits
                                                                            , FALSE
                                                                            #endif
                                                                          );       
      if ( !cm_result )
      {
        QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_register() \n");
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
      break;

    case QCRIL_CM_SS_MODE_ERASURE:
      ss_data.erase.ss_code = req_info_ptr->ss_code;
      ss_data.erase.ss_ref = req_info_ptr->ss_ref;
      qcril_cm_ss_set_bsg_info( in_data_ptr->service_class, &ss_data.erase.basic_service );

      qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                   QCRIL_EVT_CM_SUPS_ERASE_CONF, &u_info, &reqlist_entry ); 
      reqlist_entry.valid_sub_id = TRUE;
      reqlist_entry.sub_id = req_info_ptr->ss_ref;
      if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
      {
        /* Fail to add to ReqList */
        return;
      }
  
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

      QCRIL_LOG_RPC_SS( modem_id, cm_sups_cmd_erase_api_name, cf_reason_name, ss_data.erase.ss_ref, 
                        ss_data.erase.basic_service.code_type, ss_data.erase.basic_service.bs_code );
      cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_erase_func( 
                                                                         #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                         qcril_cm_supsvc_command_callback_exten,
                                                                         #else
                                                                         qcril_cm_supsvc_command_callback,
                                                                         #endif
                                                                         (void *) user_data,
                                                                         i_ptr->client_info[ modem_id ].client_id,
                                                                         &ss_data.erase
                                                                         #ifdef FEATURE_QCRIL_DSDS
                                                                         , &dial_digits
                                                                         , CM_ORIG_CLIENT_CATEG_USER
                                                                         , FALSE 
                                                                         , as_id
                                                                         #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                         , &dial_digits
                                                                         , CM_ORIG_CLIENT_CATEG_USER
                                                                         #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                         , &dial_digits
                                                                         , FALSE
                                                                         #endif
                                                                       );
      if ( !cm_result )
      {
        QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_erase() \n" );
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
      break;

    default:
      QCRIL_LOG_ERROR( "Unrecognized status value: %d", in_data_ptr->status );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
      break;
  }

} /* qcril_cm_supsvc_request_set_call_forward() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_query_call_forward_status

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_QUERY_CALL_FORWARD_STATUS.

    Queries for the status of the calling forwarding supplimentary services
    present with the network.

    Input Paramerers:
    int *.
    ((int *)data)[0] is "reason" from TS 27.007 7.11

    Result:
    NULL ( after receiving the appropriate response from AMSS,
           returns the status of call forwarding supplimentary services )
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_query_call_forward_status
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  uint32 user_data;
  qcril_reqlist_u_type u_info;
  qcril_cm_ss_type *req_info_ptr = &u_info.cm.info.ss_info;
  qcril_cm_ss_sups_req_parm_u_type ss_data;
  boolean cm_result;
  RIL_CallForwardInfo *info;
  int reason;
  char *cf_reason_name; /* Name for call forward reason given */
  char details[ 80 ];
  char ss_buf[ QCRIL_CM_SS_MAX_SUPS_LENGTH ];
  cm_num_s_type dial_digits;
  qcril_cm_ss_sups_params_s_type ss_params;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_sups_cmd_interrogate_api_name = "cm_sups_cmd_interrogate_per_subs()";
  #else
  char *cm_sups_cmd_interrogate_api_name = "cm_sups_cmd_interrogate()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  info = ( RIL_CallForwardInfo * )( params_ptr->data );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  memset( &ss_data, 0, sizeof( ss_data ) );
  memset( &u_info, 0, sizeof( u_info ) );
  reason = info->reason;
  
  if ( !( ( reason >= (int) QCRIL_CM_SS_CCFC_REASON_UNCOND ) && ( reason < (int) QCRIL_CM_SS_CCFC_REASON_MAX ) ) )
  {
    QCRIL_LOG_ERROR( "%s", "received invalid reason in RIL_REQUEST_QUERY_CALL_FORWARD_STATUS\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  req_info_ptr->ss_code = qcril_cm_ss_get_cfw_ss_code( reason, &cf_reason_name );
  req_info_ptr->ss_ref = qcril_cm_ss_get_ss_ref();

  ss_data.interr.ss_code = req_info_ptr->ss_code;
  ss_data.interr.ss_ref = req_info_ptr->ss_ref;
  qcril_cm_ss_set_bsg_info( info->serviceClass, &ss_data.interr.basic_service );
  if ( ss_data.interr.basic_service.present )
  {
    req_info_ptr->ss_service_class = info->serviceClass;
  }

  /* fill the sups params required for sups string construction */
  memset( &ss_params, 0, sizeof( ss_params ) );
  ss_params.mode = QCRIL_CM_SS_MODE_QUERY;
  ss_params.code = req_info_ptr->ss_code;
  ss_params.service_class = info->serviceClass;
  ss_params.req.reg.number = info->number;
  ss_params.req.reg.nr_timer = info->timeSeconds;

  /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
     check in future. The string should be sent to modem for any call control*/
  if ( qcril_cm_ss_build_sups_string( &ss_params, ss_buf, QCRIL_CM_SS_MAX_SUPS_LENGTH ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "Sups string construction failed \n");
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_LOG_DEBUG( "Sups String constructed is %s\n", ss_buf);
  
  qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &dial_digits, (byte *)ss_buf, (byte)strlen( ss_buf ), CM_DIGIT_MODE_8BIT_ASCII );

  #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN
  /* Below FDN check code leg can be removed once the modem call control feature is turned on */
  if ( !qcril_cm_fdn_check_is_passed( instance_id, modem_id, ss_buf, strlen( ss_buf ) ) )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_FDN_CHECK_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  #endif /* #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN*/

  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_SUPS_INTERROGATE_CONF, &u_info, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = req_info_ptr->ss_ref;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_SNPRINTF( details, sizeof( details ), "%s ss_ref %d", cf_reason_name, ss_data.interr.ss_ref );

  QCRIL_LOG_RPC2( modem_id, cm_sups_cmd_interrogate_api_name, details );
  cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_interrogate_func(
                                                                           #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                           qcril_cm_supsvc_command_callback_exten,
                                                                           #else
                                                                           qcril_cm_supsvc_command_callback,
                                                                           #endif
                                                                           (void *) user_data,
                                                                           i_ptr->client_info[ modem_id ].client_id,
                                                                           &ss_data.interr 
                                                                           #ifdef FEATURE_QCRIL_DSDS
                                                                           , &dial_digits
                                                                           , CM_ORIG_CLIENT_CATEG_USER
                                                                           , FALSE 
                                                                           , as_id
                                                                           #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                           , &dial_digits
                                                                           , CM_ORIG_CLIENT_CATEG_USER
                                                                           #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                           , &dial_digits
                                                                           , FALSE
                                                                           #endif
                                                                         );      
  if ( !cm_result )
  {
    QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_interrogate() \n");
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_query_call_forward_status() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_set_call_waiting

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_CALL_WAITING.
    Sets the Call Waiting supplimentary services as per the received
    input

    Input Paramerers:
    const int *
    ((const int *)data)[0] is 0 for "disabled" and 1 for "enabled".
    ((const int *)data)[1] is the TS 27.007 service class bit vector of  services to modify

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_set_call_waiting
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  uint32 user_data;
  boolean cm_result = TRUE;
  int *in_data_ptr;
  unsigned int in_data_len;
  int  status, service_class;
  qcril_reqlist_u_type u_info;
  qcril_cm_ss_type *req_info_ptr = &u_info.cm.info.ss_info;
  qcril_cm_ss_sups_req_parm_u_type ss_data;
  char ss_buf [ QCRIL_CM_SS_MAX_SUPS_LENGTH ];
  qcril_cm_ss_sups_params_s_type ss_params;
  cm_num_s_type dial_digits;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_sups_cmd_deactivate_api_name = "cm_sups_cmd_deactivate_per_subs()";
  char *cm_sups_cmd_activate_api_name = "cm_sups_cmd_activate_per_subs()";
  #else
  char *cm_sups_cmd_deactivate_api_name = "cm_sups_cmd_deactivate()";
  char *cm_sups_cmd_activate_api_name = "cm_sups_cmd_activate()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (int *)params_ptr->data;
  in_data_len = params_ptr->datalen;
  QCRIL_ASSERT( in_data_ptr != NULL );
  status = in_data_ptr[0];
  QCRIL_ASSERT( in_data_ptr != NULL );
  service_class = in_data_ptr[ 1 ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  memset( &ss_data, 0, sizeof( ss_data ) );
  QCRIL_LOG_DEBUG( "RIL_REQUEST_SET_CALL_WAITING service_class = %d\n", service_class );

  if ( !qcril_cm_ss_req_set_call_wait_is_valid( in_data_len, status, service_class ) )
  {
    QCRIL_LOG_ERROR( "%s", "received invalid paramets in RIL_REQUEST_SET_CALL_WAITING\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  req_info_ptr->ss_code = (uint8) qcril_cm_ss_cw;
  req_info_ptr->ss_ref = qcril_cm_ss_get_ss_ref();

  /* fill the sups params required for sups string construction */
  memset( &ss_params, 0, sizeof( ss_params ) );
  ss_params.mode = status;
  ss_params.code = req_info_ptr->ss_code;
  ss_params.service_class = service_class;

  /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
     check in future. The string should be sent to modem for any call control */
  if ( qcril_cm_ss_build_sups_string( &ss_params, ss_buf, QCRIL_CM_SS_MAX_SUPS_LENGTH ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "Sups string construction failed \n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_LOG_DEBUG( "Sups String constructed is %s\n", ss_buf);

  qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &dial_digits, (byte *)ss_buf, (byte)strlen( ss_buf ), CM_DIGIT_MODE_8BIT_ASCII );

  #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN
  /* Below FDN check code leg can be removed once the modem call control feature is turned on */
  if ( !qcril_cm_fdn_check_is_passed( instance_id, modem_id, ss_buf, strlen( ss_buf ) ) )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_FDN_CHECK_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  #endif /* #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN*/

  switch ( status )
  {
    case QCRIL_CM_SS_MODE_DISABLE:
      ss_data.deact.ss_code = (uint8)qcril_cm_ss_cw;
      ss_data.deact.ss_ref = req_info_ptr->ss_ref;
      qcril_cm_ss_set_bsg_info( service_class, &ss_data.deact.basic_service );

      qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                   QCRIL_EVT_CM_SUPS_DEACTIVATE_CONF, &u_info, &reqlist_entry ); 
      reqlist_entry.valid_sub_id = TRUE;
      reqlist_entry.sub_id = req_info_ptr->ss_ref;
      if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
      {
        /* Fail to add to ReqList */
        return;
      }

      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

      QCRIL_LOG_RPC_SS( modem_id, cm_sups_cmd_deactivate_api_name, "CallWaiting", ss_data.deact.ss_ref, 
                        ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code );
      cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_deactivate_func( 
                                                                              #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                              qcril_cm_supsvc_command_callback_exten,
                                                                              #else
                                                                              qcril_cm_supsvc_command_callback,
                                                                              #endif
                                                                              (void *) user_data,
                                                                              i_ptr->client_info[ modem_id ].client_id,
                                                                              &ss_data.deact
                                                                              #ifdef FEATURE_QCRIL_DSDS
                                                                              , &dial_digits
                                                                              , CM_ORIG_CLIENT_CATEG_USER
                                                                              , FALSE 
                                                                              , as_id
                                                                              #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                              , &dial_digits
                                                                              , CM_ORIG_CLIENT_CATEG_USER
                                                                              #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                              , &dial_digits
                                                                              , FALSE
                                                                              #endif
                                                                            );
      if ( !cm_result )
      {
        QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_deactivate() \n");
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
      break;

    case QCRIL_CM_SS_MODE_ENABLE:
      ss_data.act.ss_code = (uint8)qcril_cm_ss_cw;
      ss_data.act.ss_ref = req_info_ptr->ss_ref;
      qcril_cm_ss_set_bsg_info( service_class, &ss_data.act.basic_service );

      qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                   QCRIL_EVT_CM_SUPS_ACTIVATE_CONF, &u_info, &reqlist_entry ); 
      reqlist_entry.valid_sub_id = TRUE;
      reqlist_entry.sub_id = req_info_ptr->ss_ref;
      if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
      {
        /* Fail to add to ReqList */
        return;
      }
         
      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

      QCRIL_LOG_RPC_SS( modem_id, cm_sups_cmd_activate_api_name, "CallWaiting", ss_data.deact.ss_ref, 
                        ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code );
      cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_activate_func( 
                                                                            #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                            qcril_cm_supsvc_command_callback_exten,
                                                                            #else
                                                                            qcril_cm_supsvc_command_callback,
                                                                            #endif
                                                                            (void *) user_data,
                                                                            i_ptr->client_info[ modem_id ].client_id,
                                                                            &ss_data.act
                                                                            #ifdef FEATURE_QCRIL_DSDS
                                                                            , &dial_digits
                                                                            , CM_ORIG_CLIENT_CATEG_USER
                                                                            , FALSE 
                                                                            , as_id
                                                                            #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                            , &dial_digits
                                                                            , CM_ORIG_CLIENT_CATEG_USER
                                                                            #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                            , &dial_digits
                                                                            , FALSE
                                                                            #endif
                                                                          );
      if ( !cm_result )
      {
        QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_activate() \n" );
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
      break;

    default:
      QCRIL_LOG_ERROR( "Unrecognized status value: %d", status );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
  } /* end switch */

} /* qcril_cm_supsvc_request_set_call_waiting() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_query_call_waiting

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_QUERY_CALL_WAITING.
    Queries for the status of the call waiting supplimentary services present
    with the network.

    Input Paramerers:
    const int *
    ((const int *)data)[0] is the TS 27.007 service class to query

    though service class is provided as input, it is not required for this SS.

    @return:
    None ( after receiving the appropriate response from AMSS,
           returns the basic service groups list for which call waiting is active )

*/
/*=========================================================================*/
void qcril_cm_supsvc_request_query_call_waiting
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  uint32 user_data;
  qcril_reqlist_u_type u_info;
  qcril_cm_ss_type *req_info_ptr = &u_info.cm.info.ss_info;
  qcril_cm_ss_sups_req_parm_u_type ss_data;
  boolean cm_result;
  int service_class = ((int *) params_ptr->data)[ 0 ];
  char ss_buf[ QCRIL_CM_SS_MAX_SUPS_LENGTH ];
  cm_num_s_type dial_digits;
  qcril_cm_ss_sups_params_s_type ss_params;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_sups_cmd_interrogate_api_name = "cm_sups_cmd_interrogate_per_subs()";
  #else
  char *cm_sups_cmd_interrogate_api_name = "cm_sups_cmd_interrogate()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  memset( &ss_data, 0, sizeof( ss_data ) );

  /* Though we are checking for service class it is ignored in case of invalid
     class here as service class is not required for interrogation, only if
     status is received in resonse then we use service class */
  QCRIL_LOG_DEBUG( "Received service class = %d\n", service_class );
  if ( (int) qcril_cm_ss_cw_allowed_classes != ( service_class | (int) qcril_cm_ss_cw_allowed_classes ) )
  {
    QCRIL_LOG_ERROR( "%s", "invalid service class received\n" );
  }

  req_info_ptr->ss_code = (uint8) qcril_cm_ss_cw;
  req_info_ptr->ss_ref = qcril_cm_ss_get_ss_ref();
  req_info_ptr->ss_service_class = service_class;

  ss_data.interr.ss_code = req_info_ptr->ss_code;
  ss_data.interr.ss_ref = req_info_ptr->ss_ref;
  qcril_cm_ss_set_bsg_info( service_class, &ss_data.interr.basic_service );

  /* fill the sups params required for sups string construction */
  memset( &ss_params, 0, sizeof( ss_params ) );
  ss_params.mode = QCRIL_CM_SS_MODE_QUERY;
  ss_params.code = req_info_ptr->ss_code;
  ss_params.service_class = service_class;

  /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
  check in future. The string should be sent to modem for call control */
  if ( qcril_cm_ss_build_sups_string( &ss_params, ss_buf, QCRIL_CM_SS_MAX_SUPS_LENGTH ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "Sups string construction failed \n");
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_LOG_DEBUG( "Sups String constructed is %s\n", ss_buf );

  qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &dial_digits, (byte *)ss_buf, (byte)strlen( ss_buf ), CM_DIGIT_MODE_8BIT_ASCII );

  #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN
  /* Below FDN check code leg can be removed once the modem call control feature is turned on */
  if ( !qcril_cm_fdn_check_is_passed( instance_id, modem_id, ss_buf, strlen( ss_buf ) ) )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_FDN_CHECK_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  #endif /* #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN*/

  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_SUPS_INTERROGATE_CONF, &u_info, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = req_info_ptr->ss_ref;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
      return;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

  QCRIL_LOG_RPC( modem_id, cm_sups_cmd_interrogate_api_name, "CallWaiting ss_ref", req_info_ptr->ss_ref );
  cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_interrogate_func( 
                                                                           #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                           qcril_cm_supsvc_command_callback_exten,
                                                                           #else
                                                                           qcril_cm_supsvc_command_callback,
                                                                           #endif
                                                                           (void *) user_data,
                                                                           i_ptr->client_info[ modem_id ].client_id,
                                                                           &ss_data.interr 
                                                                           #ifdef FEATURE_QCRIL_DSDS
                                                                           , &dial_digits
                                                                           , CM_ORIG_CLIENT_CATEG_USER
                                                                           , FALSE 
                                                                           , as_id
                                                                           #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                           , &dial_digits
                                                                           , CM_ORIG_CLIENT_CATEG_USER
                                                                           #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                           , &dial_digits
                                                                           , FALSE
                                                                           #endif
                                                                         );
  if ( !cm_result )
  {
    QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_interrogate() \n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_query_call_waiting() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_change_barring_password

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CHANGE_BARRING_PASSWORD.
    changes the call barrring password which is registered with the network
    and which is required for activation or deactivation of call barring SS

    input Paramerers:

    const char **
    ((const char **)data)[0] = facility  string code from TS 27.007 7.4
    ((const char **)data)[1] = old password
    ((const char **)data)[1] = new password

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_change_barring_password
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  uint32 user_data;
  boolean cm_result = TRUE;
  const char **in_data = (const char **)params_ptr->data;
  unsigned int in_data_len = params_ptr->datalen;
  int facility;
  qcril_reqlist_u_type u_info;
  qcril_cm_ss_type *req_info_ptr = &u_info.cm.info.ss_info;
  qcril_cm_ss_sups_req_parm_u_type ss_data;
  char facility_name[3];
  char details[80];
  char ss_buf[QCRIL_CM_SS_MAX_SUPS_LENGTH];
  cm_num_s_type dial_digits;
  qcril_cm_ss_sups_params_s_type ss_params;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_sups_cmd_reg_password_api_name = "cm_sups_cmd_reg_password_per_subs()";
  #else
  char *cm_sups_cmd_reg_password_api_name = "cm_sups_cmd_reg_password()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  facility = qcril_cm_ss_get_facility_value( in_data[ 0 ], &facility_name[ 0 ] );

  QCRIL_LOG_DEBUG( "RIL_REQUEST_CHANGE_BARRING_PASSWORD Facility %s (%d), old_pw %s, new_pw %s\n",
                   facility_name, facility, in_data[1], in_data[2] );

  if ( !qcril_cm_ss_req_change_cb_pwd_is_valid( in_data_len, facility, in_data[ 1 ], in_data[ 2 ] ) )
  {
    QCRIL_LOG_ERROR( "%s", "received invalid paramets in RIL_REQUEST_CHANGE_BARRING_PASSWORD\n");
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    req_info_ptr->ss_ref = qcril_cm_ss_get_ss_ref();;
    req_info_ptr->ss_code = (uint8) qcril_cm_ss_get_cb_ss_code(facility);

    memset( &ss_data, NULL, sizeof( ss_data ) );

    ss_data.password.ss_code.ss_code = req_info_ptr->ss_code;
    ss_data.password.ss_ref = req_info_ptr->ss_ref;
    /* filling the password information as accepted by call manager (CM)*/

    ss_data.password.ss_old_pwd.present = TRUE;
    memcpy(ss_data.password.ss_old_pwd.ss_password,
           in_data[1],
           sizeof(char)* strlen(in_data[1]));

    ss_data.password.ss_new_pwd.present = TRUE;
    memcpy(ss_data.password.ss_new_pwd.ss_password,
           in_data[2],
           sizeof(char)* strlen(in_data[2]));

    ss_data.password.ss_new_pwd_again.present = TRUE;
    memcpy(ss_data.password.ss_new_pwd_again.ss_password,
           in_data[2],
           sizeof(char)* strlen(in_data[2]));

    /* fill the sups params required for sups string construction */
    memset(&ss_params, 0, sizeof(ss_params));
    ss_params.mode = QCRIL_CM_SS_MODE_REG_PASSWD;
    ss_params.code = req_info_ptr->ss_code;
    ss_params.req.passwd.old_passwd = (char*)in_data[1];
    ss_params.req.passwd.new_passwd = (char*)in_data[2];
    ss_params.req.passwd.new_passwd_again = (char*)in_data[2];

    /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
    check in future. The string should be sent to modem for call control */
    if( E_SUCCESS != qcril_cm_ss_build_sups_string(&ss_params, ss_buf, QCRIL_CM_SS_MAX_SUPS_LENGTH) )
    {
      QCRIL_LOG_ERROR( "%s", "Sups string construction failed \n");
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
    else
    {
      QCRIL_LOG_DEBUG( "Sups String constructed is %s\n", ss_buf);

      qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &dial_digits, (byte *)ss_buf, (byte)strlen( ss_buf ), CM_DIGIT_MODE_8BIT_ASCII );

  #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN
      /* Below FDN check code leg can be removed once the modem call control feature is turned on */
      if ( !qcril_cm_fdn_check_is_passed( instance_id, modem_id, ss_buf, strlen( ss_buf ) ) )
      {
        /* The sups string constructed for REG_PASSWD will be of the form **03*SC*SIA*SIB*SIC#
        Change passwd can start with any one of **, *. So the dialled string starting with a
        single asterix for passwd change is also valid. Treat both *, ** as valid. */
        if( !qcril_cm_fdn_check_is_passed( instance_id, modem_id, &ss_buf[ 1 ], strlen( ss_buf ) - 1 ) )
        {
          qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_FDN_CHECK_FAILURE, &resp );
          qcril_send_request_response( &resp );
          return;
        }
      }
  #endif /* #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN*/
    }

    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                 QCRIL_EVT_CM_SUPS_REG_PASSWORD_CONF, &u_info, &reqlist_entry ); 
    reqlist_entry.valid_sub_id = TRUE;
    reqlist_entry.sub_id = req_info_ptr->ss_ref;
    if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
    {
      /* Fail to add to ReqList */
      return;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
    QCRIL_SNPRINTF( details, sizeof( details ), "%s ss_ref %d", facility_name, ss_data.password.ss_ref );
    
    QCRIL_LOG_RPC2( modem_id, cm_sups_cmd_reg_password_api_name, details );
    cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_reg_password_func( 
                                                                              #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                              qcril_cm_supsvc_command_callback_exten,
                                                                              #else
                                                                              qcril_cm_supsvc_command_callback,
                                                                              #endif
                                                                              (void *) user_data,
                                                                              i_ptr->client_info[ modem_id ].client_id,
                                                                              &ss_data.password
                                                                              #ifdef FEATURE_QCRIL_DSDS
                                                                              , &dial_digits
                                                                              , CM_ORIG_CLIENT_CATEG_USER
                                                                              , FALSE
                                                                              , as_id
                                                                              #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                              , &dial_digits
                                                                              , CM_ORIG_CLIENT_CATEG_USER
                                                                              #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                              , &dial_digits
                                                                              , FALSE
                                                                              #endif
                                                                            );
    if ( !cm_result )
    {
      QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_reg_password() \n");
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  }

} /* qcril_cm_supsvc_request_change_barring_password() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_set_facility_lock

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_FACILITY_LOCK.
    Sets the Call Waiting supplimentary services as per the received
    input

    Input Paramerers:
    const char **.
    ((const char **)data)[0] = facility string code from TS 27.007 7.4
    ((const char **)data)[1] = "0" for "unlock" and "1" for "lock".
    ((const char **)data)[2] = password.
    ((const char **)data)[3] = string representation of decimal TS 27.007
     service class bit vector.
     Eg, the string "1" means "set this facility for voice services
    ((const char **)data)[4] is the AID (applies only in case of FDN, or "" otherwise)

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_set_facility_lock
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  uint32 user_data;
  boolean  cm_result = TRUE;
  const char **in_data = (const char **)params_ptr->data;
  unsigned int in_data_len = params_ptr->datalen;
  const char *facility_string = in_data[ 0 ];
  const char *facility_status = in_data[ 1 ];
  const char *facility_password = in_data[ 2 ];
  const char *facility_class = in_data [ 3 ];
  int facility, status, service_class;
  qcril_reqlist_u_type u_info;
  qcril_cm_ss_type *req_info_ptr = &u_info.cm.info.ss_info;
  qcril_cm_ss_sups_req_parm_u_type ss_data;
  IxErrnoType err_no;
  char facility_name[ 3 ];
  char ss_buf[ QCRIL_CM_SS_MAX_SUPS_LENGTH ];
  cm_num_s_type dial_digits;
  qcril_cm_ss_sups_params_s_type ss_params;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  qcril_arb_subs_prov_status_e_type subs_state;
  RIL_SelectUiccSub uicc_sub_info;
  qmi_uim_session_type session_type;
  char *cm_sups_cmd_deactivate_api_name = "cm_sups_cmd_deactivate_per_subs()";
  char *cm_sups_cmd_activate_api_name = "cm_sups_cmd_activate_per_subs()";
  #else
  char *cm_sups_cmd_deactivate_api_name = "cm_sups_cmd_deactivate()";
  char *cm_sups_cmd_activate_api_name = "cm_sups_cmd_activate()";
  #endif /* FEATURE_QCRIL_DSDS */
  
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  memset( &ss_data, 0, sizeof( ss_data ) );
  memset( &u_info, 0, sizeof( u_info ) );
  facility = qcril_cm_ss_get_facility_value( facility_string, &facility_name[ 0 ] );

  QCRIL_LOG_DEBUG( "RIL_REQUEST_SET_FACILITY_LOCK Facility %s, %s, pw %s\n",
                   facility_name, ( ( *facility_status == '0' ) ? "unlock": "lock" ), facility_password );

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    /* allow FDN or PIN LOCK request always, irrespective of subscription status,
       UIM will reject the request in case app status is not ready */
    if ( !( ( facility == QCRIL_CM_SS_LOCK_SC) || ( facility == QCRIL_CM_SS_LOCK_FD ) ) )
    {
       QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
       qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
       qcril_send_request_response( &resp );
       return;
    }
  }
  #endif /* FEATURE_QCRIL_DSDS */

  if ( facility == (int) QCRIL_CM_SS_LOCK_SC )
  {
    /* Call event handler of QCRIL_MMGSDI which will take care of handling and
       sending the response back to RIL */
    err_no = qcril_process_event( instance_id, modem_id, QCRIL_EVT_INTERNAL_MMGSDI_SET_PIN1_STATUS, 
                                  params_ptr->data, params_ptr->datalen, params_ptr->t );

    /* Event handler not found */
    if ( err_no != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Event handler not found for Event = %d\n", QCRIL_EVT_INTERNAL_MMGSDI_SET_PIN1_STATUS ); 
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }           

    return;
  } 

  if ( facility == (int) QCRIL_CM_SS_LOCK_FD )
  {
    /* Call event handler of QCRIL MMGSDI which will take care of handling and
       sending the response back to RIL */ 
    err_no = qcril_process_event( instance_id, modem_id, QCRIL_EVT_INTERNAL_MMGSDI_SET_FDN_STATUS, 
                                  params_ptr->data, params_ptr->datalen, params_ptr->t );

    /* Event handler not found */
    if ( err_no != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Event handler not found for Event = %d\n", QCRIL_EVT_INTERNAL_MMGSDI_SET_FDN_STATUS ); 
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }               

    return;
  }

  QCRIL_LOG_DEBUG( "class = %s facility = %d\n", facility_class, facility );

  status = ( ( *facility_status == '0') ? FALSE: ( *facility_status == '1' ) ? TRUE : 2 );
  service_class = atoi( facility_class );

  if ( facility_password != NULL )
  {
    QCRIL_ASSERT( strlen( facility_password ) <= MAX_PWD_CHAR );
    req_info_ptr->ss_pwd.present = TRUE;
    memcpy( req_info_ptr->ss_pwd.password, facility_password, strlen(facility_password) );
  }  

  if ( !qcril_cm_ss_req_set_fac_lck_is_valid( in_data_len, facility, status, facility_password, service_class ) )
  {
    QCRIL_LOG_ERROR( "%s", "received invalid paramets in RIL_REQUEST_SET_FACILITY_LOCK\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  req_info_ptr->ss_ref = qcril_cm_ss_get_ss_ref();;
  req_info_ptr->ss_code = (uint8) qcril_cm_ss_get_cb_ss_code( facility );

  /* fill the sups params required for sups string construction */
  memset( &ss_params, 0, sizeof( ss_params ) );
  ss_params.mode = status;
  ss_params.code = req_info_ptr->ss_code;
  ss_params.service_class = service_class;
  ss_params.req.passwd.old_passwd = (char *)facility_password;

  /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
     check in future. The string should be sent to modem for call control */
  if ( qcril_cm_ss_build_sups_string( &ss_params, ss_buf, QCRIL_CM_SS_MAX_SUPS_LENGTH ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "Sups string construction failed \n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_LOG_DEBUG( "Sups String constructed is %s\n", ss_buf);

  qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &dial_digits, (byte *)ss_buf, (byte)strlen( ss_buf ), CM_DIGIT_MODE_8BIT_ASCII );

  #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN
  /* Below FDN check code leg can be removed once the modem call control feature is turned on */
  if ( !qcril_cm_fdn_check_is_passed( instance_id, modem_id, ss_buf, strlen( ss_buf ) ) )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_FDN_CHECK_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  #endif /* #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN*/

  switch ( status )
  {
    case QCRIL_CM_SS_MODE_DISABLE:
      ss_data.deact.ss_code = req_info_ptr->ss_code;
      ss_data.deact.ss_ref = req_info_ptr->ss_ref;
      qcril_cm_ss_set_bsg_info( service_class, &ss_data.deact.basic_service );

      qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                   QCRIL_EVT_CM_SUPS_DEACTIVATE_CONF, &u_info, &reqlist_entry ); 
      reqlist_entry.valid_sub_id = TRUE;
      reqlist_entry.sub_id = req_info_ptr->ss_ref;
      if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
      {
        /* Fail to add to ReqList */
        return;
      }

      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

      QCRIL_LOG_RPC_SS( modem_id, cm_sups_cmd_deactivate_api_name, facility_name, ss_data.deact.ss_ref, i
                        ss_data.deact.basic_service.code_type, ss_data.deact.basic_service.bs_code );
      cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_deactivate_func( 
                                                                              #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                              qcril_cm_supsvc_command_callback_exten,
                                                                              #else
                                                                              qcril_cm_supsvc_command_callback,
                                                                              #endif
                                                                              (void *) user_data,
                                                                              i_ptr->client_info[ modem_id ].client_id,
                                                                              &ss_data.deact
                                                                              #ifdef FEATURE_QCRIL_DSDS
                                                                              , &dial_digits
                                                                              , CM_ORIG_CLIENT_CATEG_USER
                                                                              , FALSE 
                                                                              , as_id
                                                                              #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                              , &dial_digits
                                                                              , CM_ORIG_CLIENT_CATEG_USER
                                                                              #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                              , &dial_digits
                                                                              , FALSE
                                                                              #endif
                                                                            );
      if ( !cm_result )
      {
        QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_deactivate() \n" );
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
      break;

    case QCRIL_CM_SS_MODE_ENABLE:
      ss_data.act.ss_code = req_info_ptr->ss_code;
      ss_data.act.ss_ref = req_info_ptr->ss_ref;
      qcril_cm_ss_set_bsg_info( service_class, &ss_data.act.basic_service );         

      qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                   QCRIL_EVT_CM_SUPS_ACTIVATE_CONF, &u_info, &reqlist_entry ); 
      reqlist_entry.valid_sub_id = TRUE;
      reqlist_entry.sub_id = req_info_ptr->ss_ref;
      if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
      {
        /* Fail to add to ReqList */
        return;
      }

      user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

      QCRIL_LOG_RPC_SS( modem_id, cm_sups_cmd_activate_api_name, facility_name, ss_data.act.ss_ref, 
                        ss_data.act.basic_service.code_type, ss_data.act.basic_service.bs_code );
      cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_activate_func( 
                                                                            #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                            qcril_cm_supsvc_command_callback_exten,
                                                                            #else
                                                                            qcril_cm_supsvc_command_callback,
                                                                            #endif
                                                                            (void *) user_data,
                                                                            i_ptr->client_info[ modem_id ].client_id,
                                                                            &ss_data.act
                                                                            #ifdef FEATURE_QCRIL_DSDS
                                                                            , &dial_digits
                                                                            , CM_ORIG_CLIENT_CATEG_USER
                                                                            , FALSE 
                                                                            , as_id
                                                                            #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                            , &dial_digits
                                                                            , CM_ORIG_CLIENT_CATEG_USER
                                                                            #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                            , &dial_digits
                                                                            , FALSE
                                                                            #endif
                                                                          );
      if ( !cm_result )
      {
        QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_activate() \n" );
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
      }
      break;

    default:
      QCRIL_LOG_ERROR( "Unrecognized status value: %d", status );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
  } /* end switch */

} /* qcril_cm_supsvc_request_set_facility_lock() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_query_facility_lock

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_QUERY_FACILITY_LOCK.
    Queries for the status of the call barring supplimentary services present
    with the network.

    Input Paramerers:
       const char **
       ((const char **)data)[0] is the facility string code from TS 27.007 7.4.
       ((const char **)data)[1] is the password.
       ((const char **)data)[2] is the TS 27.007 service class bit vector of  services to query
       ((const char **)data)[3] is the AID (applies only in case of FDN, or "" otherwise)

    though service class is provided as input, it is not required for call barring SS.

    Result:
    None ( after receiving the appropriate response from AMSS,
              returns the basic service groups list for which call waiting is active )

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_query_facility_lock
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  uint32 user_data;
  boolean  cm_result = TRUE;
  const char **in_data = (const char **) params_ptr->data;
  const char *facility_string = in_data[ 0 ];
  const char *facility_password = in_data[ 1 ];
  const char *facility_class = in_data [ 2 ];
  int facility, service_class;
  unsigned int in_data_len = params_ptr->datalen;

  qcril_reqlist_u_type u_info;
  qcril_cm_ss_type *req_info_ptr = &u_info.cm.info.ss_info;
  qcril_cm_ss_sups_req_parm_u_type ss_data;
  IxErrnoType err_no;  
  char facility_name[ 3 ];
  char details[ 80 ];
  char ss_buf[ QCRIL_CM_SS_MAX_SUPS_LENGTH ];
  cm_num_s_type dial_digits;
  qcril_cm_ss_sups_params_s_type ss_params;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  qcril_arb_subs_prov_status_e_type subs_state;
  RIL_SelectUiccSub uicc_sub_info;
  qmi_uim_session_type session_type;
  char *cm_sups_cmd_interrogate_api_name = "cm_sups_cmd_interrogate_per_subs()";
  #else
  char *cm_sups_cmd_interrogate_api_name = "cm_sups_cmd_interrogate()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  memset( &ss_data, 0, sizeof( ss_data ) );
  memset( &u_info, 0, sizeof( u_info ) );
  facility = qcril_cm_ss_get_facility_value( facility_string, &facility_name[ 0 ] );

  QCRIL_LOG_DEBUG( "RIL_REQUEST_QUERY_FACILITY_LOCK Facility %s, pw %s, service_class %s\n",
                   facility_name, facility_password, facility_class );

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    /* allow FDN or PIN LOCK request always, irrespective of subscription status,
       UIM will reject the request in case app status is not ready */
    if ( !( ( facility == QCRIL_CM_SS_LOCK_SC) || ( facility == QCRIL_CM_SS_LOCK_FD ) ) )
    {
       QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
       qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
       qcril_send_request_response( &resp );
       return;
    }
  }
  #endif /* FEATURE_QCRIL_DSDS */

  if ( facility == (int) QCRIL_CM_SS_LOCK_SC )
  {
    /* Call event handler of QCRIL MMGSDI which will take care of handling and
       sending the response back to RIL */
    err_no = qcril_process_event( instance_id, modem_id, QCRIL_EVT_INTERNAL_MMGSDI_GET_PIN1_STATUS, 
                                  params_ptr->data, params_ptr->datalen, params_ptr->t );
    /* Event handler not found */
    if ( err_no != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Event handler not found for Event = %d\n", QCRIL_EVT_INTERNAL_MMGSDI_GET_PIN1_STATUS ); 
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }  

    return;
  }

  if ( facility == (int)QCRIL_CM_SS_LOCK_FD )
  {
    /* Call event handler of QCRIL MMGSDI which will take care of handling and
       sending the response back to RIL */ 
    err_no = qcril_process_event( instance_id, modem_id, QCRIL_EVT_INTERNAL_MMGSDI_GET_FDN_STATUS, 
                                  params_ptr->data, params_ptr->datalen, params_ptr->t );
    /* Event handler not found */
    if ( err_no != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Event handler not found for Event = %d\n", QCRIL_EVT_INTERNAL_MMGSDI_GET_FDN_STATUS ); 
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }   

    return;
  }

  service_class = atoi( facility_class );

  if ( !qcril_cm_ss_query_facility_lock_is_valid( in_data_len, facility, facility_password, service_class ) )
  {
    QCRIL_LOG_ERROR( "%s", "received invalid paramets in RIL_REQUEST_QUERY_FACILITY_LOCK\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  req_info_ptr->ss_code = (uint8)qcril_cm_ss_get_cb_ss_code( facility );
  req_info_ptr->ss_ref = qcril_cm_ss_get_ss_ref();
  req_info_ptr->ss_service_class = service_class;

  if ( facility_password != NULL )
  {
    QCRIL_ASSERT( strlen( facility_password ) <= MAX_PWD_CHAR );
    req_info_ptr->ss_pwd.present = TRUE;
    memcpy( req_info_ptr->ss_pwd.password, facility_password, strlen(facility_password) );
  }
  else
  {
    req_info_ptr->ss_pwd.present = FALSE;
  }
   
  ss_data.interr.ss_code = req_info_ptr->ss_code;
  ss_data.interr.ss_ref = req_info_ptr->ss_ref;
  qcril_cm_ss_set_bsg_info( service_class, &ss_data.interr.basic_service );

  /* fill the sups params required for sups string construction */
  memset( &ss_params, 0, sizeof( ss_params ) );
  ss_params.mode = QCRIL_CM_SS_MODE_QUERY;
  ss_params.code = req_info_ptr->ss_code;
  ss_params.service_class = service_class;
  ss_params.req.passwd.old_passwd = (char *) facility_password;

  /* Invoke Sups String Construction. This has to be invoked even if QCRIL doesn't do FDN
    check in future. The string should be sent to modem for call control */
  if ( qcril_cm_ss_build_sups_string( &ss_params, ss_buf, QCRIL_CM_SS_MAX_SUPS_LENGTH ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "Sups string construction failed \n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_LOG_DEBUG( "Sups String constructed is %s\n", ss_buf );

  qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &dial_digits, (byte *)ss_buf, (byte)strlen( ss_buf ), CM_DIGIT_MODE_8BIT_ASCII );

  #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN
  /* Below FDN check code leg can be removed once the modem call control feature is turned on */
  if ( !qcril_cm_fdn_check_is_passed( instance_id, modem_id, ss_buf, strlen( ss_buf ) ) )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_FDN_CHECK_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }
  #endif /* #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN*/

  qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                               QCRIL_EVT_CM_SUPS_INTERROGATE_CONF, &u_info, &reqlist_entry ); 
  reqlist_entry.valid_sub_id = TRUE;
  reqlist_entry.sub_id = req_info_ptr->ss_ref;
  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
  {
    /* Fail to add to ReqList */
    return;
  }

  user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );
  QCRIL_SNPRINTF( details, sizeof( details ), "%s ss_ref %d", facility_name, ss_data.interr.ss_ref );

  QCRIL_LOG_RPC2( modem_id, cm_sups_cmd_interrogate_api_name, details );
  cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_interrogate_func( 
                                                                           #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                           qcril_cm_supsvc_command_callback_exten,
                                                                           #else
                                                                           qcril_cm_supsvc_command_callback,
                                                                           #endif
                                                                           ( void *) user_data,
                                                                           i_ptr->client_info[ modem_id ].client_id,
                                                                           &ss_data.interr
                                                                           #ifdef FEATURE_QCRIL_DSDS
                                                                           , &dial_digits
                                                                           , CM_ORIG_CLIENT_CATEG_USER
                                                                           , FALSE 
                                                                           , as_id
                                                                           #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                           , &dial_digits
                                                                           , CM_ORIG_CLIENT_CATEG_USER
                                                                           #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                           , &dial_digits
                                                                           , FALSE
                                                                           #endif
                                                                         );
  if ( !cm_result )
  {
    QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_interrogate() \n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_query_facility_lock() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_send_ussd

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SEND_USSD.
    Used to send MO USSD request or send response for MT USSD request

    Input:
    const char * containing the USSD request in UTF-8 format

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_send_ussd
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  uint32 user_data;
  const char * rcvd_ussd_str = (const char *) params_ptr->data; /* received ussd string */
  char ussd_str[ MAX_USS_CHAR ];
  cm_num_s_type dial_digits;
  qcril_reqlist_public_type info_ptr;
  cm_uss_params_s_type uss_cmd_parms;
  cm_uss_res_params_s_type uss_res_parms;
  qcril_reqlist_u_type u_info;
  qcril_cm_ss_type *req_info_ptr = &u_info.cm.info.ss_info;
  boolean cm_result;
  int ussd_str_len = 0;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  byte data_coding_scheme = QCRIL_CM_SS_USSD_DCS_UNSPECIFIED;
  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_sups_cmd_uss_res_api_name = "cm_sups_cmd_uss_res_per_subs(uss_res)";
  char *cm_sups_cmd_process_uss_api_name = "cm_sups_cmd_process_uss_per_subs(uss_req)";
  #else
  char *cm_sups_cmd_uss_res_api_name = "cm_sups_cmd_uss_res(uss_res)";
  char *cm_sups_cmd_process_uss_api_name = "cm_sups_cmd_process_uss(uss_req)";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  memset( &uss_cmd_parms, 0, sizeof( uss_cmd_parms ) );
  memset( &uss_res_parms, 0, sizeof( uss_res_parms ) );
  memset( &info_ptr, 0, sizeof( info_ptr ) );
  memset( ussd_str, 0, MAX_USS_CHAR );

  if ( ( params_ptr->data == NULL ) || ( params_ptr->datalen == 0 ) )
  {
    QCRIL_LOG_ERROR( "%s", "received RIL_REQUEST_SEND_USSD with USSD message set to NULL\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_LOG_DEBUG( "USSD string received in UTF8 format = %s length = %d\n", rcvd_ussd_str, strlen( rcvd_ussd_str ) );

  if ( qcril_cm_ss_UssdStringIsAscii( rcvd_ussd_str ) )
  {
    QCRIL_LOG_RPC( modem_id, "qcril_cm_util_ascii_to_gsm_alphabet_func()", "", "" );
    ussd_str_len = qcril_cm_util_ascii_to_gsm_alphabet( (byte *) ussd_str, 
                                                        (const byte *) rcvd_ussd_str, 
                                                        strlen( rcvd_ussd_str ) );
    QCRIL_LOG_DEBUG( "%s", "USSD string is in ASCII format, converting to 7BIT  format" );
  }
  else                                                  
  {
    qcril_cm_ss_convert_utf8_to_ucs2( rcvd_ussd_str, ussd_str, &ussd_str_len );

    if ( ussd_str_len == 0 )
    {
      QCRIL_LOG_DEBUG( "%s", "Illegal UTF8 charecters received\n" );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
      return;
    }
    data_coding_scheme = QCRIL_CM_SS_USSD_DCS_UCS2;
  }

  ussd_str[ ussd_str_len ] = '\0';
  QCRIL_LOG_DEBUG( "USSD string after conversion = %s length = %d\n", ussd_str, strlen( ussd_str ) );

  if ( ussd_str_len > MAX_USS_CHAR )
  {
    QCRIL_LOG_DEBUG( "%s", "converted USSD charecters exceed maximum length\n" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  req_info_ptr->ss_ref = qcril_cm_ss_get_ss_ref();;

  /* case where RIL is responding for MT USSD request */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_SUPS_USS_IND, &info_ptr ) == E_SUCCESS )
  {
    uss_res_parms.invoke_id = info_ptr.sub.cm.info.ss_info.ss_ref;
    if ( params_ptr->data == NULL )
    {
      uss_res_parms.uss_res_data.data_type = (cm_ss_conf_e_type) CM_USS_RES_SS_ERROR;
      uss_res_parms.uss_res_data.data.cm_ss_error.present = TRUE;
      /* from mn_cm_exp.h "ERROR_CODE_TAG"*/
      uss_res_parms.uss_res_data.data.cm_ss_error.error_code_tag =  0x02;
      uss_res_parms.uss_res_data.data.cm_ss_error.error_code = 27;
      uss_res_parms.uss_res_data.data.cm_ss_error.parameter.cm_absent_subscriber_error.present = TRUE;
      uss_res_parms.uss_res_data.data.cm_ss_error.parameter.cm_absent_subscriber_error.mwd_set = TRUE;
    }
    else
    {
      uss_res_parms.uss_res_data.data_type =  (cm_ss_conf_e_type) CM_USS_RES_SS_DATA;
      uss_res_parms.uss_res_data.data.uss_data.present = TRUE;
      uss_res_parms.uss_res_data.data.uss_data.uss_data_coding_scheme = data_coding_scheme;
      uss_res_parms.uss_res_data.data.uss_data.size = (byte)ussd_str_len;
      memcpy( uss_res_parms.uss_res_data.data.uss_data.ussData, ussd_str, (byte) ussd_str_len );
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, info_ptr.req_id );

    if ( params_ptr->data == NULL )
    {
      QCRIL_LOG_RPC( modem_id, cm_sups_cmd_uss_res_api_name, "ERROR invoke_id", uss_res_parms.invoke_id );
    }
    else
    {
      QCRIL_LOG_RPC( modem_id, cm_sups_cmd_uss_res_api_name, "invoke_id", uss_res_parms.invoke_id );
    }

    cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_uss_res_func( qcril_cm_supsvc_command_callback,
                                                                         (void *) user_data,
                                                                         i_ptr->client_info[ modem_id ].client_id,
                                                                         &uss_res_parms 
                                                                         #ifdef FEATURE_QCRIL_DSDS
                                                                         , as_id
                                                                         #endif /* FEATURE_QCRIL_DSDS */
                                                                       );
    if ( cm_result )
    {
      /* remove the entry of the indication from the list as we are sending the response*/
      qcril_reqlist_free( instance_id, info_ptr.t );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
      qcril_send_request_response( &resp );
    }
    else
    {
      QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_uss_res() \n");
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  }
  else /* case where RIL is initiating an MO USSD request */
  {
    uss_cmd_parms.ss_ref = req_info_ptr->ss_ref;
    uss_cmd_parms.uss_data.present = TRUE;

    if (data_coding_scheme == QCRIL_CM_SS_USSD_DCS_UCS2 )
    {
      uss_cmd_parms.uss_data.size =  (byte) ussd_str_len;
      memcpy( uss_cmd_parms.uss_data.ussData, ussd_str, uss_cmd_parms.uss_data.size);
    }
    else
    {
      uss_cmd_parms.uss_data.size =  (byte) strlen(rcvd_ussd_str);
      memcpy( uss_cmd_parms.uss_data.ussData, rcvd_ussd_str, uss_cmd_parms.uss_data.size );
    }

    QCRIL_ASSERT( uss_cmd_parms.uss_data.size < MAX_USS_CHAR );
    uss_cmd_parms.uss_data.uss_data_coding_scheme = data_coding_scheme;

    qcril_cm_api_funcs[ modem_id ].cm_num_fill_func( &dial_digits, (byte *)rcvd_ussd_str, (byte)uss_cmd_parms.uss_data.size, 
                                                     CM_DIGIT_MODE_8BIT_ASCII );

  #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN
    /* Below FDN check code leg can be removed once the modem call control feature is turned on */
    /* USS data is comprised of digits 0-9 along with one or more instances of * and a # which are within first 128 characters 
       of ASCII format. UTF-8 uses single octet encoding for first 128 characters. So UTF-8 is similar to ASCII for the first 
       128 characters. */
    if ( !qcril_cm_fdn_check_is_passed( instance_id, modem_id, rcvd_ussd_str, strlen(rcvd_ussd_str) ) )
    {
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_FDN_CHECK_FAILURE, &resp );
      qcril_send_request_response( &resp );
      return;
    }
  #endif /* #ifndef FEATURE_QCRIL_SUPS_CC_EXTEN*/

    qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_CALLBACK, 
                                 QCRIL_EVT_CM_SUPS_PROCESS_USS_CONF, &u_info, &reqlist_entry ); 
    reqlist_entry.valid_sub_id = TRUE;
    reqlist_entry.sub_id = req_info_ptr->ss_ref;
    if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
    {
      /* Fail to add to ReqList */
      return;
    }

    user_data = QCRIL_COMPOSE_USER_DATA( instance_id, modem_id, reqlist_entry.req_id );

    QCRIL_LOG_RPC( modem_id, cm_sups_cmd_process_uss_api_name, "invoke_id", uss_res_parms.invoke_id );
    cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_process_uss_func( 
                                                                             #ifdef FEATURE_QCRIL_SUPS_CC_EXTEN
                                                                             qcril_cm_supsvc_command_callback_exten,
                                                                             #else
                                                                             qcril_cm_supsvc_command_callback,
                                                                             #endif
                                                                             (void *) user_data,
                                                                             i_ptr->client_info[ modem_id ].client_id,
                                                                             &uss_cmd_parms
                                                                             #ifdef FEATURE_QCRIL_DSDS
                                                                             , &dial_digits 
                                                                             , CM_ORIG_CLIENT_CATEG_USER
                                                                             , FALSE
                                                                             , as_id
                                                                             #elif defined( FEATURE_QCRIL_SUPS_CC_EXTEN )
                                                                             , &dial_digits
                                                                             , CM_ORIG_CLIENT_CATEG_USER
                                                                             #elif !defined( FEATURE_QCRIL_SUPS_CC_UNSUPP )
                                                                             , &dial_digits
                                                                             , FALSE
                                                                             #endif
                                                                           );
    if ( !cm_result )
    {
      QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_deactivate() \n" );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  }

} /* qcril_cm_supsvc_request_send_ussd() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_cancel_ussd

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_CANCEL_USSD.
    Used for cancelling/releasing the ongoing USSD session

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_cancel_ussd
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  qcril_reqlist_public_type info_ptr;
  cm_release_ss_params_s_type  release_cmd_parms;
  boolean cm_result = TRUE;
  char *ss_name;
  cm_num_s_type dial_digits;
  qcril_request_resp_params_type resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_sups_cmd_release_api_name = "cm_sups_cmd_release_per_subs()";
  #else
  char *cm_sups_cmd_release_api_name = "cm_sups_cmd_release()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  #ifdef FEATURE_QCRIL_DSDS
  /* Lookup as_id */
  if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
  {
    QCRIL_LOG_DEBUG( "%s\n", "as_id not available, Ignore request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }  
  #endif /* FEATURE_QCRIL_DSDS */

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  memset( &release_cmd_parms, 0, sizeof( cm_release_ss_params_s_type ) );

  if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_SUPS_PROCESS_USS_CONF, &info_ptr ) == E_SUCCESS )
  {
    release_cmd_parms.ss_oper = qcril_cm_ss_processUnstructuredSS_Request;
    ss_name = "ProcessUnstructuredReq";
  }
  else if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_SUPS_USS_IND, &info_ptr ) == E_SUCCESS )
  {
    release_cmd_parms.ss_oper = qcril_cm_ss_unstructuredSS_Request;
    ss_name = "UnstructuredReq";
  }
  else if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_SUPS_USS_NOTIFY_IND, &info_ptr ) == E_SUCCESS )
  {
    release_cmd_parms.ss_oper = qcril_cm_ss_unstructuredSS_Notify;
    ss_name = "UnstructuredNotify";
  }
  else
  {
    QCRIL_LOG_DEBUG( "%s", " RIL_REQUEST_CANCEL_USSD received when none of them are present\n" );
  }

  if ( (int) info_ptr.pending_event_id > 0 )
  {
    release_cmd_parms.ss_ref = info_ptr.sub.cm.info.ss_info.ss_ref;

    memset( &dial_digits, 0, sizeof( dial_digits ) );

    QCRIL_LOG_RPC2( modem_id, cm_sups_cmd_release_api_name, ss_name );
    cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_release_func( NULL,
                                                                         NULL,
                                                                         i_ptr->client_info[ modem_id ].client_id,
                                                                         &release_cmd_parms
                                                                         #ifdef FEATURE_QCRIL_DSDS
                                                                         , &dial_digits 
                                                                         , TRUE
                                                                         , as_id
                                                                         #endif /* FEATURE_QCRIL_DSDS */
                                                                       );
    if ( cm_result )
    {
      if ( release_cmd_parms.ss_oper == qcril_cm_ss_processUnstructuredSS_Request )
      {
        if( !info_ptr.sub.cm.info.ss_info.req_from_other_client )
        {
           /* send success to match with the android design for blocking the multiple rejected pop ups */
           qcril_default_request_resp_params( instance_id, info_ptr.t, info_ptr.request, RIL_E_SUCCESS, &resp );
           qcril_send_request_response( &resp );
        }
      }
  
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
      qcril_send_request_response( &resp );
    }
    else
    {
      QCRIL_LOG_ERROR( "%s", "CM returned error for cm_sups_cmd_release() \n" );
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
      qcril_send_request_response( &resp );
    }
  }
  else
  {
    QCRIL_LOG_ERROR( "%s", "Sending failure as response for RIL_REQUEST_CANCEL_USSD request" );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_cancel_ussd() */


/*===========================================================================

  FUNCTION:  qcril_cm_supsvc_request_set_supp_svc_notification

===========================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION.
    Enables/disables supplementary service related notifications from the network.
    Notifications are reported via RIL_UNSOL_SUPP_SVC_NOTIFICATION

    All the events required for notification are either registered or /de-registered
    based on the input.

    Input Paramerers:
    const int *
    ((const int *)data)[0] to enable or disable the notifications.

    @return:
    None
*/
/*=========================================================================*/
void qcril_cm_supsvc_request_set_supp_svc_notification
( 
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  #ifndef FEATURE_ICS
  qcril_radio_tech_family_e_type voice_radio_tech;
  #else
  qcril_radio_tech_e_type        voice_radio_tech;
  #endif
  int *in_data_ptr;
  int supps_notification;
  uint16 i = 0;
  qcril_request_resp_params_type resp;

  cm_call_event_e_type call_event_list[ 12 ] = {
    CM_CALL_EVENT_ORIG_FWD_STATUS,
    CM_CALL_EVENT_CALL_BEING_FORWARDED,
    CM_CALL_EVENT_CALL_IS_WAITING,
    CM_CALL_EVENT_CALL_BARRED,
    CM_CALL_EVENT_INCOM_FWD_CALL,
    CM_CALL_EVENT_CUG_INFO_RECEIVED,
    CM_CALL_EVENT_CALL_ON_HOLD,
    CM_CALL_EVENT_CALL_RETRIEVED,
    CM_CALL_EVENT_CALL_FORWARDED,
    CM_CALL_EVENT_CALL_RESTRICTED,
    CM_CALL_EVENT_TRANSFERRED_CALL,
    CM_CALL_EVENT_CALL_DEFLECTION
  };

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  in_data_ptr = (int *)params_ptr->data;
  QCRIL_ASSERT( in_data_ptr != NULL );
  supps_notification = in_data_ptr[0];
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_DEBUG( "RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION %s\n",
                   ( ( supps_notification == (int) QCRIL_CM_SS_ENABLE_NOTIFICATION) ? "Enable" : "Disable" ) );

  /* Lookup the modem that should provide the service */
  if ( qcril_arb_query_voice_srv_modem_id( instance_id, &modem_id, &voice_radio_tech ) != E_SUCCESS )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );

  if ( supps_notification == (int) QCRIL_CM_SS_ENABLE_NOTIFICATION )
  {
    /* Register for Call events */
    for ( i = 0; i < QCRIL_ARR_SIZE( call_event_list ); i++ )
    {
      QCRIL_LOG_RPC2( modem_id, "cm_mm_client_call_reg(CM_CLIENT_EVENT_REG)", call_event_list_names[ i ] );
      if ( qcril_cm_api_funcs[ modem_id ].cm_mm_client_call_reg_func( i_ptr->client_info[ modem_id ].client_id,
                                                                      qcril_cm_api_callbacks[ modem_id ].call_event_callback_func,
                                                                      CM_CLIENT_EVENT_REG,
                                                                      call_event_list[ i ],
                                                                      call_event_list[ i ],
                                                                      NULL
                                                                   ) != CM_CLIENT_OK )
      {
        QCRIL_LOG_ERROR( "Fail to register CM Call event %d\n", call_event_list[ i ] );
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        return;
      }
    }

    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else if ( supps_notification == (int) QCRIl_CM_SS_DISABLE_NOTIFICATION )
  {
    /* Register for Call events */
    for ( i = 0; i < QCRIL_ARR_SIZE( call_event_list ); i++ )
    {
      QCRIL_LOG_RPC2( modem_id, "cm_mm_client_call_reg(CM_CLIENT_EVENT_DEREG)", call_event_list_names[ i ] );
      if ( qcril_cm_api_funcs[ modem_id ].cm_mm_client_call_reg_func( i_ptr->client_info[ modem_id ].client_id,
                                                                      qcril_cm_api_callbacks[ modem_id ].call_event_callback_func,
                                                                      CM_CLIENT_EVENT_DEREG,
                                                                      call_event_list[ i ],
                                                                      call_event_list[ i ],
                                                                      NULL
                                                                    ) != CM_CLIENT_OK )
      {
        QCRIL_LOG_ERROR( "Fail to register CM Call event %d\n", call_event_list[ i ] );
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
        return;
      }
    }

    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    QCRIL_LOG_ERROR( "%s", "received invalid params in RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION\n");
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_request_set_supp_svc_notification() */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_ack

===========================================================================*/
/*!
    @brief
    Handle CM_SUPS_EVENT_ACTIVATE
           CM_SUPS_EVENT_REGISTER
           CM_SUPS_EVENT_ERASE
           CM_SUPS_EVENT_DEACTIVATE
           CM_SUPS_EVENT_INTERROGATE
           CM_SUPS_EVENT_REG_PASSWORD

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_ack
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_sups_info_s_type *cm_info;
  qcril_reqlist_public_type list_info;
  qcril_cm_ss_type *ss_list_info;
  qcril_request_resp_params_type resp;
  qcril_unsol_resp_params_type unsol_resp;
  char buf_str[QCRIL_CM_ALPHA_TEXT_MAX_SIZE];
  int utf8_len = 0;
  byte alpha_dcs;
  boolean is_alpha_dcs_valid = TRUE;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  cm_info = (cm_sups_info_s_type *)(params_ptr->data);
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  QCRIL_LOG_DEBUG( "%s\n", __func__ );

  if ( qcril_reqlist_query_by_sub_id( instance_id, modem_id, cm_info->ss_ref, &list_info )
             != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "None of entry requested for sups code %d \n", cm_info->ss_code );
    return;
  }

  ss_list_info = &list_info.sub.cm.info.ss_info;

  QCRIL_LOG_DEBUG( "Sups info success = %d confirmation type = %d requested ss_code = %d received ss_code = %d call_control_result = %d\n",
                   cm_info->ss_success, cm_info->conf_type, ss_list_info->ss_code,
                   cm_info->ss_code, cm_info->mod_ss_params.call_control_result );

  if ( ss_list_info->ss_ref != cm_info->ss_ref )
  {
    QCRIL_LOG_ERROR( "%s", "QCRIL_EVT_CM_SUPS_ACK with incorrect ss_ref is receiveds\n" );
    return;
  }

  if ( !cm_info->ss_success )
  {
    QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer\n" );
  }

  // Check if SS request got modified due to STK CC.
  // If modified, return failure (RIL_E_SS_MODIFIED_TO_SS) for the original request.
  if ( cm_info->mod_ss_params.call_control_result == CM_CC_RESULT_ALLOWED_BUT_MODIFIED_TO_SS )
  {
    qcril_default_request_resp_params( instance_id, list_info.t,
                    list_info.request, RIL_E_SS_MODIFIED_TO_SS, &resp );
    qcril_send_request_response( &resp );
  }

  if ( cm_info->cc_result_alpha.len > 0 )
  {
    memset(buf_str, '\0' , sizeof(buf_str));
    QCRIL_LOG_DEBUG( "Alpha received! DCS = %d", cm_info->cc_result_alpha.dcs );
    switch ( cm_info->cc_result_alpha.dcs )
    {
      case QCRIL_CM_SS_USSD_DCS_8_BIT_MASK:
      alpha_dcs = QCRIL_CM_SS_ALPHA_DCS_8_BIT;
      break;

      case QCRIL_CM_SS_USSD_DCS_UCS2_MASK:
      alpha_dcs = QCRIL_CM_SS_ALPHA_DCS_UCS2;
      break;

      default:
      is_alpha_dcs_valid = FALSE;
      break;
    }
    if ( is_alpha_dcs_valid == TRUE )
    {
      utf8_len = qcril_cm_ss_convert_ussd_string_to_utf8( alpha_dcs,
                                            cm_info->cc_result_alpha.len,
                                            cm_info->cc_result_alpha.buf, buf_str );
    }
    else
    {
      QCRIL_LOG_DEBUG ("%s","Invalid Alpha DCS!");
    }
    if ( *buf_str )
    {
      qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_STK_CC_ALPHA_NOTIFY, &unsol_resp );
      unsol_resp.resp_pkt    = (void*)buf_str;
      unsol_resp.resp_len    = sizeof( char* );

      qcril_send_unsol_response( &unsol_resp );
    }
  }

} /* qcril_cm_supsvc_event_ack */


void qcril_cm_stk_cc_supsvc_response
( int instance_id,
  RIL_SsServiceType ss_service_type,
  RIL_SsRequestType ss_request_type,
  int ss_info[],
  qcril_cm_ss_callforwd_info_param_u_type cf_data[],
  int info_len
)
{
  qcril_unsol_resp_params_type unsol_resp;
  RIL_StkCcUnsolSsResponse  ril_ss_response;
  int idx = 0;

  memset( &ril_ss_response, 0, sizeof( ril_ss_response ) );

  ril_ss_response.serviceType = ss_service_type;
  ril_ss_response.requestType = ss_request_type;
  ril_ss_response.serviceClass =  QCRIL_CM_SS_CLASS_VOICE;

  if ( ss_request_type == SS_INTERROGATION )
  {
    switch ( ss_service_type )
    {
      case SS_CFU:
      case SS_CF_BUSY:
      case SS_CF_NO_REPLY:
      case SS_CF_NOT_REACHABLE:
      case SS_CF_ALL:
      case SS_CF_ALL_CONDITIONAL:

        for ( idx = 0; idx < info_len; idx++ )
        {
          ril_ss_response.cfData.cfInfo[idx].status = cf_data[idx].status;
          ril_ss_response.cfData.cfInfo[idx].reason = cf_data[idx].reason;
          ril_ss_response.cfData.cfInfo[idx].serviceClass = cf_data[idx].service_class;
          ril_ss_response.cfData.cfInfo[idx].number = cf_data[idx].number;
          ril_ss_response.cfData.cfInfo[idx].toa = cf_data[idx].toa;
          ril_ss_response.cfData.cfInfo[idx].timeSeconds = cf_data[idx].no_reply_timer;
        }
        ril_ss_response.cfData.numValidIndexes = info_len;
        break;

      default:
        for ( idx = 0; idx < info_len; idx++ )
        {
          ril_ss_response.ssInfo[idx] = ss_info[idx];
        }
        break;
    }
  }

  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_ON_SS, &unsol_resp );
  unsol_resp.resp_pkt = ( void * ) &ril_ss_response;
  unsol_resp.resp_len = sizeof( ril_ss_response );
  qcril_send_unsol_response( &unsol_resp );
}


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_activate_conf

===========================================================================*/
/*!
    @brief
    Handle CM_SUPS_EVENT_ACTIVATE_CONF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_activate_conf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_sups_info_s_type *cm_info;
  qcril_reqlist_public_type list_info;
  qcril_cm_ss_type *ss_list_info;
  boolean success = FALSE;
  qcril_request_resp_params_type resp;
  RIL_SsServiceType ss_service_type;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  cm_info = (cm_sups_info_s_type *)(params_ptr->data);
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  if ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, (uint32) QCRIL_EVT_CM_SUPS_ACTIVATE_CONF, 
                                                cm_info->ss_ref, &list_info ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "None of entry is waiting for QCRIL_EVT_CM_SUPS_ACTIVATE_CONF. This is probably STK CC response.\n" );
    if ( cm_info->ss_success && ( cm_info->conf_type != CC_CAUSE_INFO ) &&
            ( cm_info->conf_type != SS_ERROR_INFO ))
    {
      ss_service_type = qcril_cm_ss_get_service_type ( cm_info->ss_code );
      qcril_cm_stk_cc_supsvc_response ( instance_id, ss_service_type, SS_ACTIVATION,
                      NULL, NULL, 0);
    }
    else
    {
      QCRIL_LOG_ERROR( "%s", "STK CC command failed!");
    }
    return;
  }

  ss_list_info = &list_info.sub.cm.info.ss_info;

  QCRIL_LOG_DEBUG( "Sups info success = %d confirmation type = %d ss_code = %d\n",
                   cm_info->ss_success, cm_info->conf_type, ss_list_info->ss_code );
  
  if ( ss_list_info->ss_ref != cm_info->ss_ref )
  {
    QCRIL_LOG_ERROR( "%s", "QCRIL_EVT_CM_SUPS_ACTIVATE_CONF with incorrect ss_ref is receiveds\n" );
    return;
  }

  if ( !cm_info->ss_success )
  {
    QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer\n" );
    success = FALSE;
  }
  else
  {
    switch ( ss_list_info->ss_code )
    {
      case qcril_cm_ss_cw:
      case qcril_cm_ss_cfu:
      case qcril_cm_ss_cfb:
      case qcril_cm_ss_cfnry:
      case qcril_cm_ss_cfnrc:
      case qcril_cm_ss_allForwardingSS:
      case qcril_cm_ss_allCondForwardingSS:
        switch(cm_info->conf_type)
        {
          /* Success cases */
          case FWD_INFO:
          case SS_DATA_INFO:
          case NO_INFO:  /* special case with no parameter info */
            QCRIL_LOG_DEBUG( "SupS confirmation successful: %d \n", cm_info->conf_type );
            success = TRUE;
            break;

          case CC_CAUSE_INFO:    /* Lower layer faliure in protocol stack */
            QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer \n" );
            success = FALSE;
            break;

          case SS_ERROR_INFO:    /* Network rejected request */
          default:
            QCRIL_LOG_ERROR( "%s", "Network rejected SupS request \n" );
            success = FALSE;
            break;
        }
        break;

      case qcril_cm_ss_baoc:
      case qcril_cm_ss_boic:
      case qcril_cm_ss_boicExHC:
      case qcril_cm_ss_baic:
      case qcril_cm_ss_bicRoam:
        switch ( cm_info->conf_type )
        {
          /* Success cases */
          case CALL_BARRING_INFO:
          case NO_INFO:  /* special case with no parameter info */
            QCRIL_LOG_DEBUG( "SupS confirmation successful: %d \n", cm_info->conf_type );
            success = TRUE;
            break;

          case CC_CAUSE_INFO:    /* Lower layer faliure in protocol stack */
            QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer \n" );
            success = FALSE;
            break;

          case SS_ERROR_INFO:    /* Network rejected request */
            default:
            QCRIL_LOG_ERROR( "%s", "Network rejected SupS request \n" );
            success = FALSE;
            break;
        }
        break;

      default:
        break;         
    } /* end switch */
  }

  QCRIL_LOG_DEBUG( "sending response for QCRIL_EVT_CM_SUPS_ACTIVATE_CONF as success = %d\n", success );

  if ( success )
  {
    qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_event_activate_conf */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_deactivate_conf

===========================================================================*/
/*!
    @brief
    Handle CM_SUPS_EVENT_DEACTIVATE_CONF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_deactivate_conf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_sups_info_s_type *cm_info;
  qcril_reqlist_public_type list_info;
  qcril_cm_ss_type *ss_list_info;
  boolean success = FALSE;
  qcril_request_resp_params_type resp;
  RIL_SsServiceType ss_service_type;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  cm_info = (cm_sups_info_s_type *)(params_ptr->data);
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  if ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, (uint32) QCRIL_EVT_CM_SUPS_DEACTIVATE_CONF, cm_info->ss_ref, 
                                                &list_info ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "None of entry is waiting for QCRIL_EVT_CM_SUPS_ACTIVATE_CONF. This is probably STK CC response.\n" );
    if ( cm_info->ss_success && ( cm_info->conf_type != CC_CAUSE_INFO ) &&
            ( cm_info->conf_type != SS_ERROR_INFO ))
    {
      ss_service_type = qcril_cm_ss_get_service_type ( cm_info->ss_code );
      qcril_cm_stk_cc_supsvc_response ( instance_id, ss_service_type, SS_DEACTIVATION,
                      NULL, NULL, 0);
    }
    else
    {
      QCRIL_LOG_ERROR( "%s", "STK CC command failed!");
    }
    return;
  }

  ss_list_info = &list_info.sub.cm.info.ss_info;

  if ( ss_list_info->ss_ref != cm_info->ss_ref )
  {
    QCRIL_LOG_ERROR( "%s", "QCRIL_EVT_CM_SUPS_ACTIVATE_CONF with incorrect ss_ref is receiveds\n" );
    return;
  }

  if ( !cm_info->ss_success )
  {
    QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer\n" );
    success = FALSE;
  }
  else
  {
    switch ( ss_list_info->ss_code )
    {
      case qcril_cm_ss_cw:
      case qcril_cm_ss_cfu:
      case qcril_cm_ss_cfb:
      case qcril_cm_ss_cfnry:
      case qcril_cm_ss_cfnrc:
      case qcril_cm_ss_allForwardingSS:
      case qcril_cm_ss_allCondForwardingSS:
        switch ( cm_info->conf_type )
        {
          /* Success cases */
          case FWD_INFO:
          case SS_DATA_INFO:
          case NO_INFO:  /* special case with no parameter info */
            QCRIL_LOG_DEBUG( "SupS confirmation successful: %d \n", cm_info->conf_type );
            success = TRUE;
            break;

          case CC_CAUSE_INFO:    /* Lower layer faliure in protocol stack */
            QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer \n" );
            success = FALSE;
            break;

          case SS_ERROR_INFO:    /* Network rejected request */
          default:
            QCRIL_LOG_ERROR( "%s", "Network rejected SupS request \n" );
            success = FALSE;
            break;
        }
        break;

      case qcril_cm_ss_baoc:
      case qcril_cm_ss_boic:
      case qcril_cm_ss_boicExHC:
      case qcril_cm_ss_baic:
      case qcril_cm_ss_bicRoam:
      case qcril_cm_ss_allCallRestrictionSS:
      case qcril_cm_ss_barringOfOutgoingCalls:       
      case qcril_cm_ss_barringOfIncomingCalls:       
        switch ( cm_info->conf_type )
        {
          /* Success cases */
          case CALL_BARRING_INFO:
          case NO_INFO:             /* special case with no parameter info */
            QCRIL_LOG_DEBUG( "SupS confirmation successful: %d \n", cm_info->conf_type );
            success = TRUE;
            break;

          case CC_CAUSE_INFO:    /* Lower layer faliure in protocol stack */
            QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer \n" );
            success = FALSE;
            break;

          case SS_ERROR_INFO:    /* Network rejected request */
          default:
            QCRIL_LOG_ERROR( "%s", "Network rejected SupS request \n" );
            success = FALSE;
            break;
        }
        break;

      default:
        break;
    }
  }

  if ( success )
  {
    qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_event_deactivate_conf */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_erase_conf

===========================================================================*/
/*!
    @brief
    Handle CM_SUPS_EVENT_ERASE_CONF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_erase_conf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_sups_info_s_type *cm_info;
  qcril_reqlist_public_type list_info;
  qcril_cm_ss_type *ss_list_info;
  boolean success = FALSE;
  qcril_request_resp_params_type resp;
  RIL_SsServiceType ss_service_type;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  cm_info = (cm_sups_info_s_type *)(params_ptr->data);
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  if ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, (uint32) QCRIL_EVT_CM_SUPS_ERASE_CONF, 
                                                cm_info->ss_ref, &list_info ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "None of entry is waiting for QCRIL_EVT_CM_SUPS_ERASE_CONF. This is probably STK CC response.\n" );
    if ( cm_info->ss_success && ( cm_info->conf_type != CC_CAUSE_INFO ) &&
            ( cm_info->conf_type != SS_ERROR_INFO ))
    {
      ss_service_type = qcril_cm_ss_get_service_type ( cm_info->ss_code );
      qcril_cm_stk_cc_supsvc_response ( instance_id, ss_service_type, SS_ERASURE,
                      NULL, NULL, 0);
    }
    else
    {
      QCRIL_LOG_ERROR( "%s", "STK CC command failed!");
    }
    return;
  }

  ss_list_info = &list_info.sub.cm.info.ss_info;

  QCRIL_LOG_DEBUG( "Sups info success = %d confirmation type = %d ss_code = %d\n",
                   cm_info->ss_success, cm_info->conf_type, ss_list_info->ss_code );
  
  if ( ss_list_info->ss_ref != cm_info->ss_ref )
  {
    QCRIL_LOG_ERROR( "%s", "QCRIL_EVT_CM_SUPS_ERASE_CONF with incorrect ss_ref is receiveds\n");
    return;
  }

  if ( !cm_info->ss_success )
  {
    QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer\n" );
    success = FALSE;
  }
  else
  {
    switch ( ss_list_info->ss_code )
    {
      case qcril_cm_ss_cfu:
      case qcril_cm_ss_cfb:
      case qcril_cm_ss_cfnry:
      case qcril_cm_ss_cfnrc:
      case qcril_cm_ss_allForwardingSS:
      case qcril_cm_ss_allCondForwardingSS:
        switch ( cm_info->conf_type )
        {
          /* Success cases */
          case FWD_INFO:
          case NO_INFO:  /* special case with no parameter info */
            QCRIL_LOG_DEBUG( "SupS confirmation successful: %d \n", cm_info->conf_type );
            success = TRUE;
            break;

          case CC_CAUSE_INFO:   /* Network rejected request */
            QCRIL_LOG_ERROR( "%s", "Network rejected SupS request \n" );
            success = FALSE;
            break;

          case SS_ERROR_INFO:   /* Lower layer faliure in protocol stack */
          default:
            QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer \n" );
            success = FALSE;
            break;
        }
       break;

      default:
        break;
    }
  }

  if ( success )
  {
    qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_event_erase_conf */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_interrogate_conf

===========================================================================*/
/*!
    @brief
    Handle CM_SUPS_EVENT_INTERROGATE_CONF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_interrogate_conf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  cm_sups_info_s_type *cm_info;
  qcril_reqlist_public_type list_info;
  qcril_cm_ss_type *ss_list_info;
  boolean success = FALSE, stk_cc_response = FALSE;
  int count = 0, num_active_classes = 0, ss_code;
  basic_service_T *bsg_list_ptr;
  cli_restriction_info_T *cli_restriction_info;
  uint32 bs_class = 0;
  qcril_cm_ss_clir_status_e_type  clir_interrogate_status = QCRIL_CM_SS_CLIR_SRV_NOT_PROVISIONED;
  uint8 status = 0;
  qcril_request_resp_params_type resp;
  char args[ PROPERTY_VALUE_MAX ];
  RIL_SsServiceType ss_service_type;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  i_ptr = &qcril_cm[ instance_id ];
  cm_info = (cm_sups_info_s_type *)(params_ptr->data);
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  if ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, (uint32) QCRIL_EVT_CM_SUPS_INTERROGATE_CONF, cm_info->ss_ref, 
                                                &list_info) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "None of entry is waiting for QCRIL_EVT_CM_SUPS_INTERROGATE_CONF. This is probably STK CC response.\n" );
    if ( cm_info->ss_success && ( cm_info->conf_type != CC_CAUSE_INFO ) &&
            ( cm_info->conf_type != SS_ERROR_INFO ))
    {
      ss_service_type = qcril_cm_ss_get_service_type ( cm_info->ss_code );
      stk_cc_response = TRUE;
    }
    else
    {
      QCRIL_LOG_ERROR( "%s", "STK CC command failed!");
      return;
    }
  }

  QCRIL_LOG_DEBUG( "Sups info success = %d and confirmation type = %d \n", cm_info->ss_success, cm_info->conf_type );

  if ( stk_cc_response == FALSE )
  {
    ss_list_info = &list_info.sub.cm.info.ss_info;

    QCRIL_LOG_DEBUG( "stored ss code = %d\n", ss_list_info->ss_code );

    if ( ss_list_info->ss_ref != cm_info->ss_ref )
    {
      QCRIL_LOG_ERROR( "%s", "QCRIL_EVT_CM_SUPS_INTERROGATE_CONF with incorrect ss_ref is received \n");
      return;
    }
  }

  if ( ( !cm_info->ss_success ) && ( stk_cc_response == FALSE ) )
  {
    QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer\n");
    qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
    return;
  }

  if ( stk_cc_response == FALSE )
  {
    ss_code = ss_list_info->ss_code;
  }
  else
  {
    ss_code = cm_info->ss_code;
  }

  switch ( ss_code )
  {
    case qcril_cm_ss_cw:
    case qcril_cm_ss_baoc:
    case qcril_cm_ss_boic:
    case qcril_cm_ss_boicExHC:
    case qcril_cm_ss_baic:
    case qcril_cm_ss_bicRoam:
    case qcril_cm_ss_allCallRestrictionSS:
    case qcril_cm_ss_barringOfOutgoingCalls:       
    case qcril_cm_ss_barringOfIncomingCalls:  
    {
      int response[ 2 ];

      switch ( cm_info->conf_type )
      {

        /* Success cases */
        case BSG_LIST_INFO:
          while ( cm_info->bsg_list.list_length > count )
          {
            bsg_list_ptr = &cm_info->bsg_list.list[ count ];
            if ( bsg_list_ptr->present )
            {
              bs_class += qcril_cm_ss_get_service_class( bsg_list_ptr->code_type, bsg_list_ptr->bs_code );
            }

            count++;
          }

          response[ 0 ] = TRUE;
          response[ 1 ] = (int) bs_class;
          success = TRUE;
          break;

        case SS_STATUS_INFO:
          /*status info received with ss_active set to TRUE is considered as success */
          if ( cm_info->ss_status.present && cm_info->ss_status.cm_ss_active )
          {
            if ( ( stk_cc_response == FALSE ) &&
                  ( list_info.sub.cm.info.ss_info.ss_service_class != 0 ) )
            {
              bs_class = (uint32) list_info.sub.cm.info.ss_info.ss_service_class;
            }
            else
            {
              bs_class = 0xff;
            }

            response[ 0 ] = TRUE;
            response[ 1 ] = (int) bs_class;
          }
          else
          {
            response[ 0 ] = FALSE;
            response[ 1 ] = 0x00;
          }

          success = TRUE;
          break;

        default:
          QCRIL_LOG_ERROR( "Invalid confirmation type = %d is received\n", cm_info->conf_type );
          success = FALSE;
          break;
      } /* end switch */

      if ( stk_cc_response == FALSE )
      {
        if ( success )
        {
          qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_SUCCESS, &resp );
          if ( ss_list_info->ss_code == qcril_cm_ss_cw )
          {
            resp.resp_pkt = (void *) response;
            resp.resp_len = sizeof( response );
          }
          else
          {
            resp.resp_pkt = (void *) &response[ 1 ];
            resp.resp_len = sizeof( response[ 1 ] );
          }

          qcril_send_request_response( &resp );
        }
        else
        {
          qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
        }
      }
      // STK CC case
      else
      {
        if ( success )
        {
          if ( ss_code == qcril_cm_ss_cw )
          {
            qcril_cm_stk_cc_supsvc_response ( instance_id, ss_service_type, SS_INTERROGATION,
                      response, NULL, 2);
          }
          else
          {
            qcril_cm_stk_cc_supsvc_response ( instance_id, ss_service_type, SS_INTERROGATION,
                      &response[1], NULL, 1);
          }
        }
      }
      break;
    }

    case qcril_cm_ss_clip:
    {
      int response[ 1 ];

      response[ 0 ] = 2;
      switch ( cm_info->conf_type )
      {
        case SS_STATUS_INFO:
          if ( cm_info->ss_status.present )
          {
            if ( cm_info->ss_status.cm_ss_provisioned )
            {
              response[ 0 ] = 1;
            }
            else
            {
              response[ 0 ] = 0;
            }
          }
          else
          {
            response[ 0 ] = 2; /* as per android requirement */
          }

          success = TRUE;
          break;

        case CLI_RESTRICTION_INFO:
          if ( cm_info->cli_restriction.present )
          {
            if ( cm_info->cli_restriction.cm_ss_status.cm_ss_provisioned )
            {
              response[ 0 ] = 1;
            }
            else
            {
              response[ 0 ] = 0;
            }
          }
          else
          {
            response[ 0 ] = 2; /* as per android requirement */
          }

          success = TRUE;
          break;

        case CC_CAUSE_INFO:
        case SS_ERROR_INFO:
        default:
          break;
      } /* end switch */

      if ( stk_cc_response == FALSE )
      {
        if ( success )
        {
          qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_SUCCESS, &resp );
          resp.resp_pkt = (void *) response;
          resp.resp_len = sizeof( response );
          qcril_send_request_response( &resp );
        }
        else
        {
          qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
        }
      }
      // STK CC case
      else
      {
        if ( success )
        {
          qcril_cm_stk_cc_supsvc_response ( instance_id, ss_service_type, SS_INTERROGATION,
                      response, NULL, 1);
        }
      }
      break;
    }

    case qcril_cm_ss_clir:
    {
      int response[ 2 ];

      switch ( cm_info->conf_type )
      {
        case SS_STATUS_INFO:
          if ( cm_info->ss_status.present )
          {
            if ( cm_info->ss_status.cm_ss_provisioned )
            {
              response[ 1 ] = (int) QCRIL_CM_SS_CLIR_SRV_PROVISIONED_PERMANENT;
            }
            else
            {
              response[ 1 ] = (int) QCRIL_CM_SS_CLIR_SRV_NOT_PROVISIONED;
            }
          }
          else
          {
             response[ 1 ] = (int)QCRIL_CM_SS_CLIR_SRV_NO_NETWORK; /* as per android requirement */
          }

          success = TRUE;
          break;

        case CLI_RESTRICTION_INFO:
          cli_restriction_info = &cm_info->cli_restriction;
          clir_interrogate_status = QCRIL_CM_SS_CLIR_SRV_NOT_PROVISIONED;

          if ( cli_restriction_info->present )
          {
            if ( cli_restriction_info->cm_cli_restriction_option.present )
            {
              switch ( cli_restriction_info->cm_cli_restriction_option.option )
              {
                case CLI_DEFAULT_OPTION:
                  /* This maps to Permanent CLIR provisioning */
                  clir_interrogate_status = QCRIL_CM_SS_CLIR_SRV_PROVISIONED_PERMANENT;
                  break;

                case CLI_RESTRICT_OPTION:
                  /* This maps to default CLIR ON and can be overidden */
                  clir_interrogate_status = QCRIL_CM_SS_CLIR_SRV_PRESENTATION_RESTRICTED;
                  break;

                case CLI_OVERRIDE_OPTION:
                  /* This maps to CLIR default - requires explicit CLIR status to be used during call setup */
                  clir_interrogate_status = QCRIL_CM_SS_CLIR_SRV_PRESENTATION_ALLOWED;
                  break;

                case CLI_UNKNOWN_OPTION:
                  clir_interrogate_status = QCRIL_CM_SS_CLIR_SRV_NO_NETWORK;
                  break;

                default:
                  /* Ideally filtered by CM and should not be received */
                  /* Map it to non provisioned status */
                  break;
              } /* end switch */
            }
          }

          response[ 1 ] = (int)clir_interrogate_status;
          success = TRUE;
          break;

        case CC_CAUSE_INFO:
        case SS_ERROR_INFO:
          response[ 1 ] = (int)QCRIL_CM_SS_CLIR_SRV_NO_NETWORK;
          success = TRUE;
          break;

        default:
          break;
      }

      QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, "qcril_cm.info.ss_mutex" );
      /* modify the clir setting values based on the response of RIL_REQUEST_GET_CLIR */
      if (  ( success && ( ( response[1] == QCRIL_CM_SS_CLIR_SRV_NOT_PROVISIONED ) ||
                           ( response[1] == QCRIL_CM_SS_CLIR_SRV_NO_NETWORK ) ) ) || ( !success ) )
      {
         i_ptr->clir = 0;
         /* Save CLIR setting to system property */
         QCRIL_SNPRINTF( args, sizeof( args ), "%d", i_ptr->clir );
         if ( property_set( QCRIL_CM_CLIR, args ) != E_SUCCESS )
         {
           QCRIL_LOG_ERROR( "Fail to save %s to system property\n", QCRIL_CM_CLIR );
         }
        QCRIL_LOG_DEBUG( "modifying the SET_CLIR information based on GET_CLIR response, clir = %d\n", i_ptr->clir );
      }

      response[0] = i_ptr->clir;
      QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, "qcril_cm.info.ss_mutex" );

      QCRIL_LOG_DEBUG( "GET_CLIR response, n_value = %d, m_value = %d\n", response[0], response[1] );
      if ( stk_cc_response == FALSE )
      {
        if ( success )
        {
          qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_SUCCESS, &resp );
          resp.resp_pkt = (void *) response;
          resp.resp_len = sizeof( response );
          qcril_send_request_response( &resp );
        }
        else
        {
          qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_GENERIC_FAILURE, &resp );
          qcril_send_request_response( &resp );
        }
      }
      // STK CC case
      else
      {
        if ( success )
        {
          qcril_cm_stk_cc_supsvc_response ( instance_id, ss_service_type, SS_INTERROGATION,
                      response, NULL, 2);
        }
      }
      break;
    }

    case qcril_cm_ss_allForwardingSS:
    case qcril_cm_ss_allCondForwardingSS:
    case qcril_cm_ss_cfb:
    case qcril_cm_ss_cfnry:
    case qcril_cm_ss_cfnrc:
    case qcril_cm_ss_cfu:
    {
      qcril_cm_ss_callforwd_info_param_u_type response_buffer[ 7 ];
      qcril_cm_ss_callforwd_info_param_u_type *response[ 7 ];
      char forward_to_number[ 7 ][ 2 * CM_CALLED_PARTY_BCD_NO_LENGTH ];

      memset( (void*) response_buffer, 0, sizeof( response_buffer ) );
      memset( (void*) response, NULL, sizeof( response ) );
      memset( (void*) forward_to_number, 0, sizeof( forward_to_number ) );

      switch ( cm_info->conf_type )
      {
        case SS_STATUS_INFO:
          if ( cm_info->ss_status.present && cm_info->ss_status.cm_ss_active )
          {
            response_buffer[ 0 ].status = TRUE;
          }
          else
          {
            response_buffer[ 0 ].status = FALSE;
          }

          /* if call forwarding is interrogated for specific service class,
             include only that service class in response */
          if ( ( stk_cc_response == FALSE ) && ( ss_list_info->ss_service_class != 0 ) )
          {
            response_buffer[ 0 ].service_class = ss_list_info->ss_service_class;
          }
          else
          {
            response_buffer[ 0 ].service_class = 0xff;
          }

          response_buffer[ 0 ].reason = qcril_cm_ss_get_cfw_reason( ss_code );
          response[ count ] = &response_buffer[ 0 ];

          if ( stk_cc_response == FALSE )
          {
            qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_SUCCESS, &resp );
            resp.resp_pkt = (void *) response;
            resp.resp_len = sizeof( qcril_cm_ss_callforwd_info_param_u_type * );
            qcril_send_request_response( &resp );
          }
          // STK CC case
          else
          {
            qcril_cm_stk_cc_supsvc_response ( instance_id, ss_service_type, SS_INTERROGATION,
                      NULL, response_buffer, 1);
          }
          break;

        case FWD_FEATURE_LIST_INFO:
          if ( !cm_info->fwd_feature_list.present )
          {
            QCRIL_LOG_ERROR( "%s", "Fowarding feature list info missing \n" );
            break;
          }

          /* Report for each forwarding registration */
          while ( cm_info->fwd_feature_list.forwarding_feature_list_length > count )
          {
            const forwarding_feature_T * fflist_ptr = &cm_info->fwd_feature_list.forwarding_feature[ count ];
            uint8 type = 0, j = 0;
            uint32 service_class = 0;
            int no_reply_timer = 0;

            /* Size temp buffer for address, subaddress, and various other characters */
            #define MAX_CCFC_ADDRESS_SIZE ( 2 * CM_CALLED_PARTY_BCD_NO_LENGTH * ( 2 * MAXNO_FORWARD_TO_NUMBER ) )

            byte address[ MAX_CCFC_ADDRESS_SIZE ];
            byte buffer[ MAX_CCFC_ADDRESS_SIZE ];
            byte * a_ptr = &address[ 1 ];
            uint8 a_length = 0;
            byte * s_ptr = buffer;
                
            status = 0;
            memset( (void*) buffer, 0, sizeof( buffer ) );
            memset( (void*) address, 0, sizeof( address ) );

            status = ( ( fflist_ptr->ss_status.present && fflist_ptr->ss_status.cm_ss_active ) ? 1 : 0 );

            /* Per 3GPP TS 27.007 section Do not print an info text response line for an inactive class */
            if ( status == 0 )
            {
              count++;
              continue;
            }

            if ( !fflist_ptr->basic_service.present )
            {
              service_class = 0;
            }
            else
            {
              service_class = qcril_cm_ss_get_service_class( fflist_ptr->basic_service.code_type, fflist_ptr->basic_service.bs_code );
            }

            /* Decode dialed number */
            /* though it has been written to handle multiple call forward to number
               as of now we are not aware of such scenario where multiple call forward
               to number is sent by network */

            while ( j < ( 2 * MAXNO_FORWARD_TO_NUMBER ) )
            {
              /* Check for availability */
              if ( fflist_ptr->forwarded_to_number[ j ].present )
              {
                /* Append number segment to existing buffer */
                uint8 k;

                for ( k = 0; k < fflist_ptr->forwarded_to_number[ j ].length; k++ )
                {
                  *a_ptr++ = fflist_ptr->forwarded_to_number[ j ].data[ k ];
                }

                a_length += fflist_ptr->forwarded_to_number[ j ].length;
              }

              j++;
            } /* end while */

            address[ 0 ] = a_length;

            /* Convert from BCD to ASCII string */
            if ( a_ptr != &address[ 1 ] )
            {
              qcril_cm_util_bcd_to_ascii( address, s_ptr );

              /* Set Type based on '+' prefix */
              type = ( QCRIl_CM_SS_TA_INTER_PREFIX == *s_ptr ) ? QCRIL_CM_SS_TA_INTERNATIONAL : QCRIL_CM_SS_TA_UNKNOWN;

              /* removing the first charecter which indicates type*/
              s_ptr = s_ptr + 1;
              success = TRUE;
            }

            /* Decode timer */
            if ( fflist_ptr->no_reply_condition_timer.present )
            {
              no_reply_timer = fflist_ptr->no_reply_condition_timer.timer_value;
              success = TRUE;
            }

            QCRIL_ASSERT( strlen((char*) s_ptr) < ((2*CM_CALLED_PARTY_BCD_NO_LENGTH) - 1) );
            memcpy( forward_to_number[ num_active_classes ], buffer, strlen( (char*) s_ptr ) + 1 );

            response_buffer[ num_active_classes ].service_class = (int)service_class;
            response_buffer[ num_active_classes ].status = status;
            response_buffer[ num_active_classes ].toa = type;
            response_buffer[ num_active_classes ].reason = qcril_cm_ss_get_cfw_reason(ss_code);
            response_buffer[ num_active_classes ].no_reply_timer = no_reply_timer;
            response_buffer[ num_active_classes ].number = forward_to_number[num_active_classes];

            /* initializing it to pointer as ANDROID API expects array of pointers */
            response[ num_active_classes ] = &response_buffer[num_active_classes];

            count++;
            num_active_classes++;
          } /* end while */

          QCRIL_LOG_DEBUG( "count = %d active_class =%d and status = %d\n", count, num_active_classes, status );
              
          if ( num_active_classes == 0 )
          {
            response_buffer[ 0 ].status = FALSE;

            /* if call forwarding is interrogated for specific service class, include only that service class in response */
            if ( ( stk_cc_response == FALSE ) && ( ss_list_info->ss_service_class != 0 ) )
            {
              response_buffer[ 0 ].service_class = ss_list_info->ss_service_class;
            }
            else
            {
              response_buffer[ 0 ].service_class = 0xff;
            }

            response_buffer[ 0 ].reason = qcril_cm_ss_get_cfw_reason( ss_code );
            response[ 0 ] = &response_buffer[ 0 ];

            if ( stk_cc_response == FALSE )
            {
              qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_SUCCESS, &resp );
              resp.resp_pkt = (void *) response;
              resp.resp_len = sizeof( qcril_cm_ss_callforwd_info_param_u_type * );
              qcril_send_request_response( &resp );
            }
            // STK CC case
            else
            {
              qcril_cm_stk_cc_supsvc_response ( instance_id, ss_service_type, SS_INTERROGATION,
                      NULL, response_buffer, 1);
            }
          }
          else
          {
            qcril_cm_ss_add_service_class_based_on_number(response, &num_active_classes);
            if ( stk_cc_response == FALSE )
            {
              qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_SUCCESS, &resp );
              resp.resp_pkt = (void *) response;
              resp.resp_len = sizeof( qcril_cm_ss_callforwd_info_param_u_type * ) * num_active_classes;
              qcril_send_request_response( &resp );
            }
            // STK CC case
            else
            {
              qcril_cm_stk_cc_supsvc_response ( instance_id, ss_service_type, SS_INTERROGATION,
                      NULL, response_buffer, num_active_classes);
            }
          }  
          break;

        default:
          QCRIL_LOG_DEBUG( "%s", "entered the default case for call forwarding\n");             
          if ( stk_cc_response == FALSE )
          {
            qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_GENERIC_FAILURE, &resp );
            qcril_send_request_response( &resp );
          }
          break;
      } /* end switch */
      break;
    }

    default:
      break;
  }

} /* qcril_cm_supsvc_event_interrogate_conf */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_register_conf

===========================================================================*/
/*!
    @brief
    handle CM_SUPS_EVENT_REGISTER_CONF.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_register_conf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_sups_info_s_type *cm_info;
  qcril_reqlist_public_type list_info;
  qcril_cm_ss_type *ss_list_info;
  boolean success = FALSE;
  qcril_request_resp_params_type resp;
  RIL_SsServiceType ss_service_type;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  cm_info = (cm_sups_info_s_type *)(params_ptr->data);
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  if ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, (uint32) QCRIL_EVT_CM_SUPS_REGISTER_CONF, 
                                                cm_info->ss_ref, &list_info ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "None of entry is waiting for QCRIL_EVT_CM_SUPS_REGISTER_CONF. This is probably STK CC response.\n");
    if ( cm_info->ss_success && ( cm_info->conf_type != CC_CAUSE_INFO ) &&
            ( cm_info->conf_type != SS_ERROR_INFO ))
    {
      ss_service_type = qcril_cm_ss_get_service_type ( cm_info->ss_code );
      qcril_cm_stk_cc_supsvc_response ( instance_id, ss_service_type, SS_REGISTRATION,
                      NULL, NULL, 0);
    }
    else
    {
      QCRIL_LOG_ERROR( "%s", "STK CC command failed!");
    }
    return;
  }

  ss_list_info = &list_info.sub.cm.info.ss_info;

  QCRIL_LOG_DEBUG( "Sups info success = %d confirmation type = %d ss_code = %d\n",
                   cm_info->ss_success, cm_info->conf_type, ss_list_info->ss_code );  

  if ( ss_list_info->ss_ref != cm_info->ss_ref )
  {
    QCRIL_LOG_ERROR( "%s", "QCRIL_EVT_CM_SUPS_REGISTER_CONF with incorrect ss_ref is receiveds\n" );
    return;
  }

  if ( !cm_info->ss_success )
  {
    QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer\n");
    success = FALSE;
  }
  else
  {
    switch ( ss_list_info->ss_code )
    {
      case qcril_cm_ss_cfu:
      case qcril_cm_ss_cfb:
      case qcril_cm_ss_cfnry:
      case qcril_cm_ss_cfnrc:
      case qcril_cm_ss_allForwardingSS:
      case qcril_cm_ss_allCondForwardingSS:
        switch(cm_info->conf_type)
        {
          /* Success cases */
          case FWD_INFO:
          case NO_INFO:  /* special case with no parameter info */
            QCRIL_LOG_DEBUG( "SupS confirmation successful: %d \n", cm_info->conf_type );
            success = TRUE;
            break;

          case CC_CAUSE_INFO:    /* Lower layer faliure in protocol stack */
            QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer \n" );
            success = FALSE;
            break;

          case SS_ERROR_INFO:    /* Network rejected request */
          default:
            QCRIL_LOG_ERROR( "%s", "Network rejected SupS request \n" );
            success = FALSE;
            break;
        }
        break;

      default:
        break;
    }
  }

  if ( success )
  {
    qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_event_register_conf */


/*=========================================================================
  FUNCTION:  qcril_cm_suppvc_event_reg_password_conf

===========================================================================*/
/*!
    @brief
    Processes the response received for RIL_REQUEST_CHANGE_BARRING_PASSWORD
    request from network/protocol stack

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_reg_password_conf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_sups_info_s_type *cm_info;
  qcril_reqlist_public_type list_info;
  boolean success = FALSE;
  qcril_request_resp_params_type resp;
  RIL_SsServiceType ss_service_type;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  cm_info = (cm_sups_info_s_type *)(params_ptr->data);
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  if ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, (uint32) QCRIL_EVT_CM_SUPS_REG_PASSWORD_CONF, 
                                                cm_info->ss_ref, &list_info ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "None of entry is waiting for QCRIL_EVT_CM_SUPS_REG_PASSWORD_CONF. This is probably STK CC response.\n");
    if ( cm_info->ss_success && ( cm_info->conf_type != CC_CAUSE_INFO ) &&
            ( cm_info->conf_type != SS_ERROR_INFO ))
    {
      ss_service_type = qcril_cm_ss_get_service_type ( cm_info->ss_code );
      // TODO STK CC: Check the request type.
      qcril_cm_stk_cc_supsvc_response ( instance_id, ss_service_type, SS_REGISTRATION,
                      NULL, NULL, 0);
    }
    else
    {
      QCRIL_LOG_ERROR( "%s", "STK CC command failed!");
    }
    return;
  }

  if ( !cm_info->ss_success )
  {
    QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer\n");
    success = FALSE;
  }
  else
  {
    switch ( list_info.sub.cm.info.ss_info.ss_code )
    {
      case qcril_cm_ss_baoc:
      case qcril_cm_ss_boic:
      case qcril_cm_ss_boicExHC:
      case qcril_cm_ss_baic:
      case qcril_cm_ss_bicRoam:
      case qcril_cm_ss_allCallRestrictionSS:
      case qcril_cm_ss_barringOfOutgoingCalls:       
      case qcril_cm_ss_barringOfIncomingCalls:
        switch ( cm_info->conf_type )
        {
          /* Success cases */
          case NEW_PWD_INFO:
            QCRIL_LOG_DEBUG( "SupS confirmation successful: %d \n", cm_info->conf_type );
            success = TRUE;
            break;

          case CC_CAUSE_INFO:    /* Lower layer faliure in protocol stack */
            QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer \n" );
            success = FALSE;
            break;

          case SS_ERROR_INFO:    /* Network rejected request */
          default:
            QCRIL_LOG_ERROR( "%s", "Network rejected SupS request \n" );
            success = FALSE;
            break;
        }
        break;

      default:
        QCRIL_LOG_ERROR( "%s", "received invalid ss code\n" );       
        break;
    }
  }

  if ( success )
  {
    qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_GENERIC_FAILURE, &resp );
    qcril_send_request_response( &resp );
  }

} /* qcril_cm_supsvc_event_reg_password_conf */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_process_uss

===========================================================================*/
/*!
    @brief
    tracking the MO USSD initiated by other clients.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_process_uss
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_reqlist_public_type reqlist_entry;
  qcril_reqlist_u_type info;
  cm_sups_info_s_type *cm_info;
  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  cm_info = (cm_sups_info_s_type *)(params_ptr->data);
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/



  if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_SUPS_PROCESS_USS_CONF, &reqlist_entry ) != E_SUCCESS )
  {
     QCRIL_LOG_DEBUG("%s", "no pending request, add to req list for tracking the mo ussd from other client")

     memset(&info, 0, sizeof(info) );
     info.cm.info.ss_info.req_from_other_client = TRUE;
     info.cm.info.ss_info.ss_ref = cm_info->ss_ref;

     qcril_reqlist_default_entry( params_ptr->t, params_ptr->event_id, modem_id, QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS, 
                                    QCRIL_EVT_CM_SUPS_PROCESS_USS_CONF, &info, &reqlist_entry ); 

      if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
      {
        /* Fail to add to ReqList */
        QCRIL_LOG_DEBUG("%s", "failed to add to the req list");
        return;
      }
  }
  else
  {
     QCRIL_LOG_DEBUG("%s", "ignoring the event as mo ussd is initiated by ril");
  }

}


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_process_uss_conf

===========================================================================*/
/*!
    @brief
    Processes the response received for USSD request
    (i.e QCRIL_EVT_CM_SUPS_PROCESS_USS_CONF) from network/protocol stack

    @return
    char **response[] with response[0] contains the type code and
                           response[1] contains the response from NW if any.
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_process_uss_conf
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_sups_info_s_type *cm_info;
  qcril_reqlist_public_type list_info;
  qcril_cm_ss_type *ss_list_info;
  boolean success;
  char ussd_utf8_str[MAX_MT_USSD_CHAR*2];
  char type_code[2];
  char *response_buff[2];
  int utf8_len =0;
  qcril_request_resp_params_type resp;
  qcril_unsol_resp_params_type unsol_resp;
  qcril_cm_struct_type *i_ptr;
  boolean request_from_other_client = FALSE;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  cm_info = (cm_sups_info_s_type *)(params_ptr->data);
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  memset( ussd_utf8_str, '\0', sizeof( ussd_utf8_str ) );
  memset( type_code, '\0', sizeof( type_code ) );
  memset( response_buff, NULL, sizeof( response_buff ) );

  if ( qcril_reqlist_query_by_event_and_sub_id( instance_id, modem_id, (uint32) QCRIL_EVT_CM_SUPS_PROCESS_USS_CONF, cm_info->ss_ref, 
                                                &list_info ) != E_SUCCESS )
  {
    QCRIL_LOG_ERROR( "%s", "None of entry is waiting for QCRIL_EVT_CM_SUPS_PROCESS_USS_CONF \n");

    if ( qcril_reqlist_query_by_event( instance_id, modem_id, params_ptr->event_id, &list_info ) == E_SUCCESS )
    {
      if( list_info.sub.cm.info.ss_info.req_from_other_client )
      {
        QCRIL_LOG_DEBUG("%s", "ussd response for USSD request from other client,"
              "ignore or send unsol_on_ussd if process_ussd_from_other_clients is true.");
    
        // Remove entry from Reqlist if applicable 
        ( void ) qcril_reqlist_free( instance_id, list_info.t );
        request_from_other_client = TRUE;
      }
    }

    if ( i_ptr->process_ussd_from_other_clients == FALSE )
         return;
  }

  if( ( ( cm_info->conf_type == SS_ERROR_INFO ) &&
         ( cm_info->ss_error.error_code_tag  == QCRIL_CM_SS_INVOKE_PROBLEM ) &&
         ( cm_info->ss_error.error_code == QCRIL_CM_SS_UNRECOGNISED_OPERATION ) ) ||
       ( ( cm_info->conf_type == CC_CAUSE_INFO ) &&
         ( cm_info->cc_cause.cause_value == QCRIL_CM_SS_FACILITY_REJECTED ) )
    )
  {
    QCRIL_LOG_DEBUG( "%s", "Ignoring the event as PHASE2 USSD is rejected and retried as PHASE1\n" );
    return;
  }

  ss_list_info = &list_info.sub.cm.info.ss_info;

  QCRIL_LOG_DEBUG( "Sups info success = %d confirmation type = %d\n", cm_info->ss_success, cm_info->conf_type );
  
  if ( ss_list_info->ss_ref != cm_info->ss_ref )
  {
    QCRIL_LOG_ERROR( "%s", "QCRIL_EVT_CM_SUPS_ACTIVATE_CONF with incorrect ss_ref is receiveds\n");
    return;
  }

  if ( !cm_info->ss_success )
  {
    QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer\n");
    success = FALSE;
  }
  else
  {
    switch ( cm_info->conf_type )
    {
      /* Success cases */
      case USS_DATA_INFO:
      case NO_INFO:  /* special case with no parameter info */
        if ( cm_info->uss_data.present )
        {
          if ( cm_info->uss_data_type == CM_USS_PHASE1_TYPE )
          {
            QCRIL_LOG_DEBUG( "%s", "Received PHASE1 USSD \n" );
            utf8_len = cm_info->uss_data.size;
            memcpy( ussd_utf8_str, cm_info->uss_data.ussData, utf8_len );
            ussd_utf8_str[ utf8_len ] = '\0';
          }
          else
          {
            utf8_len = qcril_cm_ss_convert_ussd_string_to_utf8( cm_info->uss_data.uss_data_coding_scheme,
                                                                cm_info->uss_data.size, 
                                                                cm_info->uss_data.ussData, 
                                                                ussd_utf8_str );
          }

          if ( utf8_len > ( MAX_MT_USSD_CHAR * 2 ) )
          {
            QCRIL_LOG_ERROR ("%s", "ascii_len exceeds MAX_MT_USSD_CHAR \n" );
            utf8_len = (int) (MAX_MT_USSD_CHAR*2);
            ussd_utf8_str[ utf8_len - 1] = '\0';
          }    
        }
        success = TRUE;
        break;

      case CC_CAUSE_INFO:   /* Network rejected request */
        QCRIL_LOG_ERROR( "%s", "Network rejected SupS request \n" );
        success = FALSE;
        break;

      case SS_ERROR_INFO:   /* Lower layer faliure in protocol stack */
      default:
        QCRIL_LOG_ERROR( "%s", "Rejected from protocol layer \n" );
        success = FALSE;
        break;
    }
  }

  /* send success to match with the android design for blocking the multiple rejected pop ups */
  if (request_from_other_client == FALSE)
  {
      qcril_default_request_resp_params( instance_id, list_info.t, list_info.request, RIL_E_SUCCESS, &resp );
      qcril_send_request_response( &resp );
  }

  if ( success )
  {
    type_code[ 0 ] = '0';  /* QCRIL_CM_SS_CUSD_RESULT_DONE */
    type_code[ 1 ] = '\0';
    response_buff[ 0 ] = type_code;

    if ( cm_info->uss_data.present )
    {
      response_buff[ 1 ] = ussd_utf8_str;
    }
    else
    {
      response_buff[ 1 ] = NULL;
    }

    /* Sending the response received from the network for the USSD request */
    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_ON_USSD, &unsol_resp );
    unsol_resp.resp_pkt = (void *) response_buff;
    unsol_resp.resp_len = sizeof( response_buff );
    qcril_send_unsol_response( &unsol_resp );
  }
  else
  {
    /* sending the unsol indication so that RIL can close the USSD session */
    if ( cm_info->ss_error.present &&
         ( cm_info->ss_error.error_code_tag == 0x02 ) && /*ERROR_CODE_TAG*/
         ( cm_info->ss_error.error_code == 0x15 ) ) /*facilityNotSupported*/
    {
      type_code[ 0 ] = '4';  /*QCRIL_CM_SS_CUSD_RESULT_NOSUP */
      type_code[ 1 ] = '\0';
    }
    else
    {
      type_code[ 0 ] = '2';  /* QCRIL_CM_SS_CUSD_RESULT_ABORT */
      type_code[ 1 ] = '\0';
    }

    response_buff[ 0 ] = type_code;
    response_buff[ 1 ] = NULL;

    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_ON_USSD, &unsol_resp );
    unsol_resp.resp_pkt = (void *) response_buff;
    unsol_resp.resp_len = sizeof( response_buff );
    qcril_send_unsol_response( &unsol_resp );
  }

} /* qcril_cm_supsvc_event_process_uss_conf */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_fwd_check_ind

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_SUPS_EVENT_FWD_CHECK_IND notification message from network
    which is sent when supplementary services data in the HLR may have become
    corrupted.

    @return
    RIL_SuppSvcNotification.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_fwd_check_ind
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  RIL_SuppSvcNotification response;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  /* Initialize response structure */
  memset( ( void* )&response, 0, sizeof( response ) );
  response.number = NULL;

  response.notificationType = (int) QCRIL_CM_SS_MT_NOTIFICATION;
  response.code = (int) QCRIL_CM_SS_CSSU_FWD_CHECK_SS_RECVD;

  /* all the checks are already take care in CM like checking for the notification
     present and its value, hence sending the reponse directly to RIL*/

  /* Call related notifications to RIL */
  qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_SUPP_SVC_NOTIFICATION, &unsol_resp );
  unsol_resp.resp_pkt = ( void * ) &response;
  unsol_resp.resp_len = sizeof( response );
  qcril_send_unsol_response( &unsol_resp );

} /* qcril_cm_supsvc_event_fwd_check_ind */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_uss_notify_ind

===========================================================================*/
/*!
    @brief
    Handle CM_SUPS_EVENT_USS_NOTIFY_IND.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_uss_notify_ind
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  cm_sups_info_s_type *cm_info;
  char ussd_utf8_str[ MAX_MT_USSD_CHAR * 2 ];
  char *response[ 2 ];
  char type_code[ 2 ];
  qcril_reqlist_u_type u_info;
  qcril_cm_ss_type *req_info_ptr = &u_info.cm.info.ss_info;
  cm_uss_notify_res_params_s_type    uss_notify_parms;
  boolean cm_result;
  int utf8_len = 0;
  qcril_unsol_resp_params_type unsol_resp;

  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_sups_cmd_uss_notify_res_api_name = "cm_sups_cmd_uss_notify_res_per_subs()";
  #else
  char *cm_sups_cmd_uss_notify_res_api_name = "cm_sups_cmd_uss_notify_res()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  cm_info = (cm_sups_info_s_type *)(params_ptr->data);
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/
  memset( ( void* )&uss_notify_parms, 0, sizeof(uss_notify_parms) );

  req_info_ptr->ss_ref = cm_info->invoke_id;

  if ( cm_info->uss_data.present )
  {
    memset( ussd_utf8_str, '\0', sizeof( ussd_utf8_str ) );

    utf8_len = qcril_cm_ss_convert_ussd_string_to_utf8( cm_info->uss_data.uss_data_coding_scheme,
                                                        cm_info->uss_data.size, 
                                                        cm_info->uss_data.ussData, 
                                                        ussd_utf8_str );
    type_code[ 0 ] = '0'; /* QCRIL_CM_SS_CUSD_RESULT_MORE */
    type_code[ 1 ] = '\0';

    response[ 0 ] = type_code;
    response[ 1 ] = ussd_utf8_str;

    /* Sending the response received from the network for the USSD request */
    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_ON_USSD, &unsol_resp );
    unsol_resp.resp_pkt = ( void * ) &response;
    unsol_resp.resp_len = sizeof( response );
    qcril_send_unsol_response( &unsol_resp );

    uss_notify_parms.invoke_id = cm_info->invoke_id;

    #ifdef FEATURE_QCRIL_DSDS
    /* Lookup as_id */
    if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) != E_SUCCESS )
    {
      return;
    }
    #endif /* FEATURE_QCRIL_DSDS */

    QCRIL_LOG_RPC( modem_id, cm_sups_cmd_uss_notify_res_api_name, "invoke_id", uss_notify_parms.invoke_id );
    cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_uss_notify_res_func( NULL,
                                                                                NULL,
                                                                                i_ptr->client_info[ modem_id ].client_id,
                                                                                &uss_notify_parms 
                                                                                #ifdef FEATURE_QCRIL_DSDS
                                                                                , as_id
                                                                                #endif /* FEATURE_QCRIL_DSDS */
                                                                              );
    if ( !cm_result )
    {
      QCRIL_LOG_ERROR( "%s", "received error from CM while sending notify_res() \n" );
    }  
  }
  else
  {
    QCRIL_LOG_ERROR( "%s", "Received QCRIL_EVT_CM_SUPS_USS_NOTIFY_IND with no USSD string\n");
  }

} /* qcril_cm_supsvc_event_uss_notify_ind */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_uss_ind

===========================================================================*/
/*!
    @brief
    Processes the mobile terminated USSD request received
    (i.e QCRIL_EVT_CM_SUPS_USS_IND) from network

    @return
    char **response[] with response[0] contains the type code and
                           response[1] contains the response from NW if any.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_uss_ind
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  cm_sups_info_s_type *cm_info;
  char ussd_utf8_str[MAX_MT_USSD_CHAR*2];
  char *response[ 2 ];
  char type_code[ 2 ];
  qcril_reqlist_u_type u_info;
  qcril_cm_ss_type *req_info_ptr = &u_info.cm.info.ss_info;
  int utf8_len = 0;
  qcril_reqlist_public_type reqlist_entry;
  qcril_unsol_resp_params_type unsol_resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  cm_info = (cm_sups_info_s_type *)(params_ptr->data);
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  req_info_ptr->ss_ref = cm_info->invoke_id;

  if ( cm_info->uss_data.present )
  {
    memset( ussd_utf8_str, '\0', sizeof( ussd_utf8_str ) );

    utf8_len = qcril_cm_ss_convert_ussd_string_to_utf8( cm_info->uss_data.uss_data_coding_scheme,
                                                        cm_info->uss_data.size, 
                                                        cm_info->uss_data.ussData, 
                                                        ussd_utf8_str );

    // To support muti session USSD initiated by an MO USSD request by other
    // client like STK we need another internal token id since we already used
    // QCRIL_TOKEN_ID_INTERNAL for PROCESS CM_SUPS_EVENT_PROCESS_USS event.
    qcril_reqlist_default_entry( QCRIL_TOKEN_ID_INTERNAL1, params_ptr->event_id, modem_id,
          QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS, QCRIL_EVT_CM_SUPS_USS_IND, &u_info, &reqlist_entry );
    reqlist_entry.valid_sub_id = TRUE;
    reqlist_entry.sub_id = req_info_ptr->ss_ref;
    if ( qcril_reqlist_new( instance_id, &reqlist_entry ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "%s", "Could not add entry to the list \n");
    }

    type_code[ 0 ] = '1';   /* QCRIL_CM_SS_CUSD_RESULT_MORE */
    type_code[ 1 ] = '\0';

    response[ 0 ] = type_code;
    response[ 1 ] = ussd_utf8_str;

    /* sending the response received from the network for the USSD request */
    qcril_default_unsol_resp_params( instance_id, (int) RIL_UNSOL_ON_USSD, &unsol_resp );
    unsol_resp.resp_pkt = ( void * ) &response;
    unsol_resp.resp_len = sizeof( response );
    qcril_send_unsol_response( &unsol_resp );
  }
  else
  {
    QCRIL_LOG_ERROR( "%s", "Received QCRIL_EVT_CM_SUPS_USS_IND with no USSD string\n");
  }

} /* qcril_cm_supsvc_event_uss_ind */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_release_uss_ind

===========================================================================*/
/*!
    @brief
    Handle CM_SUPS_EVENT_RELEASE_USS_IND.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_release_uss_ind
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  char *response[ 2 ];
  char type_code[ 2 ] = "2"; /* QCRIL_CM_SS_CUSD_RESULT_MORE */
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  modem_id = params_ptr->modem_id;
  QCRIL_ASSERT( modem_id < QCRIL_MAX_MODEM_ID );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  response[0] = type_code;
  response[1] = NULL;

  if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_SUPS_PROCESS_USS_CONF, &req_info ) == E_SUCCESS )
  {
    if( !req_info.sub.cm.info.ss_info.req_from_other_client )
    {
       QCRIL_LOG_ERROR( "%s", "cleaning the uss_cnf after receiving release_uss_ind\n");
       /* send RIL_E_GENERIC_FAILURE response */
       qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_GENERIC_FAILURE, &resp );
       qcril_send_request_response( &resp );
    }
    else
    {
       QCRIL_LOG_DEBUG("%s", "ussd response for the request from other client, ignore, remove from list");
          // Remove entry from Reqlist
       ( void ) qcril_reqlist_free( instance_id, req_info.t );
    }
  }
  
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_SUPS_USS_IND, &req_info ) == E_SUCCESS )
  {
    /* remove the entry of the indication from the list*/
    qcril_reqlist_free( instance_id, req_info.t );
  }
  else if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_SUPS_USS_NOTIFY_IND, &req_info ) == E_SUCCESS )
  {
    /* remove the entry of the indication from the list*/
    qcril_reqlist_free( instance_id, req_info.t );
  }
  
} /* qcril_cm_supsvc_event_release_uss_ind */


/*=========================================================================
  FUNCTION:  qcril_cm_supsvc_event_get_password_ind

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_CM_SUPS_GET_PASSWORD_IND.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_supsvc_event_get_password_ind
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_cm_struct_type *i_ptr;
  cm_sups_info_s_type *cm_info;
  cm_get_pwd_res_params_s_type       get_pwd_res;
  boolean cm_result;
  qcril_reqlist_public_type info_ptr;
  char *cm_guidance = "";
  char details[80];
  char password[MAX_PWD_CHAR + 1]; 
  #ifdef FEATURE_QCRIL_DSDS
  sys_modem_as_id_e_type as_id = SYS_MODEM_AS_ID_NONE;
  char *cm_sups_cmd_get_password_res_api_name = "cm_sups_cmd_get_password_res_per_subs()";
  #else
  char *cm_sups_cmd_get_password_res_api_name = "cm_sups_cmd_get_password_res()";
  #endif /* FEATURE_QCRIL_DSDS */

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  modem_id = params_ptr->modem_id;
  cm_info = (cm_sups_info_s_type *)( params_ptr->data );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  memset( &get_pwd_res, 0, sizeof( cm_get_pwd_res_params_s_type ));

  /* Preserve network invoke ID */
  get_pwd_res.invoke_id = cm_info->invoke_id;

  /* case where RIL is responding for MT USSD request */
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_SUPS_REGISTER_CONF, &info_ptr ) == E_SUCCESS )
  {
    if ( info_ptr.sub.cm.info.ss_info.ss_pwd.present )
    {
      get_pwd_res.ss_pwd.present = TRUE;
    }
  }
  else if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_SUPS_ACTIVATE_CONF, &info_ptr ) == E_SUCCESS )
  {
    if ( info_ptr.sub.cm.info.ss_info.ss_pwd.present )
    {
      get_pwd_res.ss_pwd.present = TRUE;
    }  
  }
  else if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_SUPS_DEACTIVATE_CONF, &info_ptr ) == E_SUCCESS )
  {
    if ( info_ptr.sub.cm.info.ss_info.ss_pwd.present )
    {
      get_pwd_res.ss_pwd.present = TRUE;
    }  
  }
  else if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_SUPS_INTERROGATE_CONF, &info_ptr ) == E_SUCCESS )
  {
    if ( info_ptr.sub.cm.info.ss_info.ss_pwd.present )
    {
      get_pwd_res.ss_pwd.present = TRUE;
    }  
  }
  else
  {
    QCRIL_LOG_ERROR( "%s", "ignoring the received event as there are no pending requests \n");
  }

  if ( get_pwd_res.ss_pwd.present )
  {
    switch ( cm_info->guidance_info )
    {
      case enterPW:                   /* enter password */
        memcpy( get_pwd_res.ss_pwd.ss_password, info_ptr.sub.cm.info.ss_info.ss_pwd.password, MAX_PWD_CHAR );
        cm_guidance = "enterPW";
        break;
  
      case enterNewPW:                /* enter new password */
      case enterNewPW_Again:          /* confirm new password */
        memcpy( get_pwd_res.ss_pwd.ss_password, info_ptr.sub.cm.info.ss_info.ss_pwd.password, MAX_PWD_CHAR );
        cm_guidance = (cm_info->guidance_info == enterNewPW)? "enterNewPW" : "enterNewPW_Again";
        break;
  
      default:
        QCRIL_LOG_ERROR( "Unknown password indication: %d, defalut password value is used \n",cm_info->guidance_info);
        break;
    }

    QCRIL_SNPRINTF( details, sizeof( details ), "pwd %s, present %d, cm_guidance %s", 
                    get_pwd_res.ss_pwd.ss_password, get_pwd_res.ss_pwd.present, cm_guidance);

    #ifdef FEATURE_QCRIL_DSDS
    /* Lookup as_id */
    if ( qcril_arb_lookup_as_id_from_instance_id( instance_id, &as_id ) == E_SUCCESS )
    #endif /* FEATURE_QCRIL_DSDS */
    {
      /* Send the command to the CM command queue */
      QCRIL_LOG_RPC2( modem_id, cm_sups_cmd_get_password_res_api_name, details );
      cm_result = qcril_cm_api_funcs[ modem_id ].cm_sups_cmd_get_password_res_func( NULL,
                                                                                    NULL,
                                                                                    i_ptr->client_info[ modem_id ].client_id,
                                                                                    &get_pwd_res
                                                                                    #ifdef FEATURE_QCRIL_DSDS
                                                                                    , as_id
                                                                                    #endif /* FEATURE_QCRIL_DSDS */
                                                                                  );
      memcpy(password, get_pwd_res.ss_pwd.ss_password, MAX_PWD_CHAR);
      password[MAX_PWD_CHAR] = '\0';
      QCRIL_LOG_DEBUG("password res value, invoke-id = %d, password = %s", get_pwd_res.invoke_id, password);

      if ( !cm_result )
      {
        QCRIL_LOG_ERROR( "%s", "Problem invoking CM API \n" );
        return ;
      }
    }
  }
  else
  {
    QCRIL_LOG_ERROR( "%s", "Ignoring as there is no stored password \n");  
  }

} /* qcril_cm_supsvc_event_get_password_ind */


/*=========================================================================
  FUNCTION:  qcril_cm_callsvc_event_ext_brst_intl 

===========================================================================*/
/*!
    @brief
    Handles CM_CALL_EVENT_EXT_BRST_INTL.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_callsvc_event_ext_brst_intl 
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;
  const cm_mm_call_info_s_type *call_info_ptr; 
  int ext_brst_intl[5];

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr-> instance_id;
  call_info_ptr = ( cm_mm_call_info_s_type * ) params_ptr->data; 
  QCRIL_ASSERT( call_info_ptr != NULL );
  QCRIL_ASSERT( ret_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_LOG_VERBOSE( "%s", "Processing Extended Burst Type International DBM");

  ext_brst_intl[ 0 ] = call_info_ptr->mode_info.info.cdma_call.ext_brst_intl_msg.mcc;
  ext_brst_intl[ 1 ] = call_info_ptr->mode_info.info.cdma_call.ext_brst_intl_msg.db_subtype;
  ext_brst_intl[ 2 ] = call_info_ptr->mode_info.info.cdma_call.ext_brst_intl_msg.chg_ind;
  ext_brst_intl[ 3 ] = call_info_ptr->mode_info.info.cdma_call.ext_brst_intl_msg.sub_unit;
  ext_brst_intl[ 4 ] = call_info_ptr->mode_info.info.cdma_call.ext_brst_intl_msg.unit;

  qcril_hook_unsol_response( instance_id, QCRIL_EVT_HOOK_UNSOL_EXTENDED_DBM_INTL, (char *) ext_brst_intl, sizeof(ext_brst_intl) );

} /* qcril_cm_callsvc_event_ext_brst_intl */


/*=========================================================================
  FUNCTION:  qcril_cm_stats_event_modem_info

===========================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_STATS_MODEM_INFO.

    @return
    None.
*/
/*=========================================================================*/
void qcril_cm_stats_event_modem_info
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  #ifdef FEATURE_QCRIL_NCELL
  qcril_instance_id_e_type instance_id;
  qcril_cm_struct_type *i_ptr;
  const sys_modem_stats_info_s_type *stats_info_ptr; 
  char details[ 40 ];
  int fre, c, i, weakest;

  /*-----------------------------------------------------------------------*/

  QCRIL_ASSERT( params_ptr != NULL );
  instance_id = params_ptr->instance_id;
  QCRIL_ASSERT( instance_id < QCRIL_MAX_INSTANCE_ID );
  i_ptr = &qcril_cm[ instance_id ];
  stats_info_ptr = ( sys_modem_stats_info_s_type * ) params_ptr->data;
  QCRIL_ASSERT( stats_info_ptr != NULL );

  /*-----------------------------------------------------------------------*/

  QCRIL_SNPRINTF( details, sizeof( details ), "qcril_cm[%d].ss_mutex", instance_id );
  QCRIL_MUTEX_LOCK( &i_ptr->ss_mutex, details );
  
  /* Store GSM Neighbor Cell info */
  if ( ( stats_info_ptr->type == SYS_MODEM_MODULE_GSM ) && 
       ( stats_info_ptr->prm.gsm_info.changed_bitmask & CM_GERAN_ENG_MODE_NMR_INFO ) )
  {
    memset( &i_ptr->monitored_set_info, 0, sizeof( i_ptr->monitored_set_info ) );

    QCRIL_LOG_DEBUG( "%s", "Saved GSM NMR info\n" );
    i_ptr->nmr_info = stats_info_ptr->prm.gsm_info.nmr_info;
  }

  else if ( ( stats_info_ptr->type == SYS_MODEM_MODULE_WCDMA ) &&
            ( stats_info_ptr->prm.wcdma_info.changed_bitmask & CM_WCDMA_MONITORED_SET_BIT_MASK ) )
  {

    QCRIL_LOG_DEBUG( "%s", "Received WCDMA neighbor info\n");
    /* Remove old GSM nmr_info */
    memset( &i_ptr->nmr_info, 0, sizeof( i_ptr->nmr_info ) );

    /* Store 6 strongest of wcdma_monitored_set_info */
    i_ptr->monitored_set_info.num_of_items = 0;
    weakest = -1;

    for( fre = 0; fre < stats_info_ptr->prm.wcdma_info.wcdma_event_info.wcdma_monitored_set_info.num_of_freqs; fre++ )
    {
      for( c = 0; c < stats_info_ptr->prm.wcdma_info.wcdma_event_info.wcdma_monitored_set_info.freq[fre].num_of_cells; c++ )
      {
        QCRIL_LOG_DEBUG("Checking freq[%d].cell[%d], with rscp %d\n", fre, c, stats_info_ptr->prm.wcdma_info.wcdma_event_info.wcdma_monitored_set_info.freq[fre].cell[c].rscp);
        /* Store cells until full, then replace with stronger */
        if( i_ptr->monitored_set_info.num_of_items < QCRIL_CM_MAX_WCDMA_MONITORED )
        {
          i_ptr->monitored_set_info.strongest[i_ptr->monitored_set_info.num_of_items] = 
            stats_info_ptr->prm.wcdma_info.wcdma_event_info.wcdma_monitored_set_info.freq[fre].cell[c];
          /* Storing first neighbor, set as weakest */
          if( i_ptr->monitored_set_info.num_of_items == 0 )
          {
            weakest = i_ptr->monitored_set_info.num_of_items;
          }
          /* Check if newest stored is weakest */
          else if( i_ptr->monitored_set_info.strongest[i_ptr->monitored_set_info.num_of_items].rscp <
                   i_ptr->monitored_set_info.strongest[weakest].rscp )
          {
            weakest = i_ptr->monitored_set_info.num_of_items;
          }
          i_ptr->monitored_set_info.num_of_items++;
        }
        else
        {
          /* Determine if cell is stronger than weakest already stored */
          if( stats_info_ptr->prm.wcdma_info.wcdma_event_info.wcdma_monitored_set_info.freq[fre].cell[c].rscp > 
              i_ptr->monitored_set_info.strongest[weakest].rscp )
          {
            QCRIL_LOG_DEBUG( "Stronger cell than %d found\n", i_ptr->monitored_set_info.strongest[weakest].rscp);
            i_ptr->monitored_set_info.strongest[weakest] = 
              stats_info_ptr->prm.wcdma_info.wcdma_event_info.wcdma_monitored_set_info.freq[fre].cell[c];

            /* Find the new weakest */
            for( i = 0; i < i_ptr->monitored_set_info.num_of_items; i++ )
            {
              if( i_ptr->monitored_set_info.strongest[i].rscp < i_ptr->monitored_set_info.strongest[weakest].rscp )
              {
                QCRIL_LOG_DEBUG( "New weakest is %d\n", i_ptr->monitored_set_info.strongest[i].rscp );
                weakest = i;
              }
            }
          }
        }
        QCRIL_ASSERT( weakest < QCRIL_CM_MAX_WCDMA_MONITORED );
      }
    }
    QCRIL_LOG_DEBUG( "%s", "Saved WCDMA monitored set info\n" );
  }

  QCRIL_MUTEX_UNLOCK( &i_ptr->ss_mutex, details );
  #endif /* FEATURE_QCRIL_NCELL */
                                                              
} /* qcril_cm_stats_event_modem_info */

//To get eme_cbm status
cm_ph_state_e_type qcril_cm_get_eme_cbm(qcril_instance_id_e_type id)
{
   qcril_cm_struct_type *i_ptr;

   QCRIL_ASSERT( id < QCRIL_MAX_INSTANCE_ID );
   i_ptr = &qcril_cm[ id ];
   return i_ptr->emer_cb_state;
}
